<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="c++11"><meta name="keywords" content="C/C++"><meta name="author" content="hero576"><meta name="copyright" content="hero576"><title>c++11 | void land space</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5ff8fca367285c16c6dd5c16ca2ccc1b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.0.2'
} </script><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="void land space" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text"> 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text"> 配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">2.</span> <span class="toc-text"> 类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">2.1.</span> <span class="toc-text"> auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">2.2.</span> <span class="toc-text"> decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%BD%E8%B8%AA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text"> 追踪返回类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%93%E7%94%A8%E6%80%A7%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">3.</span> <span class="toc-text"> 易用性的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text"> 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%86%85%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 类内成员初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 列表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%AA%84"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 防止类型收窄</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.2.</span> <span class="toc-text"> 基于范围的for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="toc-number">3.3.</span> <span class="toc-text"> 静态断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#noexcept%E4%BF%AE%E9%A5%B0%E7%AC%A6vs2013%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="toc-number">3.4.</span> <span class="toc-text"> noexcept修饰符(vs2013不支持)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nullptr"><span class="toc-number">3.5.</span> <span class="toc-text"> nullptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.6.</span> <span class="toc-text"> 强类型枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8Fvs2013-%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="toc-number">3.7.</span> <span class="toc-text"> 常量表达式(vs2013 不支持)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8Fvs2013-%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="toc-number">3.8.</span> <span class="toc-text"> 用户定义字面量(vs2013 不支持)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">3.9.</span> <span class="toc-text"> 原生字符串字面值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">4.</span> <span class="toc-text"> 类的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0vs2013-%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="toc-number">4.1.</span> <span class="toc-text"> 继承构造(vs2013 不支持)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-number">4.2.</span> <span class="toc-text"> 委托构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%8E%A7%E5%88%B6final%E5%92%8Coverride"><span class="toc-number">4.3.</span> <span class="toc-text"> 继承控制：final和override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6default-%E5%92%8C-delete%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text"> 类默认函数的控制：“default” 和 &quot;delete&quot;函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#default%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text"> &quot;&#x3D;default&quot;函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text"> &quot;&#x3D;delete&quot;函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">5.</span> <span class="toc-text"> 模板的改进</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7%E6%94%B9%E8%BF%9B"><span class="toc-number">5.1.</span> <span class="toc-text"> 右尖括号&gt;改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">5.2.</span> <span class="toc-text"> 模板的别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text"> 函数模板的默认模板参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.</span> <span class="toc-text"> 可变参数的模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text"> 可变参数模板函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.1.</span> <span class="toc-text"> 可变参数模板函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%85%E7%9A%84%E5%B1%95%E5%BC%80"><span class="toc-number">6.1.2.</span> <span class="toc-text"> 参数包的展开</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%B1%95%E5%BC%80"><span class="toc-number">6.1.2.1.</span> <span class="toc-text"> 递归方式展开</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%B1%95%E5%BC%80"><span class="toc-number">6.1.2.2.</span> <span class="toc-text"> 非递归方式展开</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text"> 可变参数模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%B1%95%E5%BC%80%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-number">6.2.1.</span> <span class="toc-text"> 继承方式展开参数包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%80%92%E5%BD%92%E5%92%8C%E7%89%B9%E5%8C%96%E6%96%B9%E5%BC%8F%E5%B1%95%E5%BC%80%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-number">6.2.2.</span> <span class="toc-text"> 模板递归和特化方式展开参数包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text"> 右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text"> 左值引用、右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 左值、右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-2"><span class="toc-number">7.1.2.</span> <span class="toc-text"> 左值引用、右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text"> 移动语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">7.2.1.</span> <span class="toc-text"> 为什么需要移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.2.</span> <span class="toc-text"> 移动语义定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.3.</span> <span class="toc-text"> 转移构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.4.</span> <span class="toc-text"> 转移赋值函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0-stdmove"><span class="toc-number">7.3.</span> <span class="toc-text"> 标准库函数 std::move</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91-stdforward"><span class="toc-number">7.4.</span> <span class="toc-text"> 完美转发 std::forward</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text"> 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#unique_ptr"><span class="toc-number">8.1.</span> <span class="toc-text"> unique_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared_ptr"><span class="toc-number">8.2.</span> <span class="toc-text"> shared_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak_ptr"><span class="toc-number">8.3.</span> <span class="toc-text"> weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.</span> <span class="toc-text"> 闭包的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">9.1.</span> <span class="toc-text"> 什么是闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">9.2.</span> <span class="toc-text"> 闭包的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-operator"><span class="toc-number">9.2.1.</span> <span class="toc-text"> 仿函数：重载 operator()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdbind%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">9.2.2.</span> <span class="toc-text"> std::bind绑定器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stdfunction"><span class="toc-number">9.2.2.1.</span> <span class="toc-text"> std::function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stdbind"><span class="toc-number">9.2.2.2.</span> <span class="toc-text"> std::bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stdbind%E5%92%8Cstdfunction%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">9.2.2.3.</span> <span class="toc-text"> std::bind和std::function配合使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.2.3.</span> <span class="toc-text"> lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">9.2.3.1.</span> <span class="toc-text"> lambda基础使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E4%B8%8E%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.3.2.</span> <span class="toc-text"> lambda与仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.2.3.3.</span> <span class="toc-text"> lambda类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E4%BC%98%E5%8A%BF"><span class="toc-number">9.2.3.4.</span> <span class="toc-text"> lambda优势</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text"> 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.1.</span> <span class="toc-text"> 线程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">10.1.1.</span> <span class="toc-text"> 线程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90"><span class="toc-number">10.1.2.</span> <span class="toc-text"> 回收线程资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8Bid%E5%92%8Ccpu%E6%A0%B8%E5%BF%83%E6%95%B0"><span class="toc-number">10.1.3.</span> <span class="toc-text"> 获取线程ID和CPU核心数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">10.2.</span> <span class="toc-text"> 互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 为什么需要互斥量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E4%BA%92%E6%96%A5%E9%87%8Fstdmutex"><span class="toc-number">10.2.2.</span> <span class="toc-text"> 独占互斥量std::mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.3.</span> <span class="toc-text"> 原子操作</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/haimianbaobao.jpg"></div><div class="author-info__name text-center">hero576</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">80</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">void land space</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">c++11</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/programme/"> programme</a></div><div class="article-container" id="post-content"><blockquote></blockquote>
<a id="more"></a>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<ul>
<li>g++在版本中配置：<code>-std=c++11</code></li>
<li>qt中配置：<code>CONFIG+=c++11</code></li>
<li>cmake-g++：<code>set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)</code></li>
</ul>
<h1 id="类型推导"><a class="markdownIt-Anchor" href="#类型推导"></a> 类型推导</h1>
<h2 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h2>
<ul>
<li>在C中，auto修饰局部变量，局部变量也叫auto变量，自动变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">auto</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++11, auto根据用户初始化内容自动推导类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.push_back(<span class="number">1</span>);a.push_back(<span class="number">2</span>);a.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i=a.begin();i!=a.end();i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong></p>
<ol>
<li>定义变量时，必须初始化：<code>auto a;a = 10;</code></li>
<li>vs2013不支持，函数形参是auto变量, qt可以：<code>void func(auto a)</code></li>
<li>auto变量不能作为自定义类型的成员变量：<code>struct Test&#123;int a;auto b = 10;//不允许xxxx&#125;;</code></li>
<li>不能是auto数组：<code>auto b[3] = &#123; 1, 2, 3 &#125;;</code></li>
<li>模板实例化类型不能是auto类型：<code>vector&lt;auto&gt; b = &#123; 1 &#125;;</code></li>
</ol>
<h2 id="decltype"><a class="markdownIt-Anchor" href="#decltype"></a> decltype</h2>
<ul>
<li>decltype实际上有点像auto的反函数， auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到其类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; //使用typeid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">decltype</span>(i) j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(j).name() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 打印出&quot;i&quot;, g++表示integer</span></span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">decltype</span>(a + b) c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(c).name() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 打印出&quot;d&quot;, g++表示double</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.begin())</span> vectype</span>; <span class="comment">// decltype(vec.begin()) 改名为 vectype</span></span><br><span class="line">    vectype k;  </span><br><span class="line">    <span class="comment">//decltype(vec.begin()) k;  </span></span><br><span class="line">    <span class="keyword">for</span> (k = vec.begin(); k &lt; vec.end(); k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 做一些事情</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> &#123;Ok, Error, Warning&#125;flag;   <span class="comment">// 匿名的枚举变量</span></span><br><span class="line">    <span class="keyword">decltype</span>(flag) tmp = Ok;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="追踪返回类型"><a class="markdownIt-Anchor" href="#追踪返回类型"></a> 追踪返回类型</h2>
<ul>
<li>返回类型后置：在函数名和参数列表后面指定返回类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">auto func2(int, int) -&gt; int;</span><br><span class="line">auto func3(int, double) -&gt; decltype(a+b);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto sum(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 + t2)&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto mul(const T1 &amp; t1, const T2 &amp; t2) -&gt; decltype(t1 * t2)&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 * t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">3</span>;<span class="keyword">auto</span> b = <span class="number">4L</span>;<span class="keyword">auto</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = mul( sum(a, b), pi );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 21.98</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="易用性的改进"><a class="markdownIt-Anchor" href="#易用性的改进"></a> 易用性的改进</h1>
<h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2>
<h3 id="类内成员初始化"><a class="markdownIt-Anchor" href="#类内成员初始化"></a> 类内成员初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> i) : a(i) <span class="comment">//初始化列表给m初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//a =  i;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> data&#123; <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> data2 = <span class="number">1</span>;<span class="comment">// 使用&quot;=&quot;初始化非静态普通成员，也可以 int data&#123;1&#125;;</span></span><br><span class="line">	A tmp&#123; <span class="number">10</span> &#125;;<span class="comment">// 对象成员，创建对象时，可以使用&#123;&#125;来调用构造函数</span></span><br><span class="line">	<span class="built_in">string</span> name&#123; <span class="string">&quot;mike&quot;</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="列表初始化"><a class="markdownIt-Anchor" href="#列表初始化"></a> 列表初始化</h3>
<ul>
<li>C++11引入了一个新的初始化方式，称为初始化列表(List Initialize)，具体的初始化方式如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = &#123;<span class="number">1</span>&#125;;  </span><br><span class="line"><span class="keyword">int</span> j&#123;<span class="number">3</span>&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>初始化列表可以用于初始化结构体类型，例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name;  </span><br><span class="line">  <span class="keyword">int</span> age;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Person p = &#123;<span class="string">&quot;Frank&quot;</span>, <span class="number">25</span>&#125;;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>其他一些不方便初始化的地方使用，比如std<vector>的初始化，如果不使用这种方式，只能用构造函数来初始化，难以达到效果：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec1</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2 = &#123;<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//不使用列表初始化用构造函数难以实现  </span></span><br></pre></td></tr></table></figure>
<h3 id="防止类型收窄"><a class="markdownIt-Anchor" href="#防止类型收窄"></a> 防止类型收窄</h3>
<ul>
<li>类型收窄指的是导致数据内容发生变化或者精度丢失的隐式类型转换。使用列表初始化在编译过程中会对数据进行校验，发生精度丢失则报错，可以防止类型收窄。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> a = x;                 <span class="comment">// 收窄，但可以通过编译</span></span><br><span class="line">    <span class="keyword">char</span>* b = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">1024</span>);   <span class="comment">// 收窄，但可以通过编译</span></span><br><span class="line">    <span class="keyword">char</span> c = &#123; x &#125;;             <span class="comment">// err, 收窄，无法通过编译</span></span><br><span class="line">    <span class="keyword">char</span> d = &#123; y &#125;;             <span class="comment">// 可以通过编译</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e&#123; <span class="number">-1</span> &#125;;      <span class="comment">// err,收窄，无法通过编译</span></span><br><span class="line">    <span class="keyword">float</span> f&#123; <span class="number">7</span> &#125;;               <span class="comment">// 可以通过编译</span></span><br><span class="line">    <span class="keyword">int</span> g&#123; <span class="number">2.0f</span> &#125;;              <span class="comment">// err,收窄，无法通过编译</span></span><br><span class="line">    <span class="keyword">float</span> * h = <span class="keyword">new</span> <span class="keyword">float</span>&#123; <span class="number">1e48</span> &#125;;  <span class="comment">// err,收窄，无法通过编译</span></span><br><span class="line">    <span class="keyword">float</span> i = <span class="number">1.2l</span>;                 <span class="comment">// 可以通过编译</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于范围的for循环"><a class="markdownIt-Anchor" href="#基于范围的for循环"></a> 基于范围的for循环</h2>
<ul>
<li>在C++中for循环可以使用基于范围的for循环，示例代码如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp; e: a)&#123;</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp; e: a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用基于范围的for循环，其for循环迭代的范围必须是可确定的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;<span class="comment">//形参中数组是指针变量，无法确定元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e: a) &#123;<span class="comment">// err, 编译失败</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    func(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态断言"><a class="markdownIt-Anchor" href="#静态断言"></a> 静态断言</h2>
<ul>
<li>C/C++提供了调试工具assert，这是一个宏，用于在运行阶段对断言进行检查，如果条件为真，执行程序，否则调用abort()。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果条件为真，程序正常执行，如果为假，终止程序，提示错误</span></span><br><span class="line">    assert(flag == <span class="literal">true</span>); <span class="comment">//#include &lt;cassert&gt;或#include &lt;assert.h&gt;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++ 11新增了关键字static_assert，可用于在编译阶段对断言进行测试。</li>
</ul>
<p><strong>静态断言的好处</strong></p>
<ul>
<li>
<p>更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低</p>
</li>
<li>
<p>减少运行时开销，静态断言是编译期检测的，减少了运行时开销</p>
</li>
<li>
<p>语法：<code>static_assert(常量表达式，提示字符串)</code></p>
</li>
</ul>
<blockquote>
<p>注意：只能是常量表达式，不能是变量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//该static_assert用来确保编译仅在32位的平台上进行，不支持64位的平台</span></span><br><span class="line">    <span class="keyword">static_assert</span>( <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)== <span class="number">4</span>, <span class="string">&quot;64-bit code generation is not supported.&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="noexcept修饰符vs2013不支持"><a class="markdownIt-Anchor" href="#noexcept修饰符vs2013不支持"></a> noexcept修饰符(vs2013不支持)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span> <span class="comment">//只能够抛出 int 和char类型的异常</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//C++11已经弃用这个声明</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockThrow</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> <span class="comment">//代表此函数不能抛出异常，如果抛出，就会异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代表此函数不能抛出异常，如果抛出，就会异常</span></span><br><span class="line"><span class="comment">//C++11 使用noexcept替代throw()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockThrowPro</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nullptr"><a class="markdownIt-Anchor" href="#nullptr"></a> nullptr</h2>
<ul>
<li>nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">&quot; a = &quot;</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">&quot; p = &quot;</span> &lt;&lt; p &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;equal\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int a = nullptr; //err, 编译失败，nullptr不能转型为int</span></span><br><span class="line">    func(<span class="number">0</span>); <span class="comment">//调用func(int)， 就算写NULL，也是调用这个</span></span><br><span class="line">    func(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强类型枚举"><a class="markdownIt-Anchor" href="#强类型枚举"></a> 强类型枚举</h2>
<ul>
<li>C++ 11引入了一种新的枚举类型，即“枚举类”，又称“强类型枚举”。声明请类型枚举非常简单，只需要在enum后加上使用class或struct。如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Old&#123;Yes, No&#125;;          <span class="comment">// old style</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">New</span>&#123;</span>Yes, No&#125;;    <span class="comment">// new style</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span> <span class="title">New2</span>&#123;</span>Yes, No&#125;;  <span class="comment">// new style</span></span><br></pre></td></tr></table></figure>
<ul>
<li>“传统”的C++枚举类型有一些缺点：它会在一个代码区间中抛出枚举类型成员（如果在相同的代码域中的两个枚举类型具有相同名字的枚举成员，这会导致命名冲突），它们会被隐式转换为整型，并且不可以指定枚举的底层数据类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Status&#123;Ok, Error&#125;;</span><br><span class="line">    <span class="comment">//enum Status2&#123;Ok, Error&#125;;//err, 导致命名冲突, Status已经有成员叫Ok, Error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在C++11中，强类型枚举解决了这些问题：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span> &#123;</span>Ok, Error&#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span> <span class="title">Status2</span>&#123;</span>Ok, Error&#125;;</span><br><span class="line">    <span class="comment">//Status flag2 = Ok; // err，必须使用强类型名称</span></span><br><span class="line">    Status flag3 = Status::Ok;</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">char</span> &#123; C1 = <span class="number">1</span>, C2 = <span class="number">2</span>&#125;;<span class="comment">//指定枚举的底层数据类型</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123; D1 = <span class="number">1</span>, D2 = <span class="number">2</span>, Dbig = <span class="number">0xFFFFFFF0</span>U &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(C::C1) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(D::D1) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(D::Dbig) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量表达式vs2013-不支持"><a class="markdownIt-Anchor" href="#常量表达式vs2013-不支持"></a> 常量表达式(vs2013 不支持)</h2>
<ul>
<li>常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。</li>
<li>这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时都计算。</li>
<li>使用constexpr，你可以创建一个编译时的函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">GetConst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[ GetConst() ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; e1 = GetConst(), e2 &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = GetConst();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>constexpr函数的限制</strong></p>
<ul>
<li>函数中只能有一个return语句（有极少特例）</li>
<li>函数必须返回值（不能是void函数）</li>
<li>在使用前必须已有定义</li>
<li>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//err,函数中只能有一个return语句</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">data2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一个constexpr函数，只允许包含一行可执行代码</span></span><br><span class="line">    <span class="comment">//但允许包含typedef、 using 指令、静态断言等。</span></span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="number">1</span>, <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">data3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;<span class="comment">//err, return返回语句表达式中不能使用非常量表达式的函数、全局数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//函数声明，定义放在main函数后面</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> c = func();  <span class="comment">//err, 无法通过编译, 在使用前必须已有定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量表达式的构造函数有以下限制：
<ul>
<li>函数体必须为空</li>
<li>初始化列表只能由常量表达式来赋值</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    constexpr Date(int y, int m, int d): year(y), month(m), day(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">GetYear</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> year; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">GetMonth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">GetDay</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> Date PRCfound &#123;<span class="number">1949</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> foundmonth = PRCfound.GetMonth();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foundmonth &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户定义字面量vs2013-不支持"><a class="markdownIt-Anchor" href="#用户定义字面量vs2013-不支持"></a> 用户定义字面量(vs2013 不支持)</h2>
<ul>
<li>用户自定义字面值，或者叫“自定义后缀”更直观些，主要作用是简化代码的读写。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _mm(<span class="keyword">long</span> <span class="keyword">double</span> x) &#123; <span class="keyword">return</span> x / <span class="number">1000</span>; &#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _m(<span class="keyword">long</span> <span class="keyword">double</span> x)  &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _km(<span class="keyword">long</span> <span class="keyword">double</span> x) &#123; <span class="keyword">return</span> x * <span class="number">1000</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; operate<span class="string">&quot;&quot;</span> _mm(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0.001传统方式，不推荐</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1.0</span>_mm &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0.001</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1.0</span>_m  &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1.0</span>_km &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据 C++ 11 标准，只有下面参数列表才是合法的：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *  <span class="comment">//字符或者指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> </span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *, <span class="keyword">size_t</span>  <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">wchar_t</span> <span class="keyword">const</span> *, <span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">char16_t</span> <span class="keyword">const</span> *, <span class="keyword">size_t</span></span><br><span class="line"><span class="keyword">char32_t</span> <span class="keyword">const</span> *, <span class="keyword">size_t</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后四个对于字符串相当有用，因为第二个参数会自动推断为字符串的长度。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _len(<span class="keyword">char</span> <span class="keyword">const</span> * str, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mike&quot;</span>_len &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//结果为4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于参数char const *，应该被称为原始字面量 raw literal 操作符。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _r(<span class="keyword">char</span> <span class="keyword">const</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">250</span>_r &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//结果为250</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原生字符串字面值"><a class="markdownIt-Anchor" href="#原生字符串字面值"></a> 原生字符串字面值</h2>
<ul>
<li>原生字符串字面值(raw string literal)使用户书写的字符串“所见即所得”。C++11中原生字符串的声明相当简单，只需在字符串前加入前缀，即字母R，并在引号中使用括号左右标识，就可以声明该字符串字面量为原生字符串了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">R&quot;(hello,\n</span></span><br><span class="line"><span class="string">         world)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的改进"><a class="markdownIt-Anchor" href="#类的改进"></a> 类的改进</h1>
<h2 id="继承构造vs2013-不支持"><a class="markdownIt-Anchor" href="#继承构造vs2013-不支持"></a> 继承构造(vs2013 不支持)</h2>
<ul>
<li>C++ 11允许派生类继承基类的构造函数（默认构造函数、复制构造函数、移动构造函数除外）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">double</span> d, <span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">float</span> f, <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">char</span>* c) &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::A; <span class="comment">// 继承构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ExtraInterface</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>继承的构造函数只能初始化基类中的成员变量，不能初始化派生类的成员变量</li>
<li>如果基类的构造函数被声明为私有，或者派生类是从基类中虚继承，那么不能继承构造函数</li>
<li>一旦使用继承构造函数，编译器不会再为派生类生成默认构造函数</li>
</ul>
<h2 id="委托构造"><a class="markdownIt-Anchor" href="#委托构造"></a> 委托构造</h2>
<ul>
<li>和继承构造函数类似，委托构造函数也是C<ins>11中对C</ins>的构造函数的一项改进，其目的也是为了减少程序员书写构造函数的时间。</li>
<li>如果一个类包含多个构造函数，C++ 11允许在一个构造函数中的定义中使用另一个构造函数，但这必须通过初始化列表进行操作，如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Info() : Info(<span class="number">1</span>) &#123; &#125;    <span class="comment">// 委托构造函数</span></span><br><span class="line">    Info(<span class="keyword">int</span> i) : Info(i, <span class="string">&#x27;a&#x27;</span>) &#123; &#125; <span class="comment">// 既是目标构造函数，也是委托构造函数</span></span><br><span class="line">    Info(<span class="keyword">char</span> e): Info(<span class="number">1</span>, e) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Info(<span class="keyword">int</span> i, <span class="keyword">char</span> e): type(i), name(e) &#123; <span class="comment">/* 其它初始化 */</span> &#125; <span class="comment">// 目标构造函数</span></span><br><span class="line">    <span class="keyword">int</span>  type;</span><br><span class="line">    <span class="keyword">char</span> name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="继承控制final和override"><a class="markdownIt-Anchor" href="#继承控制final和override"></a> 继承控制：final和override</h2>
<ul>
<li>C++11之前，一直没有继承控制关键字，禁用一个类的进一步衍生比较麻烦。</li>
<li>C++ 11添加了两个继承控制关键字：final和override。
<ul>
<li>final阻止类的进一步派生和虚函数的进一步重写</li>
<li>override确保在派生类中声明的函数跟基类的虚函数有相同的签名，要求一模一样</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="title">final</span> &#123;</span>&#125;; <span class="comment">// 此类不能被继承</span></span><br><span class="line"><span class="comment">//class D1: public B1 &#123;&#125;; // error!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  virtual void func() override // error! 指定了重写但实际并没重写,没有基类</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span>      <span class="comment">// ok! 隐藏,由于没有重写同名函数B::f,在D中变为不可见</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hiding: &quot;</span> &lt;&lt;__func__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  virtual void f() override   // error! 指定了重写但实际并没重写,类型声明不完全相同</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> <span class="comment">// ok! 指定了重写实际上也重写了，同时，指定为最终，后代类中不能再重写此虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span>      <span class="comment">// ok! 重写B::f(),同时,由于没有重写D::f(int),在D2中变不可见</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  virtual void fun() // error! 基类的此虚函数被指定为最终,不能被重写,虽然没有显示指定&quot;override&quot;</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  virtual void fun() override // error! 基类的此虚函数被指定为最终，不能被重写</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout &lt;&lt; __func__ &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类默认函数的控制default-和-delete函数"><a class="markdownIt-Anchor" href="#类默认函数的控制default-和-delete函数"></a> 类默认函数的控制：“default” 和 &quot;delete&quot;函数</h2>
<h3 id="default函数"><a class="markdownIt-Anchor" href="#default函数"></a> &quot;=default&quot;函数</h3>
<ul>
<li>C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。</li>
<li>但是，如果程序员为类显式的自定义了非默认构造函数，编译器将不再会为它隐式地生成默认无参构造函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    X()&#123;&#125;  <span class="comment">// 手动定义默认构造函数</span></span><br><span class="line"></span><br><span class="line">    X(<span class="keyword">int</span> i)</span><br><span class="line">    &#123; </span><br><span class="line">        a = i; </span><br><span class="line">    &#125;      </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line">X obj; <span class="comment">//必须手动定义默认构造函数X()&#123;&#125; 才能编译通过</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>原本期望编译器自动生成的默认构造函数却需要程序员手动编写，即程序员的工作量加大了。此外，手动编写的默认构造函数的代码执行效率比编译器自动生成的默认构造函数低。</p>
</li>
<li>
<p>类的其它几类特殊成员函数也和默认构造函数一样，当存在用户自定义的特殊成员函数时，编译器将不会隐式的自动生成默认特殊成员函数，而需要程序员手动编写，加大了程序员的工作量。类似的，手动编写的特殊成员函数的代码执行效率比编译器自动生成的特殊成员函数低。</p>
</li>
<li>
<p>C++11 标准引入了一个新特性：&quot;=default&quot;函数。程序员只需在函数声明后加上“=default;”，就可将该函数声明为 &quot;=default&quot;函数，编译器将为显式声明的 &quot;=default&quot;函数自动生成函数体。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    X()= <span class="keyword">default</span>; <span class="comment">//该函数比用户自己定义的默认构造函数获得更高的代码效率</span></span><br><span class="line">    X(<span class="keyword">int</span> i)</span><br><span class="line">    &#123; </span><br><span class="line">        a = i; </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">X obj;</span><br></pre></td></tr></table></figure>
<ul>
<li>&quot;=default&quot;函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。例如：
<ul>
<li>无参构造</li>
<li>拷贝构造</li>
<li>赋值运算符重载</li>
<li>析构函数</li>
<li>等</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="keyword">default</span>;      <span class="comment">// err , 函数 f() 非类 X 的特殊成员函数</span></span><br><span class="line">    X(<span class="keyword">int</span>, <span class="keyword">int</span>) = <span class="keyword">default</span>;  <span class="comment">// err , 构造函数 X(int, int) 非 X 的特殊成员函数</span></span><br><span class="line">    X(<span class="keyword">int</span> = <span class="number">1</span>) = <span class="keyword">default</span>;   <span class="comment">// err , 默认构造函数 X(int=1) 含有默认参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>&quot;=default&quot;函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X() = <span class="keyword">default</span>; <span class="comment">//Inline defaulted 默认构造函数</span></span><br><span class="line">    X(<span class="keyword">const</span> X&amp;);</span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp;);</span><br><span class="line">    ~X() = <span class="keyword">default</span>;  <span class="comment">//Inline defaulted 析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X::X(<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;  <span class="comment">//Out-of-line defaulted 拷贝构造函数</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>= (<span class="keyword">const</span> X&amp;) = <span class="keyword">default</span>;   <span class="comment">//Out-of-line defaulted  拷贝赋值操作符</span></span><br></pre></td></tr></table></figure>
<h3 id="delete函数"><a class="markdownIt-Anchor" href="#delete函数"></a> &quot;=delete&quot;函数</h3>
<ul>
<li>为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性：&quot;=delete&quot;函数。程序员只需在函数声明后上“=delete;”，就可将该函数禁用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X();</span><br><span class="line">    X(<span class="keyword">const</span> X&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 声明拷贝构造函数为 deleted 函数</span></span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X &amp;) = <span class="keyword">delete</span>; <span class="comment">// 声明拷贝赋值操作符为 deleted 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X obj1;</span><br><span class="line">    X obj2=obj1;   <span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line"></span><br><span class="line">    X obj3;</span><br><span class="line">    obj3=obj1;     <span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>&quot;=delete&quot;函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(<span class="keyword">double</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    X(<span class="keyword">int</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">obj1</span><span class="params">(<span class="number">1.2</span>)</span></span>;</span><br><span class="line">    <span class="function">X <span class="title">obj2</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// 错误，参数为整数 int 类型的转换构造函数被禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>&quot;=delete&quot;函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X *pa = <span class="keyword">new</span> X;      <span class="comment">// 错误，new 操作符被禁用</span></span><br><span class="line">    X *pb = <span class="keyword">new</span> X[<span class="number">10</span>];  <span class="comment">// 错误，new[] 操作符被禁用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板的改进"><a class="markdownIt-Anchor" href="#模板的改进"></a> 模板的改进</h1>
<h2 id="右尖括号改进"><a class="markdownIt-Anchor" href="#右尖括号改进"></a> 右尖括号&gt;改进</h2>
<ul>
<li>在C++98/03的泛型编程中，模板实例化有一个很繁琐的地方，就是连续两个右尖括号(&gt;&gt;)会被编译解释成右移操作符，而不是模板参数表的形式，需要一个空格进行分割，以避免发生编译时的错误。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt; <span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Y</span>&#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Y&lt;X&lt;<span class="number">1</span>&gt; &gt; x1;    <span class="comment">// ok, 编译成功</span></span><br><span class="line">    Y&lt;X&lt;<span class="number">2</span>&gt;&gt; x2;     <span class="comment">// err, 编译失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在实例化模板时会出现连续两个右尖括号，同样static_cast、dynamic_cast、reinterpret_cast、const_cast表达式转换时也会遇到相同的情况。C<ins>98标准是让程序员在&gt;&gt;之间填上一个空格，在C</ins>11中，这种限制被取消了。在C++11标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出&quot;&gt;&gt;&quot;是一个右移操作符还是模板参数表的结束标记。</li>
</ul>
<h2 id="模板的别名"><a class="markdownIt-Anchor" href="#模板的别名"></a> 模板的别名</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt; //std::is_same</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="keyword">using</span> sint = <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::is_same 判断类型是否一致</span></span><br><span class="line">    <span class="comment">//这个结构体作用很简单，就是两个一样的类型会返回true</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; is_same&lt;uint, UINT&gt;::value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数模板的默认模板参数"><a class="markdownIt-Anchor" href="#函数模板的默认模板参数"></a> 函数模板的默认模板参数</h2>
<ul>
<li>C++11之前，类模板是支持默认的模板参数，却不支持函数模板的默认模板参数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、普通函数带默认参数，c++98 编译通过，c++11 编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DefParm</span><span class="params">(<span class="keyword">int</span> m = <span class="number">3</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//2、类模板是支持默认的模板参数，c++98 编译通过，c++11 编译通过</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line">class DefClass &#123;&#125;;</span><br><span class="line"><span class="comment">//3、函数模板的默认模板参数， c++98 - 编译失败，c++11 - 编译通过</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt; <span class="keyword">void</span> DefTempParm() &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类模板的默认模板参数必须从右往左定义，数模板的默认模板参数则没这个限定：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span> = <span class="title">int</span>&gt; <span class="title">class</span> <span class="title">DefClass1</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span> = <span class="title">int</span>, <span class="title">class</span> <span class="title">T2</span>&gt; <span class="title">class</span> <span class="title">DefClass2</span>;</span>   <span class="comment">// 无法通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">i</span> = 0&gt; <span class="title">class</span> <span class="title">DefClass3</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i = <span class="number">0</span>, class T&gt; class DefClass4;         <span class="comment">// 无法通过编译</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1 </span>= <span class="keyword">int</span>, <span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt; <span class="title">void</span> <span class="title">DefFunc1</span>(<span class="title">T1</span> <span class="title">a</span>, <span class="title">T2</span> <span class="title">b</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">int</span> i </span>= <span class="number">0</span>, <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">DefFunc2</span>(<span class="title">T</span> <span class="title">a</span>);</span></span><br></pre></td></tr></table></figure>
<h1 id="可变参数的模板"><a class="markdownIt-Anchor" href="#可变参数的模板"></a> 可变参数的模板</h1>
<ul>
<li>
<p>在C<ins>11之前，类模板和函数模板只能含有固定数量的模板参数。C</ins>11增强了模板功能，允许模板定义中包含0到任意个模板参数，这就是可变参数模板。</p>
</li>
<li>
<p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在typename或class后面带上省略号“…”：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">template&lt;class ... T&gt; void func(T ... args)//T叫模板参数包，args叫函数参数包</span><br><span class="line">&#123;<span class="comment">//可变参数模板函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();    <span class="comment">// OK：args不含有任何实参</span></span><br><span class="line">func(<span class="number">1</span>);    <span class="comment">// OK：args含有一个实参：int</span></span><br><span class="line">func(<span class="number">2</span>, <span class="number">1.0</span>);   <span class="comment">// OK：args含有两个实参int和double</span></span><br></pre></td></tr></table></figure>
<ul>
<li>省略号“…”的作用有两个：
<ol>
<li>声明一个参数包，这个参数包中可以包含0到任意个模板参数</li>
<li>在模板定义的右边，可以将参数包展开成一个一个独立的参数</li>
</ol>
</li>
</ul>
<h2 id="可变参数模板函数"><a class="markdownIt-Anchor" href="#可变参数模板函数"></a> 可变参数模板函数</h2>
<h3 id="可变参数模板函数的定义"><a class="markdownIt-Anchor" href="#可变参数模板函数的定义"></a> 可变参数模板函数的定义</h3>
<ul>
<li>一个可变参数模板函数的定义如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">template&lt;class ... T&gt; void func(T ... args)</span><br><span class="line">&#123;<span class="comment">//可变参数模板函数</span></span><br><span class="line">    <span class="comment">//sizeof...（sizeof后面有3个小点）计算变参个数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();     <span class="comment">// num = 0</span></span><br><span class="line">    func(<span class="number">1</span>);    <span class="comment">// num = 1</span></span><br><span class="line">    func(<span class="number">2</span>, <span class="number">1.0</span>);   <span class="comment">// num = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数包的展开"><a class="markdownIt-Anchor" href="#参数包的展开"></a> 参数包的展开</h3>
<h4 id="递归方式展开"><a class="markdownIt-Anchor" href="#递归方式展开"></a> 递归方式展开</h4>
<ul>
<li>通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归终止函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;empty\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> ... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">debug</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">Args</span> ... <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;parameter &quot;</span> &lt;&lt; first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    debug(last...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    debug(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    运行结果：</span></span><br><span class="line"><span class="comment">        parameter 1</span></span><br><span class="line"><span class="comment">        parameter 2</span></span><br><span class="line"><span class="comment">        parameter 3</span></span><br><span class="line"><span class="comment">        parameter 4</span></span><br><span class="line"><span class="comment">        empty</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归调用过程如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">debug(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">debug(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">debug(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">debug(<span class="number">4</span>);</span><br><span class="line">debug();</span><br></pre></td></tr></table></figure>
<h4 id="非递归方式展开"><a class="markdownIt-Anchor" href="#非递归方式展开"></a> 非递归方式展开</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">expand</span>(<span class="title">Args</span> ... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; (print(args), <span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    expand(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>expand函数的逗号表达式：(print(args), 0)， 也是按照这个执行顺序，先执行print(args)，再得到逗号表达式的结果0。</p>
</li>
<li>
<p>同时，通过初始化列表来初始化一个变长数组，{ (print(args), 0)… }将会展开成( (print(args1), 0), (print(args2), 0), (print(args3), 0), etc…), 最终会创建一个元素只都为0的数组int a[sizeof…(args)]。</p>
</li>
</ul>
<h2 id="可变参数模板类"><a class="markdownIt-Anchor" href="#可变参数模板类"></a> 可变参数模板类</h2>
<h3 id="继承方式展开参数包"><a class="markdownIt-Anchor" href="#继承方式展开参数包"></a> 继承方式展开参数包</h3>
<ul>
<li>可变参数模板类的展开一般需要定义2 ~ 3个类，包含类声明和特化的模板类：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... A&gt; <span class="class"><span class="keyword">class</span> <span class="title">BMW</span>&#123;</span>&#125;;  <span class="comment">// 变长模板的声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;  <span class="comment">// 递归的偏特化定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span>&lt;Head, Tail...&gt; :</span> <span class="keyword">public</span> BMW&lt;Tail...&gt;</span><br><span class="line">&#123;<span class="comment">//当实例化对象时，则会引起基类的递归构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BMW()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type: %s\n&quot;</span>, <span class="keyword">typeid</span>(Head).name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Head head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">BMW</span>&lt;&gt;&#123;</span>&#125;;  <span class="comment">// 边界条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BMW&lt;<span class="keyword">int</span>, <span class="keyword">char</span>, <span class="keyword">float</span>&gt; car;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    运行结果：</span></span><br><span class="line"><span class="comment">        type: f</span></span><br><span class="line"><span class="comment">        type: c</span></span><br><span class="line"><span class="comment">        type: i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板递归和特化方式展开参数包"><a class="markdownIt-Anchor" href="#模板递归和特化方式展开参数包"></a> 模板递归和特化方式展开参数包</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">long</span>... nums&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span>;</span><span class="comment">// 变长模板的声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">long</span> first, <span class="keyword">long</span>... last&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span>&lt;first, last...&gt; // 变长模板类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = first * Multiply&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span>&lt;&gt; // 边界条件</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> val = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Multiply&lt;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::val &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="右值引用"><a class="markdownIt-Anchor" href="#右值引用"></a> 右值引用</h1>
<h2 id="左值引用-右值引用"><a class="markdownIt-Anchor" href="#左值引用-右值引用"></a> 左值引用、右值引用</h2>
<h3 id="左值-右值"><a class="markdownIt-Anchor" href="#左值-右值"></a> 左值、右值</h3>
<ul>
<li>在C语言中，我们常常会提起左值（lvalue）、右值（rvalue）这样的称呼。一个最为典型的判别方法就是，在赋值表达式中，出现在等号左边的就是“左值”，而在等号右边的，则称为“右值”。如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a = a + b;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在这个赋值表达式中，a就是一个左值，而b + c则是一个右值。</p>
</li>
<li>
<p>不过C++中还有一个被广泛认同的说法，那就是可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。那么这个加法赋值表达式中，&amp;a是允许的操作，但&amp;(b + c)这样的操作则不会通过编译。因此a是一个左值，(b + c)是一个右值。</p>
</li>
<li>
<p>相对于左值，右值表示字面常量、表达式、函数的非引用返回值等。</p>
</li>
</ul>
<h3 id="左值引用-右值引用-2"><a class="markdownIt-Anchor" href="#左值引用-右值引用-2"></a> 左值引用、右值引用</h3>
<ul>
<li>
<p>左值引用是对一个左值进行引用的类型，右值引用则是对一个右值进行引用的类型。</p>
</li>
<li>
<p>左值引用和右值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。</p>
</li>
<li>
<p>左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p>
</li>
<li>
<p>左值引用：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       <span class="comment">// 左值引用绑定到右值，编译失败, err</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        <span class="comment">// 非常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; <span class="comment">// 常量左值引用绑定到非常量左值，编译通过, ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  <span class="comment">// 常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = c; <span class="comment">// 常量左值引用绑定到常量左值，编译通过, ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">2</span>; <span class="comment">// 常量左值引用绑定到右值，编程通过, ok</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>“const 类型 &amp;”为 “万能”的引用类型，它可以接受非常量左值、常量左值、右值对其进行初始化；</p>
</li>
<li>
<p>右值引用，使用&amp;&amp;表示：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; r1 = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; r2 = x + y;</span><br><span class="line">T &amp;&amp; a = ReturnRvalue();</span><br></pre></td></tr></table></figure>
<ul>
<li>通常情况下，右值引用是不能够绑定到任何的左值的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; d = c; <span class="comment">//err</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(<span class="keyword">int</span> &amp; i)</span> <span class="comment">//参数为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;LValue processed: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(<span class="keyword">int</span> &amp;&amp; i)</span> <span class="comment">//参数为右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;RValue processed: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    process_value(a); <span class="comment">//LValue processed: 0</span></span><br><span class="line">    process_value(<span class="number">1</span>); <span class="comment">//RValue processed: 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移动语义"><a class="markdownIt-Anchor" href="#移动语义"></a> 移动语义</h2>
<h3 id="为什么需要移动语义"><a class="markdownIt-Anchor" href="#为什么需要移动语义"></a> 为什么需要移动语义</h3>
<ul>
<li>
<p>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。</p>
</li>
<li>
<p>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。</p>
</li>
<li>
<p>通过转移语义，临时对象中的资源能够转移其它的对象里。</p>
</li>
</ul>
<h3 id="移动语义定义"><a class="markdownIt-Anchor" href="#移动语义定义"></a> 移动语义定义</h3>
<ul>
<li>
<p>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。</p>
</li>
<li>
<p>如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。</p>
</li>
<li>
<p>普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p>
</li>
</ul>
<h3 id="转移构造函数"><a class="markdownIt-Anchor" href="#转移构造函数"></a> 转移构造函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *tmp = <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    &#123;<span class="comment">//普通构造函数</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(tmp);  <span class="comment">//长度</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>]; <span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str, tmp); <span class="comment">//拷贝内容</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;普通构造函数 str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyString(<span class="keyword">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数 tmp.str = &quot;</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="comment">//参数是非const的右值引用</span></span><br><span class="line">    MyString(MyString &amp;&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        str = t.str; <span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">        len = t.len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原来指针置空</span></span><br><span class="line">        t.str = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//赋值运算符重载函数</span></span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先释放原来的内存</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新申请内容</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;赋值运算符重载函数 tmp.str = &quot;</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyString()</span><br><span class="line">    &#123;<span class="comment">//析构函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;已操作delete, str =  &quot;</span> &lt;&lt; str;</span><br><span class="line">            <span class="keyword">delete</span> []str;</span><br><span class="line">            str = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">func</span><span class="params">()</span> <span class="comment">//返回普通对象，不是引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">obj</span><span class="params">(<span class="string">&quot;mike&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyString &amp;&amp;tmp = func(); <span class="comment">//右值引用接收</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>和拷贝构造函数类似，有几点需要注意：</p>
<ul>
<li>参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”。</li>
<li>参数（右值）不可以是常量，因为我们需要修改右值。</li>
<li>参数（右值）的资源链接和标记必须修改，否则，右值的析构函数就会释放资源，转移到新对象的资源也就无效了。</li>
</ul>
</li>
<li>
<p>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。</p>
</li>
</ul>
<h3 id="转移赋值函数"><a class="markdownIt-Anchor" href="#转移赋值函数"></a> 转移赋值函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span> *tmp = <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    &#123;<span class="comment">//普通构造函数</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(tmp);  <span class="comment">//长度</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>]; <span class="comment">//堆区申请空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str, tmp); <span class="comment">//拷贝内容</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;普通构造函数 str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyString(<span class="keyword">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数 tmp.str = &quot;</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="comment">//参数是非const的右值引用</span></span><br><span class="line">    MyString(MyString &amp;&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        str = t.str; <span class="comment">//拷贝地址，没有重新申请内存</span></span><br><span class="line">        len = t.len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原来指针置空</span></span><br><span class="line">        t.str = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>= (<span class="keyword">const</span> MyString &amp;tmp)</span><br><span class="line">    &#123;<span class="comment">//赋值运算符重载函数</span></span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先释放原来的内存</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新申请内容</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, tmp.str);</span><br><span class="line"></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;赋值运算符重载函数 tmp.str = &quot;</span> &lt;&lt; tmp.str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动赋值函数</span></span><br><span class="line">    <span class="comment">//参数为非const的右值引用</span></span><br><span class="line">    MyString &amp;<span class="keyword">operator</span>=(MyString &amp;&amp;tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;tmp == <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先释放原来的内存</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">delete</span> []str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无需重新申请堆区空间</span></span><br><span class="line">        len = tmp.len;</span><br><span class="line">        str = tmp.str; <span class="comment">//地址赋值</span></span><br><span class="line">        tmp.str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;移动赋值函数\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyString()</span><br><span class="line">    &#123;<span class="comment">//析构函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;已操作delete, str =  &quot;</span> &lt;&lt; str;</span><br><span class="line">            <span class="keyword">delete</span> []str;</span><br><span class="line">            str = <span class="literal">NULL</span>;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">func</span><span class="params">()</span> <span class="comment">//返回普通对象，不是引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">obj</span><span class="params">(<span class="string">&quot;mike&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>; <span class="comment">//实例化一个对象</span></span><br><span class="line">    tmp = func();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标准库函数-stdmove"><a class="markdownIt-Anchor" href="#标准库函数-stdmove"></a> 标准库函数 std::move</h2>
<ul>
<li>既然编译器只对右值引用才能调用转移构造函数和转移赋值函数，而所有命名对象都只能是左值引用，如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用，怎么做呢？标准库提供了函数 std::move，这个函数以非常简单的方式将左值引用转换为右值引用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = a;      		<span class="comment">// 编译失败</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = <span class="built_in">std</span>::move(a);  	<span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<h2 id="完美转发-stdforward"><a class="markdownIt-Anchor" href="#完美转发-stdforward"></a> 完美转发 std::forward</h2>
<ul>
<li>
<p>完美转发适用于这样的场景：需要将一组参数原封不动的传递给另一个函数。</p>
</li>
<li>
<p>“原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：左值／右值和 const/non-const。完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样。在泛型函数中，这样的需求非常普遍。</p>
</li>
<li>
<p>下面举例说明：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T &amp;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const T &amp;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process_value(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process_value(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数 forward_value 为每一个参数必须重载两种类型，T&amp; 和 const T&amp;</span></span><br><span class="line">    forward_value(a); <span class="comment">// T&amp;</span></span><br><span class="line">    forward_value(b); <span class="comment">// const T &amp;</span></span><br><span class="line">    forward_value(<span class="number">2</span>); <span class="comment">// const T&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>对于一个参数就要重载两次，也就是函数重载的次数和参数的个数是一个正比的关系。这个函数的定义次数对于程序员来说，是非常低效的。</p>
</li>
<li>
<p>那C<ins>11是如何解决完美转发的问题的呢？实际上，C</ins>11是通过引入一条所谓“引用折叠”（reference collapsing）的新语言规则，并结合新的模板推导规则来完成完美转发。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> T &amp; TR;</span><br><span class="line">TR &amp;v = <span class="number">1</span>; <span class="comment">//在C++11中，一旦出现了这样的表达式，就会发生引用折叠，即将复杂的未知表达式折叠为已知的简单表达式</span></span><br></pre></td></tr></table></figure>
<ul>
<li>C++11中的引用折叠规则：</li>
</ul>
<table>
<thead>
<tr>
<th>TR的类型定义</th>
<th>声明v的类型</th>
<th>v的实际类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>T &amp;</td>
<td>TR</td>
<td>T &amp;</td>
</tr>
<tr>
<td>T &amp;</td>
<td>TR &amp;</td>
<td>T &amp;</td>
</tr>
<tr>
<td>T &amp;</td>
<td>TR &amp;&amp;</td>
<td>T &amp;</td>
</tr>
<tr>
<td>T &amp;&amp;</td>
<td>TR</td>
<td>T &amp;&amp;</td>
</tr>
<tr>
<td>T &amp;&amp;</td>
<td>TR &amp;</td>
<td>T &amp;</td>
</tr>
<tr>
<td>T &amp;&amp;</td>
<td>TR &amp;&amp;</td>
<td>T &amp;&amp;</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>一旦定义中出现了左值引用，引用折叠总是优先将其折叠为左值引用</p>
</li>
<li>
<p>C++11中，std::forward可以保存参数的左值或右值特性：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(T &amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T &amp;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(T &amp;&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T &amp;&amp;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const T &amp;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(<span class="keyword">const</span> T &amp;&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const T &amp;&amp;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(T &amp;&amp; val)</span> <span class="comment">//参数为右值引用&#123;</span></span></span><br><span class="line"><span class="function">    <span class="title">process_value</span><span class="params">( <span class="built_in">std</span>::forward&lt;T&gt;(val) )</span></span>;<span class="comment">//C++11中，std::forward可以保存参数的左值或右值特性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">1</span>;</span><br><span class="line">    forward_value(a); <span class="comment">// T &amp;</span></span><br><span class="line">    forward_value(b); <span class="comment">// const T &amp;</span></span><br><span class="line">    forward_value(<span class="number">2</span>); <span class="comment">// T &amp;&amp;</span></span><br><span class="line">    forward_value( <span class="built_in">std</span>::move(b) ); <span class="comment">// const T &amp;&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h1>
<ul>
<li>C++11中有unique_ptr、shared_ptr与weak_ptr等智能指针(smart pointer)，定义在<memory>中。可以对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</li>
</ul>
<h2 id="unique_ptr"><a class="markdownIt-Anchor" href="#unique_ptr"></a> unique_ptr</h2>
<ul>
<li>
<p>unique_ptr持有对对象的独有权，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p>
</li>
<li>
<p>unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。</p>
</li>
<li>
<p>离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>))</span></span>;   <span class="comment">// 无法复制的unique_ptr</span></span><br><span class="line">    <span class="comment">//unique_ptr&lt;int&gt; up2 = up1;        // err, 不能通过编译</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = move(up1);    <span class="comment">// 现在p3是数据的唯一的unique_ptr</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up3 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 11</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *up1 &lt;&lt; endl;   // err, 运行时错误</span></span><br><span class="line">    up3.reset();            <span class="comment">// 显式释放内存</span></span><br><span class="line">    up1.reset();            <span class="comment">// 不会导致运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *up3 &lt;&lt; endl;   // err, 运行时错误</span></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>))</span></span>;   <span class="comment">// 无法复制的unique_ptr</span></span><br><span class="line">    up4.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">44</span>)); <span class="comment">//&quot;绑定&quot;动态对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    up4 = <span class="literal">nullptr</span>;<span class="comment">//显式销毁所指对象，同时智能指针变为空指针。与up4.reset()等价</span></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up5</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">55</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> *p = up5.release(); <span class="comment">//只是释放控制权，不会释放内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *up5 &lt;&lt; endl; // err, 运行时错误</span></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">//释放堆区资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shared_ptr"><a class="markdownIt-Anchor" href="#shared_ptr"></a> shared_ptr</h2>
<ul>
<li>shared_ptr允许多个该智能指针共享第“拥有”同一堆分配对象的内存，这通过引用计数（reference counting）实现，会记录有多少个shared_ptr共同指向一个对象，一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>))</span></span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印引用计数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 22</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 22</span></span><br><span class="line">    sp1.reset();    <span class="comment">//显式让引用计数减1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印引用计数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 22</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="weak_ptr"><a class="markdownIt-Anchor" href="#weak_ptr"></a> weak_ptr</h2>
<ul>
<li>
<p>weak_ptr是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起引用计数的增加或减少。没有重载 * 和 -&gt; 但可以使用lock获得一个可用的shared_ptr对象</p>
</li>
<li>
<p>weak_ptr的使用更为复杂一点，它可以指向shared_ptr指针指向的对象内存，却并不拥有该内存，而使用weak_ptr成员lock，则可返回其指向内存的一个share_ptr对象，且在所指对象内存已经无效时，返回指针空值nullptr。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(weak_ptr&lt;<span class="keyword">int</span>&gt; &amp;wp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = wp.lock(); <span class="comment">// 转换为shared_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;still &quot;</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer is invalid&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">22</span>))</span></span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp2 = sp1;</span><br><span class="line">    weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp1; <span class="comment">// 指向shared_ptr&lt;int&gt;所指对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印计数器</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 22</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 22</span></span><br><span class="line">    check(wp);              <span class="comment">// still 22</span></span><br><span class="line">    sp1.reset();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 22</span></span><br><span class="line">    check(wp);              <span class="comment">// still 22</span></span><br><span class="line">    sp2.reset();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    check(wp);              <span class="comment">// pointer is invalid</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="闭包的实现"><a class="markdownIt-Anchor" href="#闭包的实现"></a> 闭包的实现</h1>
<h2 id="什么是闭包"><a class="markdownIt-Anchor" href="#什么是闭包"></a> 什么是闭包</h2>
<ul>
<li>
<p>闭包有很多种定义，一种说法是，闭包是带有上下文的函数。说白了，就是有状态的函数。更直接一些，不就是个类吗？换了个名字而已。</p>
</li>
<li>
<p>一个函数，带上了一个状态，就变成了闭包了。那什么叫 “带上状态” 呢？ 意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。</p>
</li>
<li>
<p>函数是代码，状态是一组变量，将代码和一组变量捆绑 (bind) ，就形成了闭包。</p>
</li>
<li>
<p>闭包的状态捆绑，必须发生在运行时。</p>
</li>
</ul>
<h2 id="闭包的实现-2"><a class="markdownIt-Anchor" href="#闭包的实现-2"></a> 闭包的实现</h2>
<h3 id="仿函数重载-operator"><a class="markdownIt-Anchor" href="#仿函数重载-operator"></a> 仿函数：重载 operator()</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunctor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyFunctor(<span class="keyword">int</span> tmp) : round(tmp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; <span class="keyword">return</span> tmp + round; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> round;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> round = <span class="number">2</span>;</span><br><span class="line">    <span class="function">MyFunctor <span class="title">f</span><span class="params">(round)</span></span>;<span class="comment">//调用构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result = &quot;</span> &lt;&lt; f(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//operator()(int tmp)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stdbind绑定器"><a class="markdownIt-Anchor" href="#stdbind绑定器"></a> std::bind绑定器</h3>
<h4 id="stdfunction"><a class="markdownIt-Anchor" href="#stdfunction"></a> std::function</h4>
<ul>
<li>
<p>在C++中，可调用实体主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对象，或者实现了opetator()的对象。</p>
</li>
<li>
<p>C<ins>11中，新增加了一个std::function类模板，它是对C</ins>中现有的可调用实体的一种类型安全的包裹。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   //std::cout</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//普通全局函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo_func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//类中静态函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;) -&gt;: &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//仿函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;) -&gt;: &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//绑定一个普通函数</span></span><br><span class="line">    function&lt; <span class="keyword">void</span>(<span class="keyword">void</span>) &gt; f1 = func;</span><br><span class="line">    f1();</span><br><span class="line">    <span class="comment">//绑定类中的静态函数</span></span><br><span class="line">    function&lt; <span class="keyword">int</span>(<span class="keyword">int</span>) &gt; f2 = Foo::foo_func;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2(<span class="number">111</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//绑定一个仿函数</span></span><br><span class="line">    Bar obj;</span><br><span class="line">    f2 = obj;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2(<span class="number">222</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     运行结果：</span></span><br><span class="line"><span class="comment">        func</span></span><br><span class="line"><span class="comment">        foo_func(111) -&gt;: 111</span></span><br><span class="line"><span class="comment">        operator()(222) -&gt;: 222</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>std::function对象最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等，但是可以与NULL或者nullptr进行比较。</li>
</ul>
<h4 id="stdbind"><a class="markdownIt-Anchor" href="#stdbind"></a> std::bind</h4>
<ul>
<li>
<p>std::bind是这样一种机制，它可以预先把指定可调用实体的某些参数绑定到已有的变量，产生一个新的可调用实体，这种机制在回调函数的使用过程中也颇为有用。</p>
</li>
<li>
<p>C++98中，有两个函数bind1st和bind2nd，它们分别可以用来绑定functor的第一个和第二个参数，它们都是只可以绑定一个参数，各种限制，使得bind1st和bind2nd的可用性大大降低。</p>
</li>
<li>
<p>在C++11中，提供了std::bind，它绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定，这个bind才是真正意义上的绑定。</p>
</li>
<li>
<p>std::bind的基本语法：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   //std::bind</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bind(func, <span class="number">1</span>, <span class="number">2</span>)();                     <span class="comment">//输出：1 2</span></span><br><span class="line">    bind(func, <span class="built_in">std</span>::placeholders::_1, <span class="number">2</span>)(<span class="number">1</span>);<span class="comment">//输出：1 2</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">// adds visibility of _1, _2, _3,...</span></span><br><span class="line">    bind(func, <span class="number">2</span>, _1)(<span class="number">1</span>);       <span class="comment">//输出：2 1</span></span><br><span class="line">    bind(func, <span class="number">2</span>, _2)(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//输出：2 2</span></span><br><span class="line">    bind(func, _1, _2)(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//输出：1 2</span></span><br><span class="line">    bind(func,_2, _1)(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//输出：2 1</span></span><br><span class="line">    <span class="comment">//err, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">//bind(func, 2, _2)(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>std::placeholders::_1是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代。</li>
</ul>
<h4 id="stdbind和stdfunction配合使用"><a class="markdownIt-Anchor" href="#stdbind和stdfunction配合使用"></a> std::bind和std::function配合使用</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   //std::cout</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">// adds visibility of _1, _2, _3,...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test obj; <span class="comment">//创建对象</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = bind(&amp;Test::func, &amp;obj, _1, _2);</span><br><span class="line">    f1(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//输出：1 2</span></span><br><span class="line">    function&lt; <span class="keyword">int</span> &amp;()&gt; f2 = bind(&amp;Test::i, &amp;obj);</span><br><span class="line">    f2() = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj.i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//结果为 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过std::bind和std::function配合使用，所有的可调用对象均有了统一的操作方法。</li>
</ul>
<h3 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h3>
<h4 id="lambda基础使用"><a class="markdownIt-Anchor" href="#lambda基础使用"></a> lambda基础使用</h4>
<ul>
<li>
<p>lambda 表达式(lambda expression)是一个匿名函数，lambda表达式基于数学中的 λ 演算得名。</p>
</li>
<li>
<p>C++11中的lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。</p>
</li>
</ul>
<p><strong>lambda表达式的基本构成</strong></p>
<ul>
<li>函数对象参数</li>
<li>[]，标识一个lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义lambda为止时lambda所在作用范围内可见的局部变量（包括lambda所在类的this）。函数对象参数有以下形式：
<ul>
<li>空。没有使用任何函数对象参数。</li>
<li>=。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li>
<li>&amp;。函数体内可以使用lambda所在作用范围内所有可见的局部变量（包括lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li>
<li>this。函数体内可以使用lambda所在类中的成员变量。</li>
<li>a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li>
<li>&amp;a。将a按引用进行传递。</li>
<li>a, &amp;b。将a按值进行传递，b按引用进行传递。</li>
<li>=，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</li>
<li>&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。</li>
</ul>
</li>
<li>操作符重载函数参数
<ul>
<li>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</li>
</ul>
</li>
<li>可修改标示符
<ul>
<li>mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</li>
</ul>
</li>
<li>错误抛出标示符
<ul>
<li>exception声明，这部分也可以省略。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)</li>
</ul>
</li>
<li>函数返回值</li>
<li>-&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</li>
<li>是函数体
<ul>
<li>{}，标识函数的实现，这部分不能省略，但函数体可以为空。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = []&#123; <span class="keyword">return</span> i; &#125;;          <span class="comment">//err, 没有捕获外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=]&#123; <span class="keyword">return</span> i+x+y; &#125;;     <span class="comment">//ok, 值传递方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [=]&#123; <span class="keyword">return</span> i+x+y; &#125;;     <span class="comment">//ok, 引用传递方式捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i; &#125;;      <span class="comment">//ok, 捕获this指针</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i+x+y; &#125;;  <span class="comment">//err, 没有捕获x, y</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]&#123; <span class="keyword">return</span> i+x+y; &#125;;<span class="comment">//ok, 捕获this指针, x, y</span></span><br><span class="line">        <span class="keyword">auto</span> x9 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i++; &#125;;        <span class="comment">//ok, 捕获this指针, 并修改成员的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = []&#123; <span class="keyword">return</span> a; &#125;;      <span class="comment">//err, 没有捕获外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = [=]&#123; <span class="keyword">return</span> a; &#125;;     <span class="comment">//ok, 值传递方式捕获所有外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a++; &#125;;   <span class="comment">//err, a是以赋值方式捕获的，无法修改</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;   <span class="comment">//ok, 加上mutable修饰符后，可以修改按值传递进来的拷贝</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;               <span class="comment">//ok, 引用传递方式捕获所有外部变量, 并对a执行自加运算</span></span><br><span class="line">    <span class="keyword">auto</span> f6 = [a]&#123; <span class="keyword">return</span> a+b; &#125;;               <span class="comment">//err, 没有捕获变量b</span></span><br><span class="line">    <span class="keyword">auto</span> f9 = [a,&amp;b]&#123; <span class="keyword">return</span> a+(b++); &#125;;        <span class="comment">//ok, 捕获a, &amp;b</span></span><br><span class="line">    <span class="keyword">auto</span> f8 = [=,&amp;b]&#123; <span class="keyword">return</span> a+(b++); &#125;;        <span class="comment">//ok, 捕获所有外部变量，&amp;b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>值传递和引用传递区别：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">auto</span> by_val_lambda = [=] &#123; <span class="keyword">return</span> j + <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> by_ref_lambda = [&amp;] &#123; <span class="keyword">return</span> j + <span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;by_val_lambda: &quot;</span> &lt;&lt; by_val_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;by_ref_lambda: &quot;</span> &lt;&lt; by_ref_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    j++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;by_val_lambda: &quot;</span> &lt;&lt; by_val_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;by_ref_lambda: &quot;</span> &lt;&lt; by_ref_lambda() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    运行结果：</span></span><br><span class="line"><span class="comment">        by_val_lambda: 13</span></span><br><span class="line"><span class="comment">        by_ref_lambda: 13</span></span><br><span class="line"><span class="comment">        by_val_lambda: 13</span></span><br><span class="line"><span class="comment">        by_ref_lambda: 14</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第3次调用结果还是13，原因是由于by_val_lambda中，j被视为了一个常量，一旦初始化后不会再改变。</li>
</ul>
<h4 id="lambda与仿函数"><a class="markdownIt-Anchor" href="#lambda与仿函数"></a> lambda与仿函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunctor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyFunctor(<span class="keyword">int</span> tmp) : round(tmp) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; <span class="keyword">return</span> tmp + round; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> round;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//仿函数</span></span><br><span class="line">    <span class="keyword">int</span> round = <span class="number">2</span>;</span><br><span class="line">    <span class="function">MyFunctor <span class="title">f1</span><span class="params">(round)</span></span>;<span class="comment">//调用构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result1 = &quot;</span> &lt;&lt; f1(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//operator()(int tmp)</span></span><br><span class="line">    <span class="comment">//lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = [=](<span class="keyword">int</span> tmp) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> tmp + round; &#125; ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result2 = &quot;</span> &lt;&lt; f2(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>通过上面的例子，我们看到，仿函数以round初始化类，而lambda函数也捕获了round变量，其它的，如果在参数传递上，两者保持一致。</p>
</li>
<li>
<p>除去在语法层面上的不同，lambda和仿函数有着相同的内涵——都可以捕获一些变量作为初始化状态，并接受参数进行运行。</p>
</li>
<li>
<p>而事实上，仿函数是编译器实现lambda的一种方式，通过编译器都是把lambda表达式转化为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式。</p>
</li>
</ul>
<h4 id="lambda类型"><a class="markdownIt-Anchor" href="#lambda类型"></a> lambda类型</h4>
<ul>
<li>
<p>lambda表达式的类型在C++11中被称为“闭包类型”，每一个lambda表达式则会产生一个临时对象(右值)。因此，严格地将，lambda函数并非函数指针。</p>
</li>
<li>
<p>不过C++11标准却允许lambda表达式向函数指针的转换，但提前是lambda函数没有捕获任何变量，且函数指针所示的函数原型，必须跟lambda函数函数有着相同的调用方式。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用std::function和std::bind来存储和操作lambda表达式</span></span><br><span class="line">    function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; f1 = [](<span class="keyword">int</span> a) &#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">    function&lt;<span class="keyword">int</span>()&gt; f2 = bind([](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f1 = &quot;</span> &lt;&lt; f1(<span class="number">123</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> f3 = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y)-&gt;<span class="keyword">int</span>&#123; <span class="keyword">return</span> x + y; &#125;; <span class="comment">//lambda表达式，没有捕获任何外部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF1)</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;   <span class="comment">//函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF2)</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    PF1 p1;     <span class="comment">//函数指针变量</span></span><br><span class="line">    p1 = f3;    <span class="comment">//ok, lambda表达式向函数指针的转换</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 = &quot;</span> &lt;&lt; p1(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PF2 p2;</span><br><span class="line">    p2 = f3;     <span class="comment">//err, 编译失败，参数必须一致</span></span><br><span class="line">    <span class="keyword">decltype</span>(f3) p3 = f3;   <span class="comment">// 需通过decltype获得lambda的类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(f3) p4 = p1;   <span class="comment">// err 编译失败，函数指针无法转换为lambda</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lambda优势"><a class="markdownIt-Anchor" href="#lambda优势"></a> lambda优势</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //std::for_each</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largeNums;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LNums</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LNums(<span class="keyword">int</span> u): ubound(u)&#123;&#125; <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//仿函数</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; ubound)</span><br><span class="line">        &#123;</span><br><span class="line">            largeNums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ubound;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nums.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ubound = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//1、传统的for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = nums.begin(); itr != nums.end(); ++itr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*itr &gt; ubound)</span><br><span class="line">        &#123;</span><br><span class="line">            largeNums.push_back(*itr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、使用仿函数</span></span><br><span class="line">    for_each(nums.begin(), nums.end(), LNums(ubound));</span><br><span class="line">    <span class="comment">//3、使用lambda函数和算法for_each</span></span><br><span class="line">    for_each(nums.begin(), nums.end(), [=](<span class="keyword">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; ubound)</span><br><span class="line">            &#123;</span><br><span class="line">                largeNums.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//4、遍历元素</span></span><br><span class="line">    for_each(largeNums.begin(), largeNums.end(), [=](<span class="keyword">int</span> i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lambda表达式的价值在于，就地封装短小的功能闭包，可以及其方便地表达出我们希望执行的具体操作，并让上下文结合更加紧密。</li>
</ul>
<h1 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h1>
<ul>
<li>
<p>在C<ins>11之前，C/C</ins>一直是一种顺序的编程语言。顺序是指所有指令都是串行执行的，即在相同的时刻，有且仅有单个CPU的程序计数器执行代码的代码段，并运行代码段中的指令。而C/C++代码也总是对应地拥有一份操作系统赋予进程的包括堆、栈、可执行的（代码）及不可执行的（数据）在内的各种内存区域。</p>
</li>
<li>
<p>而在C<ins>11中，一个相当大的变化就是引入了多线程的支持。这使得C/C</ins>语言在进行线程编程时，不比依赖第三方库。</p>
</li>
</ul>
<h2 id="线程的使用"><a class="markdownIt-Anchor" href="#线程的使用"></a> 线程的使用</h2>
<h3 id="线程的创建"><a class="markdownIt-Anchor" href="#线程的创建"></a> 线程的创建</h3>
<ul>
<li>用std::thread创建线程非常简单，只需要提供线程函数或函数对象即可，并且可以同时指定线程函数的参数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;   <span class="comment">//子线程1</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2)</span></span>;   <span class="comment">//子线程2</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>线程还可以接收任意个数的参数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> ch, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ch = &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;mike&quot;</span>)</span></span>;   <span class="comment">//子线程, 需要头文件#include &lt;thread&gt;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//特地写一个死循环，让程序不结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回收线程资源"><a class="markdownIt-Anchor" href="#回收线程资源"></a> 回收线程资源</h3>
<ul>
<li>std::thread::join等待线程结束（此函数会阻塞），并回收线程资源，如果线程函数有返回值，返回值将被忽略。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::seconds</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pause_thread</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//指定当前线程休眠一定的时间</span></span><br><span class="line">    this_thread::sleep_for(chrono::seconds(n));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pause of &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; seconds ended\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Spawning 3 threads...\n&quot;</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(pause_thread, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(pause_thread, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(pause_thread, <span class="number">3</span>)</span></span>;   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done spawning threads. Now waiting for them to join:\n&quot;</span>;</span><br><span class="line">    t1.join();<span class="comment">//等待线程结束（此函数会阻塞）</span></span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;All threads joined!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不希望线程被阻塞执行，可以调用线程的std::thread::detach，将线程和线程对象分离，让线程作为后台线程去执行。但需要注意的是，detach之后就无法在和线程发生联系了，比如detach之后就不能再通过join来等待执行完，线程何时执行完我们也无法控制。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pause_thread</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::sleep_for (chrono::seconds(n));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pause of &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; seconds ended\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Spawning and detaching 3 threads...\n&quot;</span>;</span><br><span class="line">    thread(pause_thread,<span class="number">1</span>).detach();</span><br><span class="line">    thread(pause_thread,<span class="number">2</span>).detach();</span><br><span class="line">    thread(pause_thread,<span class="number">3</span>).detach();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done spawning threads.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(the main thread will now pause for 5 seconds)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give the detached threads time to finish (but not guaranteed!):</span></span><br><span class="line">    pause_thread(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取线程id和cpu核心数"><a class="markdownIt-Anchor" href="#获取线程id和cpu核心数"></a> 获取线程ID和CPU核心数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::sleep_for (chrono::seconds(<span class="number">1</span>));<span class="comment">//休眠1秒</span></span><br><span class="line">    <span class="comment">//获取当前线程id</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func id = &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t.get_id() = &quot;</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//获取线程t的id</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main id = &quot;</span>&lt;&lt;this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//主线程id</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cup num = &quot;</span> &lt;&lt; thread::hardware_concurrency() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//获取cpu核心数，失败返回0</span></span><br><span class="line"></span><br><span class="line">    t.join(); <span class="comment">//线程阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    运行结果：</span></span><br><span class="line"><span class="comment">        t.get_id() = 2</span></span><br><span class="line"><span class="comment">        main id = 1</span></span><br><span class="line"><span class="comment">        cup num = 4</span></span><br><span class="line"><span class="comment">        func id = 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互斥量"><a class="markdownIt-Anchor" href="#互斥量"></a> 互斥量</h2>
<h3 id="为什么需要互斥量"><a class="markdownIt-Anchor" href="#为什么需要互斥量"></a> 为什么需要互斥量</h3>
<ul>
<li>在多任务操作系统中，同时运行的多个任务可能都需要使用同一种资源。这个过程有点类似于，公司部门里，我在使用着打印机打印东西的同时（还没有打印完），别人刚好也在此刻使用打印机打印东西，如果不做任何处理的话，打印出来的东西肯定是错乱的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *str;</span><br><span class="line">        str++;</span><br><span class="line">        this_thread::sleep_for (chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    printer(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    printer(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独占互斥量stdmutex"><a class="markdownIt-Anchor" href="#独占互斥量stdmutex"></a> 独占互斥量std::mutex</h3>
<ul>
<li>互斥量的基本接口很相似，一般用法是通过lock()方法来阻塞线程，直到获得互斥量的所有权为止。在线程获得互斥量并完成任务之后，就必须使用unlock()来解除对互斥量的占用，lock()和unlock()必须成对出现。try_lock()尝试锁定互斥量，如果成功则返回true, 如果失败则返回false，它是非阻塞的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mutex g_lock; <span class="comment">//全局互斥锁对象，#include &lt;mutex&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *str;</span><br><span class="line">        str++;</span><br><span class="line">        this_thread::sleep_for (chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    g_lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    printer(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    printer(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用std::lock_guard可以简化lock/unlock的写法，同时也更安全，因为lock_guard在构造时会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而避免忘了unlock操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mutex g_lock; <span class="comment">//全局互斥锁对象，#include &lt;mutex&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印机</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(g_lock)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *str;</span><br><span class="line">        str++;</span><br><span class="line">        this_thread::sleep_for (chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h3>
<ul>
<li>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。</li>
</ul>
<p>//全局的结果数据<br />
long total = 0;</p>
<p>//点击函数<br />
void func()<br />
{<br />
for(int i = 0;  i &lt; 1000000; ++i)<br />
{<br />
// 对全局数据进行无锁访问<br />
total += 1;<br />
}<br />
}</p>
<p>int main()<br />
{<br />
clock_t start = clock();    // 计时开始</p>
<pre><code>//线程
thread t1(func);
thread t2(func);

t1.join();
t2.join();

clock_t end = clock();    // 计时结束

cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;
cout &lt;&lt; &quot;time = &quot; &lt;&lt; end-start &lt;&lt; &quot; ms\n&quot;;

return 0;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 运行结果如下：</span><br><span class="line"></span><br><span class="line">- 由于线程间对数据的竞争而导致每次运行的结果都不一样。因此，为了防止数据竞争问题，我们需要对total进行原子操作。</span><br><span class="line"></span><br><span class="line">- 通过互斥锁进行原子操作：</span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">&#x2F;&#x2F;全局的结果数据</span><br><span class="line">long total &#x3D; 0;</span><br><span class="line">mutex g_lock;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;点击函数</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i &#x3D; 0;  i &lt; 1000000; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        g_lock.lock(); &#x2F;&#x2F;加锁</span><br><span class="line">        total +&#x3D; 1;</span><br><span class="line">        g_lock.unlock(); &#x2F;&#x2F;解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    clock_t start &#x3D; clock();    &#x2F;&#x2F; 计时开始</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;线程</span><br><span class="line">    thread t1(func);</span><br><span class="line">    thread t2(func);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    clock_t end &#x3D; clock();    &#x2F;&#x2F; 计时结束</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;total &#x3D; &quot; &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;time &#x3D; &quot; &lt;&lt; end-start &lt;&lt; &quot; ms\n&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>每次运行的结果都一样，只是耗时长点。</p>
</li>
<li>
<p>在新标准C++11，引入了原子操作的概念。如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程 对这个资源进行访问，编译器将保证多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原子数据类型</span></span><br><span class="line">atomic&lt;<span class="keyword">long</span>&gt; total = &#123;<span class="number">0</span>&#125;; <span class="comment">//需要头文件 #include &lt;atomic&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//点击函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        total += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();    <span class="comment">// 计时开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> end = clock();    <span class="comment">// 计时结束</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;time = &quot;</span> &lt;&lt; end-start &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>运行结果如下，耗时也很短：</p>
</li>
<li>
<p>原子操作的实现跟普通数据类型类似，但是它能够在保证结果正确的前提下，提供比mutex等锁机制更好的性能。</p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/11/29/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"><i class="fa fa-chevron-left">  </i><span>三维重建</span></a></div><div class="next-post pull-right"><a href="/2020/11/08/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"><span>状态估计中的优化问题</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'AdfkiqY89QUSUWbDY9xJuCh0-gzGzoHsz',
  appKey:'2cEvHcqEWsyoKwy4AUL3kPGh',
  placeholder:'劈个叉吧',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'100',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By hero576</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>