<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="C++"><meta name="keywords" content="C/C++"><meta name="author" content="hero576"><meta name="copyright" content="hero576"><title>C++ | void land space</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5ff8fca367285c16c6dd5c16ca2ccc1b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.0.2'
} </script><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="void land space" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text"> 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">1.2.</span> <span class="toc-text"> 历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-number">1.3.</span> <span class="toc-text"> 内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E5%AF%B9c%E7%9A%84%E6%89%A9%E5%B1%95externsion"><span class="toc-number">2.</span> <span class="toc-text"> C++对C的扩展(Externsion)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.1.</span> <span class="toc-text"> 类型增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BAcin-cout"><span class="toc-number">2.2.</span> <span class="toc-text"> 输入与输出(cin &#x2F;cout)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cin-cout"><span class="toc-number">2.2.1.</span> <span class="toc-text"> cin &amp;&amp; cout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%AE%BD%E5%8F%8A%E4%BD%8D%E6%95%B0"><span class="toc-number">2.2.2.1.</span> <span class="toc-text"> 设置域宽及位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%BF%9B%E5%88%B6%E8%BE%93%E5%87%BA"><span class="toc-number">2.2.2.2.</span> <span class="toc-text"> 按进制输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E7%AC%A6"><span class="toc-number">2.2.2.3.</span> <span class="toc-text"> 设置填充符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BDfunction-overload"><span class="toc-number">2.3.</span> <span class="toc-text"> 函数重载(function overload)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 重载规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 匹配原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.3.</span> <span class="toc-text"> 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BDoperator-overload"><span class="toc-number">2.3.4.</span> <span class="toc-text"> 操作符重载(operator overload)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-c"><span class="toc-number">2.4.</span> <span class="toc-text"> extern “C”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0default-parameters"><span class="toc-number">2.5.</span> <span class="toc-text"> 默认参数(default parameters)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8reference"><span class="toc-number">2.6.</span> <span class="toc-text"> 引用(Reference)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.6.3.</span> <span class="toc-text"> 注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newdelete-operator"><span class="toc-number">2.7.</span> <span class="toc-text"> new&#x2F;delete Operator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newnew%E7%94%A8%E6%B3%95"><span class="toc-number">2.7.1.</span> <span class="toc-text"> new&#x2F;new[]用法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete-delete%E7%94%A8%E6%B3%95"><span class="toc-number">2.7.2.</span> <span class="toc-text"> delete &#x2F;delete[]用法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.7.3.</span> <span class="toc-text"> 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline-function"><span class="toc-number">2.8.</span> <span class="toc-text"> 内联函数(inline function)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%BC%BA%E8%BD%ACtype-cast"><span class="toc-number">2.9.</span> <span class="toc-text"> 类型强转(type cast)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.9.1.</span> <span class="toc-text"> 静态类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A7%A3%E9%87%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.9.2.</span> <span class="toc-text"> 重解释类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%B1%E5%B8%B8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.9.3.</span> <span class="toc-text"> (脱)常类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.9.4.</span> <span class="toc-text"> 动态类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace-scope"><span class="toc-number">2.10.</span> <span class="toc-text"> 命名空间(namespace scope)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4namespace"><span class="toc-number">2.10.1.</span> <span class="toc-text"> 默认NameSpace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">2.10.2.</span> <span class="toc-text"> 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">2.10.2.1.</span> <span class="toc-text"> 声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.10.2.2.</span> <span class="toc-text"> 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%B5%8C%E5%A5%97"><span class="toc-number">2.10.2.3.</span> <span class="toc-text"> 支持嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91"><span class="toc-number">2.10.2.4.</span> <span class="toc-text"> 协作开发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F-string-%E7%B1%BB"><span class="toc-number">2.11.</span> <span class="toc-text"> 系统 string 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.11.1.</span> <span class="toc-text"> 定义及初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.11.2.</span> <span class="toc-text"> 类型大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97"><span class="toc-number">2.11.3.</span> <span class="toc-text"> 常用运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.4.</span> <span class="toc-text"> 常见的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">2.11.5.</span> <span class="toc-text"> string 类型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E7%B1%BB"><span class="toc-number">2.12.</span> <span class="toc-text"> vector类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text"> C++面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85encapsulation"><span class="toc-number">3.1.</span> <span class="toc-text"> 封装(Encapsulation)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B0%81%E8%A3%85"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 定义封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8class%E5%8E%BB%E5%B0%81%E8%A3%85%E5%B8%A6%E8%A1%8C%E4%B8%BA%E7%9A%84%E7%B1%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 用class去封装带行为的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1class-object"><span class="toc-number">3.2.</span> <span class="toc-text"> 类与对象(Class &amp;&amp;object)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8constructor"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 构造器（Constructor）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.1.1.</span> <span class="toc-text"> 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8"><span class="toc-number">3.2.1.2.</span> <span class="toc-text"> 参数初始化表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E9%80%A0%E5%99%A8destructor"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 析造器(Destructor)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%84%8F%E4%B9%89"><span class="toc-number">3.2.2.1.</span> <span class="toc-text"> 析构器的定义及意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0copy-contructor"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 拷贝构造(Copy contructor)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">3.2.3.1.</span> <span class="toc-text"> 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%8F%91%E7%94%9F%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">3.2.3.2.</span> <span class="toc-text"> 拷贝构造发生的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.2.3.3.</span> <span class="toc-text"> 深拷贝与浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">3.2.4.</span> <span class="toc-text"> this 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.4.1.</span> <span class="toc-text"> 作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BDoperator"><span class="toc-number">3.2.5.</span> <span class="toc-text"> 赋值运算符重载(Operator&#x3D;)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">3.2.5.1.</span> <span class="toc-text"> 定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.6.</span> <span class="toc-text"> 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%A0%88%E4%B8%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.6.1.</span> <span class="toc-text"> 返回栈上引用与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E8%BF%94%E5%9B%9E%E6%A0%88%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.6.1.1.</span> <span class="toc-text"> c语言返回栈变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E8%BF%94%E5%9B%9E%E6%A0%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.6.1.2.</span> <span class="toc-text"> c++返回栈对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c%E8%BF%94%E5%9B%9E%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.6.1.3.</span> <span class="toc-text"> c++返回栈对象引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.6.2.</span> <span class="toc-text"> 栈和堆上的对象及对象数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.6.3.</span> <span class="toc-text"> 成员函数的存储方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.2.7.</span> <span class="toc-text"> 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.2.7.1.</span> <span class="toc-text"> const修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E5%B8%B8%E9%87%8F%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">3.2.7.1.1.</span> <span class="toc-text"> const常量类的成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E5%B8%B8%E9%87%8F%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.7.1.2.</span> <span class="toc-text"> const常量类的成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.7.1.3.</span> <span class="toc-text"> const常量类对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.2.7.2.</span> <span class="toc-text"> static修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">3.2.7.2.1.</span> <span class="toc-text"> static的类成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.7.2.2.</span> <span class="toc-text"> static的类成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-const-%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">3.2.7.3.</span> <span class="toc-text"> static const 类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.2.7.4.</span> <span class="toc-text"> 指向类成员的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.2.7.4.1.</span> <span class="toc-text"> 指向类数据成员的指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.2.7.4.2.</span> <span class="toc-text"> 指向类成员函数的指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.2.7.4.3.</span> <span class="toc-text"> 指向类静态成员的指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.2.7.4.4.</span> <span class="toc-text"> 小结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83friend"><span class="toc-number">3.3.</span> <span class="toc-text"> 友元(Friend)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 友元使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.3.1.1.</span> <span class="toc-text"> 声明位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-number">3.3.1.2.</span> <span class="toc-text"> 友元的利弊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">3.3.1.3.</span> <span class="toc-text"> 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">3.3.3.</span> <span class="toc-text"> 友元类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BDoperator-overload"><span class="toc-number">3.4.</span> <span class="toc-text"> 运算符重载(Operator OverLoad)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 语法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E9%87%8D%E8%BD%BD%E5%92%8C%E6%88%90%E5%91%98%E9%87%8D%E8%BD%BD"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 友元重载和成员重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99-2"><span class="toc-number">3.4.3.</span> <span class="toc-text"> 重载规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">3.4.4.</span> <span class="toc-text"> 双目运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">3.4.5.</span> <span class="toc-text"> 单目运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.6.</span> <span class="toc-text"> 重载格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%87%8D%E8%BD%BD%E5%AE%8C%E6%88%90%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.7.</span> <span class="toc-text"> 使用重载完成类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.7.1.</span> <span class="toc-text"> 标准类型间转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.7.2.</span> <span class="toc-text"> 用类型转换构造函数进行类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.7.3.</span> <span class="toc-text"> 用类型转换操作符函数进行转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">3.4.8.</span> <span class="toc-text"> 重载的高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.8.1.</span> <span class="toc-text"> 函数操作符()—仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E7%AC%A6-new-delete"><span class="toc-number">3.4.8.2.</span> <span class="toc-text"> 堆内存操作符 （new delete）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-"><span class="toc-number">3.4.8.3.</span> <span class="toc-text"> 解引用与智能指针（-&gt; &#x2F;*）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9Finheritderive"><span class="toc-number">3.5.</span> <span class="toc-text"> 继承与派生(Inherit&amp;&amp;Derive)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">3.5.1.</span> <span class="toc-text"> 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.5.2.</span> <span class="toc-text"> 派生类的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">3.5.3.</span> <span class="toc-text"> 派生类的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">3.5.3.1.</span> <span class="toc-text"> 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-number">3.5.3.2.</span> <span class="toc-text"> 派生类的拷贝构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">3.5.3.3.</span> <span class="toc-text"> 派生类的赋值运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.3.4.</span> <span class="toc-text"> 派生类友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">3.5.3.5.</span> <span class="toc-text"> 派生类析构函数的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%A0%87%E8%AF%86%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-number">3.5.3.6.</span> <span class="toc-text"> 派生类成员的标识和访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E8%BE%A8%E7%AC%A6"><span class="toc-number">3.5.3.6.1.</span> <span class="toc-text"> 作用域分辨符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.3.6.2.</span> <span class="toc-text"> 继承方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.4.</span> <span class="toc-text"> 多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">3.5.4.1.</span> <span class="toc-text"> 继承语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E9%97%AE%E9%A2%98%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.4.2.</span> <span class="toc-text"> 三角问题(二义性问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.4.3.</span> <span class="toc-text"> 虚继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81polymorphism"><span class="toc-number">3.6.</span> <span class="toc-text"> 多态（PolyMorphism）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%89%8D%E6%8F%90"><span class="toc-number">3.6.1.</span> <span class="toc-text"> 赋值兼容(多态实现的前提)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">3.6.2.</span> <span class="toc-text"> 多态的形成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E5%A4%9A%E6%80%81"><span class="toc-number">3.6.2.1.</span> <span class="toc-text"> 静多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E5%A4%9A%E6%80%81"><span class="toc-number">3.6.2.2.</span> <span class="toc-text"> 动多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.3.</span> <span class="toc-text"> 虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">3.6.3.1.</span> <span class="toc-text"> 虚函数的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E5%86%99override"><span class="toc-number">3.6.3.2.</span> <span class="toc-text"> 覆写override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.3.3.</span> <span class="toc-text"> 纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%90%E6%9E%84"><span class="toc-number">3.6.3.4.</span> <span class="toc-text"> 含有虚函数的析构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AFrtti"><span class="toc-number">3.6.4.</span> <span class="toc-text"> 运行时类型信息(RTTI)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeid"><span class="toc-number">3.6.4.1.</span> <span class="toc-text"> typeid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typecast"><span class="toc-number">3.6.4.2.</span> <span class="toc-text"> typecast</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static_cast"><span class="toc-number">3.6.4.2.1.</span> <span class="toc-text"> static_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reinterpreter_cast"><span class="toc-number">3.6.4.2.2.</span> <span class="toc-text"> reinterpreter_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic_cast"><span class="toc-number">3.6.4.2.3.</span> <span class="toc-text"> dynamic_cast</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.5.</span> <span class="toc-text"> 多态实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">3.6.5.1.</span> <span class="toc-text"> 虚函数表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E5%86%99%E7%BB%A7%E6%89%BF"><span class="toc-number">3.6.5.2.</span> <span class="toc-text"> 无虚函数覆写继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E5%86%99%E7%BB%A7%E6%89%BF"><span class="toc-number">3.6.5.3.</span> <span class="toc-text"> 有虚函数覆写继承</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E9%AB%98%E7%BA%A7"><span class="toc-number">4.</span> <span class="toc-text"> C++高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BFtemplates"><span class="toc-number">4.1.</span> <span class="toc-text"> 模板(Templates)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.1.1.1.</span> <span class="toc-text"> 函数重载实现的泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">4.1.1.2.</span> <span class="toc-text"> 函数模板的引入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 类模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E6%B5%81"><span class="toc-number">4.2.</span> <span class="toc-text"> IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-io-%E6%B5%81"><span class="toc-number">4.2.1.</span> <span class="toc-text"> 输入输出 IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA"><span class="toc-number">4.2.1.1.</span> <span class="toc-text"> 标准输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%B5%81%E7%AE%97%E5%AD%90iomanip"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text"> 引用流算子iomanip</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5-cin"><span class="toc-number">4.2.1.2.</span> <span class="toc-text"> 标准输入 cin</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.1.2.1.</span> <span class="toc-text"> 成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-io-%E6%B5%81"><span class="toc-number">4.2.2.</span> <span class="toc-text"> 文件 IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BAbuffer"><span class="toc-number">4.2.2.1.</span> <span class="toc-text"> 缓冲区(Buffer)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.2.2.</span> <span class="toc-text"> 借助文件指针读写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E7%B1%BB%E4%B8%8E%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.2.3.</span> <span class="toc-text"> 文件流类与文件流对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-number">4.2.2.4.</span> <span class="toc-text"> 文件的打开和关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.2.4.1.</span> <span class="toc-text"> 定义流对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.2.4.2.</span> <span class="toc-text"> 打开文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E9%97%AD"><span class="toc-number">4.2.2.4.3.</span> <span class="toc-text"> 文件的关闭</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E4%B8%8E%E5%88%A4%E6%96%AD"><span class="toc-number">4.2.2.5.</span> <span class="toc-text"> 流文件状态与判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.6.</span> <span class="toc-text"> 文件的读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E7%8A%B6%E6%80%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="toc-number">4.2.2.6.1.</span> <span class="toc-text"> 流状态的查询和控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.2.6.2.</span> <span class="toc-text"> 读写文件本文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.2.6.3.</span> <span class="toc-text"> 读写二进制文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.2.6.4.</span> <span class="toc-text"> 随机读写函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8exception"><span class="toc-number">4.3.</span> <span class="toc-text"> 异常(Exception)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%AF%AD%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 异常语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 抛出类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%87%AA%E6%97%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text"> 栈自旋</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl"><span class="toc-number">4.4.</span> <span class="toc-text"> STL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c11"><span class="toc-number">4.5.</span> <span class="toc-text"> C11</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boost"><span class="toc-number">4.6.</span> <span class="toc-text"> Boost</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/haimianbaobao.jpg"></div><div class="author-info__name text-center">hero576</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">57</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">void land space</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">C++</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/programme/"> programme</a></div><div class="article-container" id="post-content"><blockquote>
<p><code>c++</code>记录</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<ul>
<li>1982 年，美国 AT&amp;T 公司贝尔实验室的 Bjarne Stroustrup 博士在 c 语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与 c 语言的渊源关系，它被命名为 <code>C++</code>。而 Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）博士被尊称为<code>C++</code>语言之父。</li>
</ul>
<h2 id="历史"><a class="markdownIt-Anchor" href="#历史"></a> 历史</h2>
<ul>
<li>在“C with Class”阶段，研制者在 C 语言的基础上加进去的特征主要有：类及派生类、共有和私有成员的区分、类的构造函数和析构函数、友元、内联函数、赋值运算符的重载等。</li>
<li>1985 年公布的 <code>C++</code>语言 1.0 版的内容中又添加了一些重要特征：虚函数的概念、函数和运算符的重载、引用、常量（constant）等。</li>
<li>1989 年推出的 2.0 版形成了更加完善的支持面向对象程序设计的 <code>C++</code>语言，新增加的内容包括：类的保护成员、多重继承、对象的初始化与赋值的递归机制、抽象类、静态成员函数、const 成员函数等。</li>
<li>1993 年的 <code>C++</code>语言 3.0 版本是 <code>C++</code>语言的进一步完善，其中最重要的新特征是模板（template）,此外解决了多重继承产生的二义性问题和相应的构造函数与析构函数的处理等。</li>
<li>1998 年 <code>C++</code>标准（<code>ISO/IEC14882 Standard for the C++ Programming Language</code>）得到了国际标准化组织（ISO）和美国标准化协会（ANSI）的批准，标准 <code>C++</code>语言及其标准库更体现了 <code>C++</code>语言设计的初衷。名字空间的概念、标准模板库（STL）中增加的标准容器类、通用算法类和字符串类型等使得 <code>C++</code>语言更为实用。此后 <code>C++</code>是具有国际标准的编程语言，该标准通常简称 <code>ANSI C++</code>或 <code>ISO C++ 98</code> 标准，以后每 5 年视实际需要更新一次标准。</li>
<li>后来又在 2003 年通过了 <code>C++</code>标准第二版（ISO/IEC 14882:2003）：这个新版本是一次技术性修订，对第一版进行了整理——修订错误、减少多义性等，但没有改变语言特性。这个版本常被称为 <code>C++03</code>。</li>
<li>此后，新的标准草案叫做 <code>C++ 0x</code>。对于 <code>C++ 0x</code> 标准草案的最终国际投票已于 2011 年 8 月 10 日结束，并且所有国家都投出了赞成票，<code>C++0x</code> 已经毫无异议地成为正式国际标准。先前被临时命名为 <code>C++0x</code> 的新标准正式定名为 ISO/IEC 14882:2011，简称 <code>ISO C++11</code> 标准。<code>C++ 11</code> 标准将取代现行的 <code>C++</code>标准 <code>C++98</code> 和 <code>C++03</code>。国际标准化组织于 2011 年 9 月 1 日出版发布《ISO/IEC 14882:2011》，名称是：<code>Information technology -- Programming languages -- C++ Edition: 3</code>。</li>
<li><code>C++</code>标准第四版，2014年8月18日发布。正式名称为ISO/IEC 14882:2014。<code>C++14</code>是<code>C++11</code>的增量更新，主要是支持普通函数的返回类型推演，泛型 lambda，扩展的 lambda 捕获，对 constexpr 函数限制的修订，constexpr变量模板化等。</li>
<li><code>C++17</code></li>
<li><code>C++20</code></li>
</ul>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h2>
<ul>
<li><code>C++</code>语言的名字，如果看作 c 的基本语法，是由操作数 c 和运算符后<code>++</code>构成。<code>C++</code>是本身这门语言先是 c,是完全兼容 c.然后在此基础上<code>++</code>。这个<code>++</code>包含三大部分，<code>c++</code>对 c的基础语法的扩展，面向对像(继承，封装，多态)，STL 等</li>
</ul>
<h1 id="c对c的扩展externsion"><a class="markdownIt-Anchor" href="#c对c的扩展externsion"></a> <code>C++</code>对C的扩展(Externsion)</h1>
<h2 id="类型增强"><a class="markdownIt-Anchor" href="#类型增强"></a> 类型增强</h2>
<ul>
<li>类型检查更严格
<ul>
<li>比如，把一个 const 类型的指针赋给非 const 类型的指针。c 语言中可以通的过，但是在 <code>c++</code>中则编不过去。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pa = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *pb = pa;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>布尔类型（bool）</p>
<ul>
<li>c 语言的逻辑真假用 0 和非 0 来表示。而 <code>c++</code>中有了具体的类型。</li>
</ul>
</li>
<li>
<p>真正的枚举(enum)</p>
<ul>
<li>c 语言中枚举本质就是整型，枚举变量可以用任意整型赋值。而 c++中枚举变量，只能用被枚举出来的元素初始化。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> season &#123;SPR,SUM,AUT,WIN&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>表达式的值可被赋值
<ul>
<li>c 语言中表达式通常不能作为左值的，即不可被赋值，<code>c++</code>中某些表达式是可以赋值的。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b = <span class="number">5</span>;</span><br><span class="line">(a = b) = <span class="number">10</span>;  <span class="comment">//b的值给了a，10的值又继续给了a</span></span><br><span class="line">(a&lt;b? a:b) = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<h2 id="输入与输出cin-cout"><a class="markdownIt-Anchor" href="#输入与输出cin-cout"></a> 输入与输出(cin /cout)</h2>
<h3 id="cin-cout"><a class="markdownIt-Anchor" href="#cin-cout"></a> cin &amp;&amp; cout</h3>
<ul>
<li>cin 和 cout 是 <code>C++</code>的标准输入流和输出流。他们在头文件 iostream 中定义。cin是类对象，&gt;&gt;流输入运算符，重载。</li>
</ul>
<table>
<thead>
<tr>
<th>流名</th>
<th>含义</th>
<th>隐含设备</th>
<th>流名</th>
<th>含义</th>
<th>隐含设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>cin</td>
<td>标准输入</td>
<td>键盘</td>
<td>cerr</td>
<td>标准错误输出</td>
<td>屏幕</td>
</tr>
<tr>
<td>cout</td>
<td>标准输出</td>
<td>屏幕</td>
<td>clog</td>
<td>cerr 的缓冲输出</td>
<td>屏幕</td>
</tr>
</tbody>
</table>
<h3 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h3>
<h4 id="设置域宽及位数"><a class="markdownIt-Anchor" href="#设置域宽及位数"></a> 设置域宽及位数</h4>
<ul>
<li>对于实型，cout 默认输出六位有效数据，setprecision(2) 可以设置有效位数，<code>setprecision(n)&lt;&lt;setiosflags(ios::fixed)</code>合用，可以设置小数点右边的位数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n%d\n%f\n&quot;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">100</span>,<span class="number">120.00</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5c\n%5d\n%6.2f\n&quot;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">100</span>,<span class="number">120.00</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">5</span>)&lt;&lt;<span class="string">&#x27;a&#x27;</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;setw(<span class="number">5</span>)&lt;&lt;<span class="number">100</span>&lt;&lt;<span class="built_in">endl</span></span><br><span class="line">&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;setiosflags(ios::fixed)&lt;&lt;<span class="number">120.00</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="按进制输出"><a class="markdownIt-Anchor" href="#按进制输出"></a> 按进制输出</h4>
<ul>
<li>输出十进制，十六进制，八进制。默认输出十进制的数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dec&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;hex&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;oct&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setbase(<span class="number">16</span>)&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="设置填充符"><a class="markdownIt-Anchor" href="#设置填充符"></a> 设置填充符</h4>
<ul>
<li>还可以设置域宽的同时，设置左右对齐及填充字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;setfill(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;setfill(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;setiosflags(ios::left)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;setfill(<span class="string">&#x27;-&#x27;</span>)&lt;&lt;setiosflags(ios::right)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载function-overload"><a class="markdownIt-Anchor" href="#函数重载function-overload"></a> 函数重载(function overload)</h2>
<h3 id="重载规则"><a class="markdownIt-Anchor" href="#重载规则"></a> 重载规则</h3>
<ul>
<li>重载规则：
<ol>
<li>函数名相同。</li>
<li>参数个数不同，参数的类型不同，参数顺序不同，均可构成重载。</li>
<li>返回值类型不同则不可以构成重载。</li>
</ol>
</li>
<li>有的函数虽然有返回值类型，但不与参数表达式运算，而作一条单独的语句。</li>
</ul>
<h3 id="匹配原则"><a class="markdownIt-Anchor" href="#匹配原则"></a> 匹配原则</h3>
<ul>
<li>
<p>匹配原则：</p>
<ol>
<li>严格匹配，找到则调用。</li>
<li>通过隐式转换寻求一个匹配，找到则调用。</li>
</ol>
</li>
<li>
<p><code>C++</code> 允许，int 到 long 和 double，double 到 int 和 float 隐式类型转换。遇到这种情型，则会引起二义性。</p>
</li>
</ul>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<ul>
<li><code>C++</code>利用 name mangling(倾轧)技术，来改名函数名，区分参数不同的同名函数。</li>
<li>实现原理：用 v-c- i-f- l- d 表示 void char int float long double 及其引用。</li>
</ul>
<h3 id="操作符重载operator-overload"><a class="markdownIt-Anchor" href="#操作符重载operator-overload"></a> 操作符重载(operator overload)</h3>
<ul>
<li><code>c++</code>认为一切操作符都是函数，而函数是可以重载的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">float</span> real;</span><br><span class="line">  <span class="keyword">float</span> image;</span><br><span class="line">&#125;;</span><br><span class="line">COMP <span class="keyword">operator</span>+(COMP one, COMP another)</span><br><span class="line">&#123;</span><br><span class="line">  one.real += another.real;</span><br><span class="line">  one.image += another.image;</span><br><span class="line">  <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例中重载了一个全局的操作符+号用于实现将两个自定义结构体类型相加。本质是<code>operator+</code>函数的调用。</li>
</ul>
<h2 id="extern-c"><a class="markdownIt-Anchor" href="#extern-c"></a> extern “C”</h2>
<ul>
<li>name mangling 发生在两个阶段，.cpp 编译阶段，和.h 的声明阶段。只有两个阶段同时进行，才能匹配调用。</li>
<li>c++ 完全兼容 c 语言，那就面临着，完全兼容 c 的类库。由.c 文件的类库文件中函数名，并没有发生 name mangling 行为，而我们在包含.c 文件所对应的.h 文件时，.h 文件要发生name manling 行为，因而会发生在链接的时候的错误。</li>
<li><code>C++</code>为了避免上述错误的发生，重载了关键字 extern。只需要,要避免 name manling的函数前，加 extern “C” 如有多个，则 extern “C”{}</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  <span class="comment">//判断是否是c++环境</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;c&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...  <span class="comment">// 对c的标准库函数声明，不倾轧</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="默认参数default-parameters"><a class="markdownIt-Anchor" href="#默认参数default-parameters"></a> 默认参数(default parameters)</h2>
<ul>
<li>通常情况下，函数在调用时，形参从实参那里取得值。对于多次调用用一函数同一实参时，<code>C++</code>给出了更简单的处理办法。给形参以默认值，这样就不用从实参那里取值了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">(<span class="keyword">float</span> length, <span class="keyword">float</span> weight = <span class="number">4</span>,<span class="keyword">float</span> high = <span class="number">5</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length*weight*high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>规则
<ol>
<li>默认的顺序，是从右向左，不能跳跃。</li>
<li>函数声明和定义一体时，默认认参数在定义(声明)处。声明在前，定义在后，默认参数在声明处。</li>
<li>一个函数，不能既作重载，又作默认参数的函数。当你少写一个参数时，系统无法确认是重载还是默认参数。</li>
</ol>
</li>
</ul>
<h2 id="引用reference"><a class="markdownIt-Anchor" href="#引用reference"></a> 引用(Reference)</h2>
<ul>
<li>变量名，本身是一段内存的引用,即别名(alias)。此处引入的引用，是为己有变量起一个别名。</li>
<li>引用是一种声明关系，声明时必须初始化，引用不开辟空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;  <span class="comment">//b是a的引用</span></span><br></pre></td></tr></table></figure>
<h3 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h3>
<ol>
<li>引用没有定义，是一种关系型声明。声明它和原有某一变量(实体)的关系。故而类型与原类型保持一致，<strong>且不分配内存</strong>。与被引用的变量有相同的地址。</li>
<li>声明的时候必须初始化，一经声明，不可变更。</li>
<li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。</li>
<li>&amp;符号前有数据类型时，是引用。其它皆为取地址。(变量前面的&amp;是取地址：&amp;a)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line"><span class="keyword">int</span> &amp;r = b; <span class="comment">//错误，不可更改原有的引用关系</span></span><br><span class="line"><span class="keyword">float</span> &amp;rr = b; <span class="comment">//错误，引用类型不匹配</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;&amp;r&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//变量与引用具有相同的地址。</span></span><br><span class="line"><span class="keyword">int</span> &amp;ra = r; <span class="comment">//可对引用更次引用，表示 a 变量有两个别名，分别是 r 和 ra</span></span><br></pre></td></tr></table></figure>
<h3 id="引用的本质"><a class="markdownIt-Anchor" href="#引用的本质"></a> 引用的本质</h3>
<ul>
<li>引用的本质是指针，<code>C++</code>对裸露的内存地址(指针)作了一次包装。又取得的指针的优良特性。所以再对引用取地址，建立引用的指针没有意义。</li>
<li>引用的本质是，是对常指针 type * const p 的再次包装。<code>char &amp;rc == *pc double &amp;rd == *pd</code></li>
</ul>
<h3 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h3>
<ol>
<li>可以定义指针的引用，但不能定义引用的引用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line"><span class="keyword">int</span>*&amp; rp = p; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rr = r; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>可以定义指针的指针(二级指针)，但不能定义引用的指针。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line"><span class="keyword">int</span>** pp = &amp;p; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line"><span class="keyword">int</span>&amp;* pr = &amp;r; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>可以定义指针数组，但不能定义引用数组，可以定义数组引用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="keyword">int</span>* parr[] = &#123;&amp;a, &amp;b, &amp;c&#125;; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span>&amp; rarr[] = &#123;a, b, c&#125;; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;rarr)[<span class="number">3</span>] = arr; <span class="comment">// ok，必须是int[3]类型的引用</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>常引用：const 引用有较多使用。它可以防止对象的值被随意修改。因而具有一些特性。</li>
</ol>
<ul>
<li><strong>const 对象的引用必须是 const 的</strong>，将普通引用绑定到 const 对象是不合法的。 这个原因比较简单。既然对象是 const 的，表示不能被修改，引用当然也不能修改，必须使用 const 引用。实际上，const int a=1; int &amp;b=a;这种写法是不合法的，编译不过。</li>
<li><strong>const 引用可使用相关类型的对象(常量,非同类型的变量或表达式)初始化</strong>。这个是const 引用与普通引用最大的区别。const int &amp;a=2;是合法的。double x=3.14; const int&amp;b=a;也是合法的。</li>
<li>常引用原理：const 引用的目的是，禁止通过修改引用值来改变被引用的对象。const 引用的初始化特性较为微妙，可通过如下代码说明：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> val = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = val; <span class="comment">// int const &amp; int &amp; const ??</span></span><br><span class="line"><span class="keyword">double</span> &amp; ref2 = val;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ref&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ref2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">val = <span class="number">4.14</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ref&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ref2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述输出结果为 3 3.14 和 3 4.14。因为 ref 是 const 的，在初始化的过程中已经给定值，不允许修改。而被引用的对象是 val，是非 const 的，所以 val 的修改并未影响 ref的值，而 ref2 的值发生了相应的改变。那么，为什么非 const 的引用不能使用相关类型初始化呢？实际上，const 引用使用相关类型对象初始化时发生了如下过程：<code>int temp = val;const int &amp;ref = temp;</code>如果 ref 不是 const 的，那么改变 ref 值，修改的是 temp，而不是 val。期望对 ref 的赋值会修改 val 的程序员会发现 val 实际并未修改。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; ref = i+<span class="number">5</span>;</span><br><span class="line"><span class="comment">//此时产生了与表达式等值的无名的临时变量，</span></span><br><span class="line"><span class="comment">//此时的引用是对无名的临时变量的引用。故不能更改。</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ref&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>尽可能使用 const：原因如下：</li>
</ol>
<ul>
<li>使用 const 可以避免无意修改数据的编程错误。</li>
<li>使用 const 可以处理 const 和非 const 实参。否则将只能接受非 const 数据。</li>
<li>使用 const 引用，可使函数能够正确的生成并使用临时变量（如果实参与引用参数不匹配，就会生成临时变量）</li>
</ul>
<h2 id="newdelete-operator"><a class="markdownIt-Anchor" href="#newdelete-operator"></a> new/delete Operator</h2>
<ul>
<li>c 语言中提供了 malloc 和 free 两个系统函数(库:stdlib.h)，完成对堆内存的申请和释放。而 <code>c++</code>则提供了两关键字 new 和 delete ;</li>
</ul>
<h3 id="newnew用法"><a class="markdownIt-Anchor" href="#newnew用法"></a> new/new[]用法:</h3>
<ol>
<li>开辟单变量地址空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//开辟大小为 sizeof(int)空间</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>); <span class="comment">//开辟大小为 sizeof(int)空间，并初始化</span></span><br><span class="line"><span class="comment">//类型转换</span></span><br><span class="line">c:   <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">c++:  <span class="keyword">int</span> *p = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="built_in">malloc</span>(size(<span class="keyword">int</span>)));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>开辟数组空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一维: <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]&#123;<span class="number">0</span>&#125;;开辟一个大小为 <span class="number">100</span> 的整型数组空间</span><br><span class="line">初始化：<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>[<span class="number">100</span>]));</span><br><span class="line">指针数组：<span class="keyword">int</span> **p = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">5</span>]&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">二维: <span class="keyword">int</span> (*a)[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">6</span>]&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">三维: <span class="keyword">int</span> (*a)[<span class="number">5</span>][<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>][<span class="number">6</span>]&#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">四维维及其以上:依此类推.</span><br></pre></td></tr></table></figure>
<h3 id="delete-delete用法"><a class="markdownIt-Anchor" href="#delete-delete用法"></a> delete /delete[]用法:</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. int *a = new int;</span></span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//释放单个 int 的空间</span></span><br><span class="line"><span class="comment">//2.int *a = new int[5];</span></span><br><span class="line"><span class="keyword">delete</span> []a; <span class="comment">//释放 int 数组空间</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c 语言版本</span></span><br><span class="line"><span class="keyword">char</span> *ps = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span>(ps == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//C++ 内存申请失败会抛出异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C++ 内存申请失败不抛出异常版本</span></span><br><span class="line"><span class="keyword">int</span> *q = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)<span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">if</span>(q == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
<ol>
<li>new/delete 是关键字，效率高于 malloc 和 free.</li>
<li>配对使用，避免内存泄漏和多重释放。</li>
<li>避免，交叉使用。比如 malloc 申请的空间去 delete，new 出的空间被 free;</li>
</ol>
<h2 id="内联函数inline-function"><a class="markdownIt-Anchor" href="#内联函数inline-function"></a> 内联函数(inline function)</h2>
<ul>
<li>c 语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去，避免了函数调用的开销。但是由于宏函数的处理发生在预处理阶段，缺失了语法检测和有可能带来的语意差错。例如传入<code>i++</code>。</li>
<li><code>C++</code>提供了 inline 关键字，实现了真正的内嵌。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏优点：内嵌代码，辟免压栈与出栈的开销</span></span><br><span class="line"><span class="comment">//缺点: 代码替换，易使生成代码体积变大，易产生逻辑错误，无类型检查</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR(x) ((x)*(x))</span></span><br><span class="line"><span class="comment">//函数优点：高度抽象，避免重复开发，类型检查</span></span><br><span class="line"><span class="comment">//缺点: 压栈与出栈，带来开销</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;  <span class="comment">//内联函数集合了宏和函数的优点</span></span><br><span class="line">  <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,SQR(i++));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sqr(i++));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内联的优缺点
<ul>
<li>优点：避免调用时的额外开销（入栈与出栈操作）</li>
<li>代价：由于内联函数的函数体在代码段中会出现多个“副本”，因此会增加代码段的空间。</li>
<li>本质：以牺牲代码段空间为代价，提高程序的运行时间的效率。</li>
<li>适用场景：函数体很“小”，且被“频繁”调用</li>
<li>编译器会根据内联函数的代码数量，决定是否内联；但是不声明内联的函数不会自动内联。</li>
</ul>
</li>
</ul>
<h2 id="类型强转type-cast"><a class="markdownIt-Anchor" href="#类型强转type-cast"></a> 类型强转(type cast)</h2>
<ul>
<li>类型转换有 c 风格的，当然还有 <code>c++</code>风格的。c 风格的转换的格式很简单（TYPE EXPRESSION)，但是 c 风格的类型转换有不少的缺点，有的时候用 c 风格的转换是不合适的，因为它可以在任意类型之间转换，比如你可以把一个指向 const 对象的指针转换成指向非const 对象的指针，把一个指向基类对象的指针转换成指向一个派生类对象的指针，这两种转换之间的差别是巨大的，但是传统的 c 语言风格的类型转换没有区分这些。还有一个缺点就是，c 风格的转换不容易查找，他由一个括号加上一个标识符组成，而这样的东西在 <code>c++</code>程序里一大堆。所以 <code>c++</code>为了克服这些缺点，引进了新的类型转换操作符</li>
</ul>
<h3 id="静态类型转换"><a class="markdownIt-Anchor" href="#静态类型转换"></a> 静态类型转换</h3>
<ul>
<li>语法格式：<code>static_cast&lt;目标类型&gt; (标识符)</code></li>
<li>转化规则：在一个方向上可以作隐式转换，在另外一个方向上就可以作静态转换。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">a=b;b=a; <span class="comment">//两个相互可以隐式转换，此时两个方向都可以静态转换</span></span><br><span class="line">b=<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(a); </span><br><span class="line">a=<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(b); <span class="comment">//float = int int = float</span></span><br><span class="line"><span class="keyword">int</span> *p; <span class="keyword">void</span> *q;</span><br><span class="line">q = p; <span class="comment">// void*可以等于int*，但是反过来不可以，需要强制转换</span></span><br><span class="line">p = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(q);</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">100</span>)); <span class="comment">//malloc开辟的void*变量，强转为char*</span></span><br></pre></td></tr></table></figure>
<h3 id="重解释类型转换"><a class="markdownIt-Anchor" href="#重解释类型转换"></a> 重解释类型转换</h3>
<ul>
<li>语法格式：<code>reinterpret_cast&lt;目标类型&gt; (标识符)</code></li>
<li>转化规则：“通常为操作数的位模式提供较低层的重新解释”也就是说将数据以二进制存在形式的重新解释，在双方向上都不可以隐式类型转换的，则需要重解释类型转换。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p; <span class="keyword">int</span> *q;</span><br><span class="line">p = q;q = p;  <span class="comment">//两个类型之间无法相互隐式转化</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0x12345648</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;x);</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *q = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(a) +<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h3 id="脱常类型转换"><a class="markdownIt-Anchor" href="#脱常类型转换"></a> (脱)常类型转换</h3>
<ul>
<li>语法格式：<code>const_cast&lt;目标类型&gt; (标识符)</code>，<font color="blue">目标类类型只能是指针或引用</font></li>
<li>转化规则：用来移除对象的常量性(cast away the constness)使用 const_cast 去除 const 限定的目的不是为了修改它的内容，而通常是为了函数能够接受这个实际参数。</li>
<li>可以改变 const 自定义类的成员变量，但是对于内置数据类型，却表现未定义行为。</li>
</ul>
<blockquote>
<p>CSDN：Depending on the type of the referenced object, a write operation through the resulting pointer, reference, or pointer to data member might produce undefined behavior.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用场景 1：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func0</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; ref)</span></span>&#123;&#125; <span class="comment">//参数为const类型引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp; ref)</span></span>&#123;&#125; <span class="comment">//别人己经写好的程序或类库</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">44</span>;</span><br><span class="line">func0(m);<span class="comment">//可以传入，同时不能更改</span></span><br><span class="line">func(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(m)); <span class="comment">//将m脱const，传入参数是引用的类库</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//脱掉 const 后的引用或指针可以改吗？const变量一定不能改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a =<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(x); <span class="comment">// int &amp;a = x;  脱常转为引用</span></span><br><span class="line">a = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;&amp;x&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//地址相同，值不同</span></span><br><span class="line"><span class="keyword">int</span> *p =<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;x); <span class="comment">// int *p = &amp;x;脱常转为指针</span></span><br><span class="line">*p = <span class="number">400</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;&amp;x&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//地址相同，值不同</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span><span class="keyword">int</span> data;&#125;;</span><br><span class="line"><span class="keyword">const</span> A xx = &#123;<span class="number">1111</span>&#125;;  <span class="comment">//复杂类型的常量</span></span><br><span class="line">A &amp;a1 = <span class="keyword">const_cast</span>&lt; A&amp;&gt;(xx);a1.data = <span class="number">222</span>;  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a1.data&lt;&lt;xx.data&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//地址变化了，值同步更改了</span></span><br><span class="line">A *p1 = <span class="keyword">const_cast</span>&lt;A*&gt;(&amp;xx);p1-&gt;data = <span class="number">333</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p1-&gt;data&lt;&lt;xx.data&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>const补充：宏在预处理阶段替换了所有宏，而const变量是在编译阶段替换了所有变量。const永远不去改变。</li>
</ul>
<h3 id="动态类型转换"><a class="markdownIt-Anchor" href="#动态类型转换"></a> 动态类型转换</h3>
<ul>
<li>语法格式：<code>dynamic_cast&lt;目标类型&gt; (标识符)</code></li>
<li>转化规则：用于多态中的父子类之间的强制转化</li>
</ul>
<h2 id="命名空间namespace-scope"><a class="markdownIt-Anchor" href="#命名空间namespace-scope"></a> 命名空间(namespace scope)</h2>
<ul>
<li>命名空间为了大型项目开发，而引入的一种避免命名冲突的一种机制。比如说，在一个大型项目中，要用到多家软件开发商提供的类库。在事先没有约定的情况下，两套类库可能在存在同名的函数或是全局变量而产生冲突。项目越大，用到的类库越多，开发人员越多，这种冲突就会越明显。</li>
</ul>
<h3 id="默认namespace"><a class="markdownIt-Anchor" href="#默认namespace"></a> 默认NameSpace</h3>
<ul>
<li>全局<code>Global scope</code>是一个程序中最大的 scope。也是引起命名冲突的根源。C 语言没有从语言层面提供这种机制来解决。也算是 C 语言的硬伤了。<code>Global scope</code>是无名的命名空间，命名空间为空。<code>c++</code>的作用域运算符：<code>::</code>。所以全局的命名空间直接用<code>::</code>即可表示。</li>
<li>局部<code>Function scope</code>就是函数作用域，就没有命名空间的概念了。直接使用函数内声明的变量即可。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	::a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3>
<ul>
<li>NameSpace 是对全局(Global scope)区域的再次划分</li>
</ul>
<h4 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NAMESPACE空间名称</span><br><span class="line">&#123;</span><br><span class="line"> 全局变量 <span class="keyword">int</span> a;</span><br><span class="line"> 数据类型 <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span>&#125;;</span><br><span class="line"> 函数 <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"> 其它命名空间 <span class="keyword">namespace</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h4>
<ol>
<li>直接指定 命名空间：<code>Space::a = 5;</code>，直接调用</li>
<li>使用 using+命名空间+空间元素：<code>using Space::a; a = 2000;</code>，取出其中一个</li>
<li>使用 using +namespace+命名空间： <code>using namespace Space;</code>，都取出来</li>
</ol>
<blockquote>
<p>全取出来虽然方便，但是可能会与局部的同名变量发生冲突。</p>
</blockquote>
<h4 id="支持嵌套"><a class="markdownIt-Anchor" href="#支持嵌套"></a> 支持嵌套</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MySpace</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">namespace</span> Other &#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> MySpace::Other;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;m&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="协作开发"><a class="markdownIt-Anchor" href="#协作开发"></a> 协作开发</h4>
<ul>
<li>同名命名空间自动合并，对于一个命名空间中的类，要包含声明和实现。</li>
</ul>
<h2 id="系统-string-类"><a class="markdownIt-Anchor" href="#系统-string-类"></a> 系统 string 类</h2>
<ul>
<li>除了使用字符数组来处理字符串以外，c++引入了字符串类型。可以定义字符串变量。</li>
<li>在<code>&lt;iostream&gt;</code>std命名空间中</li>
</ul>
<h3 id="定义及初始化"><a class="markdownIt-Anchor" href="#定义及初始化"></a> 定义及初始化</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str = <span class="string">&quot;china&quot;</span>;  <span class="comment">//初始化方式1</span></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot; is great &quot;</span>;<span class="comment">//初始化方式2</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(str2)</span></span>;<span class="comment">//初始化方式3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;str3&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="类型大小"><a class="markdownIt-Anchor" href="#类型大小"></a> 类型大小</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(string) = &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="built_in">string</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(str) = &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(str)&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h3 id="常用运算"><a class="markdownIt-Anchor" href="#常用运算"></a> 常用运算</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>赋值</td>
<td><code>string str3 = str2;</code></td>
</tr>
<tr>
<td>加法</td>
<td><code>string combine = str + str2;</code></td>
</tr>
<tr>
<td>大小</td>
<td><code>str3.size()</code></td>
</tr>
<tr>
<td>关系</td>
<td><code>string s1 = &quot;abcdeg&quot;;string s2 = &quot;12345&quot;;</code><br><code>if(s1&gt;s2)</code><br><code>cout&lt;&lt;&quot;s1&gt;s2&quot;&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>减法没有重载</td>
<td><code>string s3 = s1-s2; // error</code></td>
</tr>
</tbody>
</table>
<h3 id="常见的成员函数"><a class="markdownIt-Anchor" href="#常见的成员函数"></a> 常见的成员函数</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标操作</td>
<td><code>char &amp; operator[](int n) ;</code></td>
<td></td>
</tr>
<tr>
<td>求串大小</td>
<td><code>int size();</code></td>
<td></td>
</tr>
<tr>
<td>返回 c 串</td>
<td><code>char *c_str();</code></td>
<td>与字符数组之间操作，需要返回c串</td>
</tr>
<tr>
<td>查找</td>
<td><code>int find(char c, int pos = 0);</code><br><code>int find(char * s, int pos = 0);</code></td>
<td>返回下标值，没有找到返回-1，默认从 0 下标开找</td>
</tr>
<tr>
<td>删除</td>
<td><code>string &amp;erase(int idx=0，int n = npos);</code></td>
<td>作用是删除从 idx 开始，往后数 n 位的字符串。</td>
</tr>
<tr>
<td>交换 swap</td>
<td><code>void swap(stirng &amp;s2);</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="string-类型数组"><a class="markdownIt-Anchor" href="#string-类型数组"></a> string 类型数组</h3>
<ul>
<li>string 数组是高效的，如果用二维数组来存入字符串数组的话，则容易浪费空间，此时列数是由最长的字符串决定。如果用二级指针申请堆空间，依据大小申请相应的空间，虽然解决了内存浪费的问题，但是操作麻烦。用 string 数组存储，字符串数组的话，效率即高又灵活。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> sArray[<span class="number">10</span>] = &#123;</span><br><span class="line"><span class="string">&quot;0&quot;</span>,</span><br><span class="line"><span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="string">&quot;22&quot;</span>,</span><br><span class="line"><span class="string">&quot;333&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sArray[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vector类"><a class="markdownIt-Anchor" href="#vector类"></a> vector类</h2>
<ul>
<li>使用<code>char**</code>、<code>string</code>、vector三种方式，打印文件中的内容</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File *fp = fopen(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> lineCount=<span class="number">0</span>;<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(fgets(buf,<span class="number">1024</span>,fp)!=<span class="literal">NULL</span>)lineCount++;</span><br><span class="line">rewind(fp);</span><br><span class="line"><span class="comment">//----------------char**-------------------</span></span><br><span class="line"><span class="keyword">char</span>**p=(<span class="keyword">char</span>**)<span class="built_in">malloc</span>((lineCount+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line"><span class="keyword">char</span> **pt = p;</span><br><span class="line"><span class="keyword">while</span>(fgets(buf,<span class="number">1024</span>,fp)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> len=<span class="built_in">strlen</span>(buf);</span><br><span class="line">  *pt = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(*pt,buf);pt++;</span><br><span class="line">&#125;</span><br><span class="line">*pt=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(*p)<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,*p++);</span><br><span class="line"><span class="comment">//----------------string-------------------</span></span><br><span class="line"><span class="comment">//string str[lineCount];  不推荐使用可变数组</span></span><br><span class="line"><span class="built_in">string</span> * str = <span class="keyword">new</span> <span class="built_in">string</span>[lineCount+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">string</span> * pstr = str;</span><br><span class="line"><span class="keyword">while</span>(fgets(buf,<span class="number">1024</span>,fp)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  * pstr++ = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lineCount;i++)count&lt;&lt;str[i];</span><br><span class="line"><span class="comment">//----------------vector-------------------</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line"><span class="keyword">while</span>(fgets(buf,<span class="number">1024</span>,fp)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  vs.push_back(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vs.size();i++)count&lt;&lt;vs[i];</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>
<h1 id="c面向对象"><a class="markdownIt-Anchor" href="#c面向对象"></a> <code>C++</code>面向对象</h1>
<h2 id="封装encapsulation"><a class="markdownIt-Anchor" href="#封装encapsulation"></a> 封装(Encapsulation)</h2>
<ul>
<li>概念：当单一变量无法完成描述需求的时候，结构体类型解决了这一问题。可以将多个类型打 包成一体，形成新的类型。但是，新类型并不包含，对数据类的操作。所的有操作都是通过函数的方式，去其进行封装。</li>
</ul>
<h3 id="定义封装"><a class="markdownIt-Anchor" href="#定义封装"></a> 定义封装</h3>
<ul>
<li>封装，可以达到，对外提供接口，屏蔽数据，对内开放数据。</li>
<li>struct 中所有行为和属性都是 public 的(默认)。C++中的 class 可以指定行为和属性的访问方式，默认为 pirvate。</li>
</ul>
<table>
<thead>
<tr>
<th>访问属性</th>
<th>属性</th>
<th>对象内部</th>
<th>对象外部</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>公有</td>
<td>可访问</td>
<td>可访问</td>
</tr>
<tr>
<td>protected</td>
<td>保护</td>
<td>可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td>private</td>
<td>私有</td>
<td>可访问</td>
<td>不可访问</td>
</tr>
</tbody>
</table>
<h3 id="用class去封装带行为的类"><a class="markdownIt-Anchor" href="#用class去封装带行为的类"></a> 用class去封装带行为的类</h3>
<ul>
<li>class 封装的本质，在于将数据和行为，绑定在一起然后通过对象来完成操作。</li>
</ul>
<h2 id="类与对象class-object"><a class="markdownIt-Anchor" href="#类与对象class-object"></a> 类与对象(Class &amp;&amp;object)</h2>
<h3 id="构造器constructor"><a class="markdownIt-Anchor" href="#构造器constructor"></a> 构造器（Constructor）</h3>
<ul>
<li>构造器名与类名相同。</li>
<li>在类对象创建时，自动调用，完成类对象的初始化。尤其是动态堆内存的申请。</li>
<li>规则:
<ol>
<li>在对象创建时自动调用,完成初始化相关工作。</li>
<li>无返回值，与类名同，</li>
<li>可以重载，可默认参数。</li>
<li>默认无参空体，一经实现，默认不复存在。</li>
</ol>
</li>
</ul>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">类名(形式参数)</span><br><span class="line">构造体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数初始化表"><a class="markdownIt-Anchor" href="#参数初始化表"></a> 参数初始化表</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">char</span> * ps)</span><br><span class="line">      :name(ps),len(<span class="built_in">strlen</span>(name.c_str()))&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意点
<ol>
<li>此格式只能用于类的构造函数。</li>
<li>初始化列表中的初始化顺序，与声明顺序有关，与前后赋值顺序无关。</li>
<li>必须用此格式来初始化非静态 const 数据成员(c++98)。</li>
<li>必须用此格式来实始化引用数据。</li>
</ol>
</li>
</ul>
<h3 id="析造器destructor"><a class="markdownIt-Anchor" href="#析造器destructor"></a> 析造器(Destructor)</h3>
<ul>
<li>析构函数的作用，并不是删除对象，而在对象销毁前完成的一些清理工作。
<ol>
<li>栈对象离开其作用域。</li>
<li>堆对象被手动 delete.</li>
</ol>
</li>
</ul>
<h4 id="析构器的定义及意义"><a class="markdownIt-Anchor" href="#析构器的定义及意义"></a> 析构器的定义及意义</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span> </span><br><span class="line">~类名()</span><br><span class="line">析造体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在类对像销毁时，自动调用，完成对象的销毁。尤其是类中己申请的堆内存的释放.</li>
<li>规则:
<ol>
<li>对象销毁时，自动调用。完成销毁的善后工作。</li>
<li>无返值，与类名同，无参。不可以重载与默认参数。</li>
<li>系统提供默认空析构器，一经实现，不复存在。</li>
</ol>
</li>
</ul>
<h3 id="拷贝构造copy-contructor"><a class="markdownIt-Anchor" href="#拷贝构造copy-contructor"></a> 拷贝构造(Copy contructor)</h3>
<ul>
<li>由己存在的对象，创建新对象。也就是说新对象，不由构造器来构造，而是由拷贝构造器来完成。拷贝构造器的格式是固定的。</li>
</ul>
<h4 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">类名(<span class="keyword">const</span> 类名 &amp; another)</span><br><span class="line">拷贝构造体</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">A(<span class="keyword">const</span> A &amp; another)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>规则：
<ol>
<li>系统提供默认的拷贝构造器。一经实现，不复存在。</li>
<li>系统提供的时等位拷贝，也就是所谓的浅浅的拷贝。</li>
<li>要实现深拷贝，必须要自定义。</li>
</ol>
</li>
</ul>
<h4 id="拷贝构造发生的时机"><a class="markdownIt-Anchor" href="#拷贝构造发生的时机"></a> 拷贝构造发生的时机</h4>
<ol>
<li>制作对象的副本。</li>
<li>以对象作为参数和返回值。</li>
</ol>
<h4 id="深拷贝与浅拷贝"><a class="markdownIt-Anchor" href="#深拷贝与浅拷贝"></a> 深拷贝与浅拷贝</h4>
<ul>
<li>系统提供默认的拷贝构造器，一经定义不再提供。但系统提供的默认拷贝构造器是等位拷贝，也就是通常意义上的浅拷贝。如果类中包含的数据元素全部在栈上，浅拷贝也可以满足需求的。但如果堆上的数据，则会发生多次析构行为。</li>
</ul>
<p><img src="/images/pasted-49.png" alt="深拷贝与浅拷贝" /></p>
<h3 id="this-指针"><a class="markdownIt-Anchor" href="#this-指针"></a> this 指针</h3>
<ul>
<li>系统在创建对象时，默认生成的指向当前对象的指针。这样作的目的，就是为了带来方便。</li>
</ul>
<h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4>
<ol>
<li>避免构造器的入参与成员名相同。</li>
<li>基于 this 指针的自身引用还被广泛地应用于那些支持多重串联调用的函数中。比如连续赋值。</li>
</ol>
<h3 id="赋值运算符重载operator"><a class="markdownIt-Anchor" href="#赋值运算符重载operator"></a> 赋值运算符重载(Operator=)</h3>
<ul>
<li>用一个己有对象，给另外一个己有对象赋值。两个对象均己创建结束后，发生的赋值行为。
<ol>
<li>系统提供默认的赋值运算符重载，一经实现，不复存在。</li>
<li>系统提供的也是等位拷贝，也就浅拷贝，会造成内存泄漏，重析构。</li>
<li>要实现深深的赋值，必须自定义。</li>
<li>自定义面临的问题有三个：1、自赋值；2；内存泄漏、3，重析构</li>
<li>返回引用，且不能用 const 修饰。<code>a = b = c =&gt; (a+b) = c</code></li>
</ol>
</li>
</ul>
<h4 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类名</span><br><span class="line">&#123;</span><br><span class="line">类名&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> 类名&amp; 源对象)</span><br><span class="line">拷贝体</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;</span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; another)&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类和对象"><a class="markdownIt-Anchor" href="#类和对象"></a> 类和对象</h3>
<h4 id="返回栈上引用与对象"><a class="markdownIt-Anchor" href="#返回栈上引用与对象"></a> 返回栈上引用与对象</h4>
<h5 id="c语言返回栈变量"><a class="markdownIt-Anchor" href="#c语言返回栈变量"></a> c语言返回栈变量</h5>
<ul>
<li>为了解决函数调用完就释放空间的问题，在函数返回的过程产生了”中间变量”作为纽带。</li>
<li>不管是返回指针还是返回值，return将return之后的值存到<code>eax寄存器</code>中，回到父函数再将返回的值赋给变量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">i = func();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c返回栈对象"><a class="markdownIt-Anchor" href="#c返回栈对象"></a> <code>c++</code>返回栈对象</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; constructor&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;other)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; cp contructor from &quot;</span>&lt;&lt;&amp;other&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;other)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; operator = &quot;</span>&lt;&lt;&amp;other&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; destructor&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>C++</code>的操作方式时，函数有返回值时，在main函数开辟一个临时空间，并将临时空间的地址隐式传递到调用的函数，再把函数内的变量拷贝到指定地址。</li>
</ul>
<h5 id="c返回栈对象引用"><a class="markdownIt-Anchor" href="#c返回栈对象引用"></a> c++返回栈对象引用</h5>
<ul>
<li>返回栈对象的引用，多用于产生串联应用。比如连等式。</li>
<li>栈对象是不可以返回引用的。除非，函数的调用者返回自身对象。</li>
<li>这是由于返回后自身对象并未析构，但是如果是函数内创建的对象，在返回给主函数引用地址前，对象已经析构，可能会造成不可预知的错误。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MyString &amp; MyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> MyString &amp; another)&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="栈和堆上的对象及对象数组"><a class="markdownIt-Anchor" href="#栈和堆上的对象及对象数组"></a> 栈和堆上的对象及对象数组</h4>
<ul>
<li>注意无参构造器的建立，因为如果生成对象数组，没有初始化则必调用无参构造器，或者手动调用带参构造器。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Stu(<span class="built_in">string</span> n):_name(n)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------</span></span><br><span class="line">Stu s; <span class="comment">//error 没有无参构造器</span></span><br><span class="line">Stu s[<span class="number">5</span>]= &#123;Stu(<span class="string">&quot;zhangsan&quot;</span>),Stu(<span class="string">&quot;lisi&quot;</span>)&#125;; <span class="comment">//error 不能指定个数，或部分初始化，则会报错。</span></span><br><span class="line">Stu s[]= &#123;Stu(<span class="string">&quot;zhangsan&quot;</span>),Stu(<span class="string">&quot;lisi&quot;</span>)&#125;;</span><br><span class="line">Stu * ps = <span class="keyword">new</span> Stu[<span class="number">4</span>]&#123;Stu(<span class="string">&quot;zhangsan&quot;</span>)&#125;; <span class="comment">//C11中支持此种初始化方法，但必须对指定的类个数初始化,否则会报错。</span></span><br><span class="line">Stu * ps = <span class="keyword">new</span> Stu[<span class="number">1</span>]&#123;Stu(<span class="string">&quot;zhangsan&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="成员函数的存储方式"><a class="markdownIt-Anchor" href="#成员函数的存储方式"></a> 成员函数的存储方式</h4>
<ul>
<li>用类去定义对象时，系统会为每一个对象分配存储空间。如果一个类包括了数据和函数，要分别为数据分配存储空间，而函数则会创建公用的函数代码。这样做会大大节约存储空间。</li>
</ul>
<p><img src="/images/pasted-50.png" alt="类成员组成" /></p>
<ul>
<li>调用的原理：调用函数时，会通过this指针，找到对应对象的空间，操作不同的变量。</li>
</ul>
<h3 id="修饰符"><a class="markdownIt-Anchor" href="#修饰符"></a> 修饰符</h3>
<h4 id="const修饰符"><a class="markdownIt-Anchor" href="#const修饰符"></a> const修饰符</h4>
<h5 id="const常量类的成员"><a class="markdownIt-Anchor" href="#const常量类的成员"></a> const常量类的成员</h5>
<ul>
<li>const 修饰类的成员变量，表示成员常量，不能被修改，同时它只能在初始化参数列表中赋值(c11 中支持类中初始化)。</li>
<li>可被 const 和非 const 成员函数调用，而不可以修改。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A():a(<span class="number">199</span>)&#123;&#125;  <span class="comment">// 初始化参数列表赋值const变量a</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;  <span class="comment">// c11支持在类中初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="const常量类的成员函数"><a class="markdownIt-Anchor" href="#const常量类的成员函数"></a> const常量类的成员函数</h5>
<ul>
<li>承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。</li>
<li>const 修饰函数放在，声明之后，实现体之前，大概也没有别的地方可以放了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const 构成函数重载
<ol>
<li>如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数，若无则调用const成员函数。</li>
<li>const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。</li>
<li>类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符</li>
</ol>
</li>
</ul>
<h5 id="const常量类对象"><a class="markdownIt-Anchor" href="#const常量类对象"></a> const常量类对象</h5>
<ol>
<li>const 对象，只能调用 const 成员函数。</li>
<li>可访问 const 或非 const 数据成员，不能修改。</li>
</ol>
<h4 id="static修饰符"><a class="markdownIt-Anchor" href="#static修饰符"></a> static修饰符</h4>
<ul>
<li>在 C++中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。</li>
<li>使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏(相比全局变量的优点)的原则，保证了安全性还可以节省内存。</li>
<li>类的静态成员，属于类，也属于对象，但终归属于类。</li>
</ul>
<h5 id="static的类成员"><a class="markdownIt-Anchor" href="#static的类成员"></a> static的类成员</h5>
<ul>
<li>使用静态类成员
<ol>
<li>static 成员变量实现了同簇类对象间信息共享。</li>
<li>static 成员类外存储，求类大小，并不包含在内。</li>
<li>static 成员是命名空间属于类的全局变量，存储在 data 区 rw 段。</li>
<li>static 成员使用时必须实始化，且只能类外初始化。</li>
<li>可以通过类名访问（无对象生成时亦可），也可以通过对象访问。</li>
<li>static 成员在类声明的时候就开辟空间并初始化了，而普通类成员在类构造时才开辟空间并初始化；</li>
</ol>
</li>
<li>声明：<code>static 数据类型 成员变量; //在类的内部</code></li>
<li>初始化：必须在类的外部<code>数据类型 类名::静态数据成员 = 初值; //没有static修饰</code></li>
<li>调用：<code>类名::静态数据成员</code>; <code>类对象.静态数据成员</code></li>
</ul>
<h5 id="static的类成员函数"><a class="markdownIt-Anchor" href="#static的类成员函数"></a> static的类成员函数</h5>
<ul>
<li>使用静态类成员函数
<ol>
<li>静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。</li>
<li>静态成员函数只能访问静态数据成员。原因：非静态成员函数，在调用时 this指针时被当作参数传进。而静态成员函数属于类，而不属于对象，没有 this 指针。</li>
</ol>
</li>
<li>声明：<code>static 函数声明</code></li>
<li>调用：<code>类名::函数调用</code>；<code>类对象.函数调用</code></li>
</ul>
<h4 id="static-const-类成员"><a class="markdownIt-Anchor" href="#static-const-类成员"></a> static const 类成员</h4>
<ul>
<li>如果一个类的成员，既要实现共享，又要实现不可改变，那就用 static const 修饰。修饰成员函数，格式并无二异，修饰数据成员。</li>
<li>必须要类内部实始化。</li>
</ul>
<h4 id="指向类成员的指针"><a class="markdownIt-Anchor" href="#指向类成员的指针"></a> 指向类成员的指针</h4>
<ul>
<li>在 C++语言中，可以定义一个指针，使其指向类成员或成员函数，然后通过指针来访问类的成员。这包括指向属性成员的指针和指向成员函数的指针。</li>
</ul>
<h5 id="指向类数据成员的指针"><a class="markdownIt-Anchor" href="#指向类数据成员的指针"></a> 指向类数据成员的指针</h5>
<ul>
<li>定义：<code>&lt;成员数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;</code></li>
<li>赋值&amp;初始化：<code>&lt;成员数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;[=&amp;&lt;类名&gt;::&lt;非静态数据成员&gt;]</code>
<ul>
<li>指向非静态数据成员的指针在定义时必须和类相关联，在使用时必须和具体的对象关联。实际保存的是某个对象成员相对于这个类生成对象其实地址的偏移量，所以可以适用任意对象。</li>
</ul>
</li>
<li>解用引：由于类不是运行时 存在的对象。因此，在使用这类指针时，需要首先指定类的一个对象，然后，通过对象来引用指针所指向的成员。<br />
<code>&lt;类对象名&gt;.*&lt;指向非静态数据成员的指针&gt;</code><br />
<code>&lt;类对象指针&gt;-&gt;*&lt;指向非静态数据成员的指针&gt;</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">1002</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> Student::*ps = &amp;Student::name;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.*ps&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Student *pp = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>,<span class="number">1003</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pp-&gt;*ps&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h5 id="指向类成员函数的指针"><a class="markdownIt-Anchor" href="#指向类成员函数的指针"></a> 指向类成员函数的指针</h5>
<ul>
<li>一个指向非静态成员函数的指针必须在三个方面与其指向的成员函数保持一致：参数列表要相同、返回类型要相同、所属的类型要相同</li>
<li>定义：<code>&lt;数据类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)</code></li>
<li>赋值&amp;初始化：<code>&lt;数据类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)[=&amp;&lt;类名&gt;::&lt;非静态成员函数&gt;]</code></li>
<li>解用引由于类不是运行时存在的对象。因此，在使用这类指针时，需要首先指定类的一个对象，然后，通过对象来引用指针所指向的成员。<code>(&lt;类对象名&gt;.*&lt;指向非静态成员函数的指针&gt;)(&lt;参数列表&gt;)</code>；<code>(&lt;类对象指针&gt;-&gt;*&lt;指向非静态成员函数的指针&gt;)(&lt;参数列表&gt;)</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">1002</span>)</span></span>;</span><br><span class="line">Student *ps = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>,<span class="number">1003</span>);</span><br><span class="line"><span class="keyword">void</span> (Student::*pf)() = &amp; Student::dis;</span><br><span class="line">(s.*pf)();</span><br><span class="line">(ps-&gt;*pf)();</span><br></pre></td></tr></table></figure>
<h5 id="指向类静态成员的指针"><a class="markdownIt-Anchor" href="#指向类静态成员的指针"></a> 指向类静态成员的指针</h5>
<ul>
<li><strong>类静态数据成员的指针</strong>：指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。</li>
<li><strong>指向类静态成员函数的指针</strong>：向静态成员函数的指针和普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;data&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp; A::data;<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">void</span> (*pfunc)() = &amp;A::dis;pfunc();</span><br></pre></td></tr></table></figure>
<h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5>
<ul>
<li>与普通意义上的指针不一样。存放的是偏移量。指向非静态成员函数时，必须用类名作限定符，使用时则必须用类的实例作限定符。指向静态成员函数时，则不需要使用类名作限定符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适用类成员函数指针实现内部函数选择调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Widget()&#123;fptr[<span class="number">0</span>] = &amp;f;fptr[<span class="number">1</span>] = &amp;g;fptr[<span class="number">2</span>] = &amp;h;fptr[<span class="number">3</span>] = &amp;i;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx&lt;<span class="number">0</span> || idx&gt;cnt) <span class="keyword">return</span>;</span><br><span class="line">    (<span class="keyword">this</span>-&gt;*fptr[idx])(val);  <span class="comment">//fptr只是存了偏移量，所以必须与this一起</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> cnt;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;void f() &quot;</span>&lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;void g() &quot;</span>&lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;void h() &quot;</span>&lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">i</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;void i() &quot;</span>&lt;&lt;val&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  <span class="keyword">enum</span>&#123; cnt = <span class="number">4</span>&#125;;   <span class="comment">//建议使用匿名enum作为常量</span></span><br><span class="line">  <span class="keyword">void</span> (Widget::*fptr[cnt])(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;w.count(); i++)&#123;</span><br><span class="line">w.select(i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友元friend"><a class="markdownIt-Anchor" href="#友元friend"></a> 友元(Friend)</h2>
<ul>
<li>
<p>采用类的机制后实现了数据的隐藏与封装，类的数据成员一般定义为私有成员，成员函数一般定义为公有的，依此提供类与外界间的通信接口。但是，有时需要定义一些函数，这些函数不是类的一部分，但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该类的友元函数。除了友元函数外，还有友元类，两者统称为友元。友元的作用是提高了程序的运行效率（即减少了类型和安全性检查及调用的时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。</p>
</li>
<li>
<p>可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类。</p>
</li>
<li>
<p>友元目的本质，是让其它不属于本类的成员(全局函数，其它类的成员函数)，成为类的成员而具备了本类成员的属性。</p>
</li>
</ul>
<h3 id="友元使用"><a class="markdownIt-Anchor" href="#友元使用"></a> 友元使用</h3>
<h4 id="声明位置"><a class="markdownIt-Anchor" href="#声明位置"></a> 声明位置</h4>
<ul>
<li>友元声明以关键字friend开始，它只能出现在类定义中。因为友元不是授权类的成员，所以它不受其所在类的声明区域 public private 和 protected 的影响。通常我们选择把所有友元声明组织在一起并放在类头之后.</li>
</ul>
<h4 id="友元的利弊"><a class="markdownIt-Anchor" href="#友元的利弊"></a> 友元的利弊</h4>
<ul>
<li>友元不是类成员，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。不过，类的访问权限确实在某些应用场合显得有些呆板，从而容忍了友元这一特别语法现象。</li>
</ul>
<h4 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h4>
<ol>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>
</ol>
<h3 id="友元函数"><a class="markdownIt-Anchor" href="#友元函数"></a> 友元函数</h3>
<ul>
<li>
<p>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend：<code>friend 类型 函数名(形式参数);</code>,一个函数可以是多个类的友元函数，只需要在各个类中分别声明。</p>
</li>
<li>
<p>全局函数作友元函数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Point(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)&#123; x = xx;y = yy;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>;  <span class="comment">//友元声明在public、private没有区别</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> dx = a.x - b.x;<span class="keyword">double</span> dy = a.y - b.y;<span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line">Point p1(3.0, 4.0), p2(6.0, 8.0);</span><br><span class="line"><span class="keyword">double</span> d = Distance(p1, p2);</span><br></pre></td></tr></table></figure>
<ul>
<li>类成员函数作友元函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>;</span>    <span class="comment">// 前向声明类Point，否则ManagerPoint声明时无法编译通过</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManagerPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>;   <span class="comment">// 能有实现体，否则编译时无法获取Point的结构，造成编译失败不</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy)&#123; x = xx;y = yy;&#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">ManagerPoint::Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ManagerPoint::Distance</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>&#123; <span class="comment">// 实现体在Point实现之后</span></span><br><span class="line"><span class="keyword">double</span> dx = a.x - b.x;<span class="keyword">double</span> dy = a.y - b.y;<span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------</span></span><br><span class="line">Point p1(3.0, 4.0), p2(6.0, 8.0);</span><br><span class="line">ManagerPoint mp;</span><br><span class="line"><span class="keyword">float</span> d = mp.Distance(p1,p2);</span><br></pre></td></tr></table></figure>
<ul>
<li>前向声明，是一种不完全型（forward declaration）声明，即只需提供类名(无需提供类实现)即可。正因为是（incomplete type）功能也很有限:
<ol>
<li>不能定义类的对象。</li>
<li>可以用于定义指向这个类型的指针或引用。</li>
<li>用于声明(不是定义)，使用该类型作为形参类型或者函数的返回值类型。</li>
</ol>
</li>
</ul>
<h3 id="友元类"><a class="markdownIt-Anchor" href="#友元类"></a> 友元类</h3>
<ul>
<li>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</li>
<li>当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> x ,y;</span><br><span class="line">  <span class="keyword">friend</span> Class B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123; A a;<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d&quot;</span>.a.x,a.y);&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载operator-overload"><a class="markdownIt-Anchor" href="#运算符重载operator-overload"></a> 运算符重载(Operator OverLoad)</h2>
<ul>
<li>运算符重载的本质是函数重载。</li>
</ul>
<h3 id="语法格式"><a class="markdownIt-Anchor" href="#语法格式"></a> 语法格式</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返值类型 <span class="keyword">operator</span> 运算符名称(形参表列) &#123;</span><br><span class="line">重载实体; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>operator 运算符名称 在一起构成了新的函数名。</li>
<li>比如<code>const Complex operator+(const Complex &amp;c1,const Complex &amp;c2);</code>我们会说，operator+ 重载了重载了运算符+。</li>
</ul>
<h3 id="友元重载和成员重载"><a class="markdownIt-Anchor" href="#友元重载和成员重载"></a> 友元重载和成员重载</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">const</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1,<span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">  <span class="keyword">const</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;another);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> _x;<span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1,<span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;友元函数重载&quot;</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> Complex(c1._x + c2._x,c1._y + c2._y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp; another)&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;成员函数重载&quot;</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> Complex(<span class="keyword">this</span>-&gt;_x + another._x,<span class="keyword">this</span>-&gt;_y + another._y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重载运算符不能破坏语意。</li>
<li>关于返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;<span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">(a+b) = <span class="number">100</span>; 这种语法是错的，所以重载函数+的返回值加<span class="keyword">const</span>来修饰，防止匿名的返回值被赋值。</span><br><span class="line"><span class="built_in">string</span> a = “china”,b = “ is china”, c;</span><br><span class="line">(c = a) = b; 此时的语法，是重载= 返回值不需加 <span class="keyword">const</span> 。</span><br></pre></td></tr></table></figure>
<h3 id="重载规则-2"><a class="markdownIt-Anchor" href="#重载规则-2"></a> 重载规则</h3>
<ul>
<li>
<p>1、<code>C++</code>不允许用户自己定义新的运算符，只能对已有的 <code>C++</code>运算符进行重载。</p>
<ul>
<li>例如，有人觉得 BASIC 中用<code>**</code>作为幂运算符很方便，也想在 <code>C++</code>中将<code>**</code>定义为幂运算符，用<code>3**5</code>表示3^5，这是不行的</li>
</ul>
</li>
<li>
<p>2、<code>C++</code>中绝大部分运算符都是可以被重载的<br />
<img src="/images/pasted-51.png" alt="可以被重载的运算符" /></p>
<ul>
<li>不能重载的运算符只有 4 个,前两个运算符不能重载是为了保证访问成员的功能不能被改变，域运算符合sizeof运算符的运算对象是类型而不是变量或一般表达式，不具备重载的特征。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>不可重载</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>.*</code></td>
<td>成员对象选择符</td>
</tr>
<tr>
<td><code>::</code></td>
<td>域解析运算符</td>
</tr>
<tr>
<td><code>?:</code></td>
<td>条件运算符，三目运算符</td>
</tr>
<tr>
<td><code>sizeof</code></td>
<td>类型大小运算符</td>
</tr>
</tbody>
</table>
<ul>
<li>只能重载为成员函数的运算符</li>
</ul>
<table>
<thead>
<tr>
<th>不可重载</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>下标运算符</td>
</tr>
<tr>
<td><code>()</code></td>
<td>函数运算符</td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>间接成员访问</td>
</tr>
<tr>
<td><code>-&gt;*</code></td>
<td>间接取值访问</td>
</tr>
</tbody>
</table>
<ul>
<li>3、重载不能改变运算符运算对象（即操作数）的个数。
<ul>
<li>如关系运算符“&gt;”和“&lt;”等是双目运算符，重载后仍为双目运算符，需要两个参数。运算符<code>+</code>，<code>-</code>，<code>*</code>，<code>&amp;</code>等既可以作为单目运算符，也可以作为双目运算符，可以分别将它们重载为单目运算符或双目运算符。</li>
</ul>
</li>
<li>4、重载不能改变运算符的优先级别。
<ul>
<li>例如<code>*</code>和<code>/</code>优先级高于<code>+</code>和<code>-</code>，不论怎样进行重载，各运算符之间的优先级不会改变。有时在程序中希望改变某运算符的优先级，也只能使用加括号的方法强制改变重载运算符的运算顺序。</li>
</ul>
</li>
<li>5、重载不能改变运算符的结合性。
<ul>
<li>如复制运算符”=“是右结合性（自右至左），重载后仍为右结合性。</li>
</ul>
</li>
<li>6、重载运算符的函数不能有默认的参数
<ul>
<li>否则就改变了运算符参数的个数，与前面第3点矛盾。</li>
</ul>
</li>
<li>7、重载运算符的运算中至少有一个操作数是自定义类。
<ul>
<li>重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象（或类对象的引用）。也就是说，参数不能全部是 C++的标准类型，以防止用户修改用于标准类型数据成员的运算符的性质，如下面这样是不对的：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> + (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;<span class="keyword">return</span>(a-b);&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原来运算符+的作用是对两个数相加，现在企图通过重载使它的作用改为两个数相减。如果允许这样重载的话，如果有表达式 4+3，它的结果是 7 还是 1 呢？显然，这是绝对要禁止的。</li>
</ul>
</li>
<li>8、不必重载的运算符（= &amp;）
<ul>
<li>用于类对象的运算符一般必须重载，但有两个例外，运算符”=“和运算符”&amp;“不必用户重载。</li>
<li>复制运算符”=“可以用于每一个类对象，可以用它在同类对象之间相互赋值。因为系统已为每一个新声明的类重载了一个赋值运算符，它的作用是逐个复制类中的数据成员</li>
<li>地址运算符&amp;也不必重载，它能返回类对象在内存中的起始地址。</li>
</ul>
</li>
<li>9、对运算符的重载，不应该失去其原有的意义
<ul>
<li>应当使重载运算符的功能类似于该运算符作用于标准类型数据时候时所实现的功能。</li>
<li>例如，我们会去重载”+“以实现对象的相加，而不会去重载”+“以实现对象相减的功能，因为这样不符合我们对”+“原来的认知。</li>
</ul>
</li>
</ul>
<h3 id="双目运算符重载"><a class="markdownIt-Anchor" href="#双目运算符重载"></a> 双目运算符重载</h3>
<ul>
<li>形式：<code>L#R</code></li>
<li>全局函数：<code>operator#(L,R);</code></li>
<li>成员函数：<code>L.operator#(R)</code></li>
<li>实现重载+=</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Complex&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_x += c._x;<span class="keyword">this</span>-&gt;_y += c._y;<span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> _x;</span><br><span class="line">  <span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="单目运算符重载"><a class="markdownIt-Anchor" href="#单目运算符重载"></a> 单目运算符重载</h3>
<ul>
<li>形式：<code>#M 或 M#</code></li>
<li>全局函数：<code>operator#(M)</code></li>
<li>成员函数：<code>M.operator#()</code></li>
<li>重载-运算符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> Complex <span class="keyword">operator</span>-(<span class="keyword">void</span>) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Complex(-_x,-_y);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> _x;</span><br><span class="line">  <span class="keyword">float</span> _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="重载格式"><a class="markdownIt-Anchor" href="#重载格式"></a> 重载格式</h3>
<p><img src="/images/pasted-52.png" alt="重载与函数调用的关系" /></p>
<ul>
<li>建议</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>建议使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>所有的一元运算符</td>
<td>成员</td>
</tr>
<tr>
<td><code>+=</code> <code>-=</code> <code>/=</code> <code>*=</code> <code>^=</code> <code>&amp;=</code> <code>!=</code> <code>%=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code></td>
<td>成员</td>
</tr>
<tr>
<td>其它二员运算符</td>
<td>非成员</td>
</tr>
</tbody>
</table>
<ul>
<li>友元还是成员
<ol>
<li>一个操作符的左右操作数不一定是相同类型的对象，这就涉及到将该操作符函数定义为谁的友元，谁的成员问题。</li>
<li>一个操作符函数，被声明为哪个类的成员，取决于该函数的调用对象(通常是左操作数)。</li>
</ol>
</li>
</ul>
<h3 id="使用重载完成类型转换"><a class="markdownIt-Anchor" href="#使用重载完成类型转换"></a> 使用重载完成类型转换</h3>
<h4 id="标准类型间转换"><a class="markdownIt-Anchor" href="#标准类型间转换"></a> 标准类型间转换</h4>
<ul>
<li>隐式类型转换：<code>5/8 5.0/8</code></li>
<li>显式类型转换：<code>static_cast&lt;float&gt;(5)/8</code>或者<code>(float)5/8</code></li>
</ul>
<h4 id="用类型转换构造函数进行类型转换"><a class="markdownIt-Anchor" href="#用类型转换构造函数进行类型转换"></a> 用类型转换构造函数进行类型转换</h4>
<ul>
<li>实现其它类型到本类类型的转化。可用于构造和传参（也是构造，赋值）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 目标类&#123;</span></span><br><span class="line">目标类(<span class="keyword">const</span> 源类 &amp; 源类对象引用) &#123;</span><br><span class="line">  根据需求完成从源类型到目标类型的转换</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转换构造函数，本质是一个构造函数。是只有一个参数的构造函数。如有多个参数，只能称为构造函数，而不是转换函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Point3D(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z):_x(x),_y(y),_z(z)&#123;&#125;</span><br><span class="line">  Point3D(Point2D &amp;p)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_x = p._x;<span class="keyword">this</span>-&gt;_y = p._y;<span class="keyword">this</span>-&gt;_z = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _x;<span class="keyword">int</span> _y;<span class="keyword">int</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>explicit 关键字：以显式的方式完成转化 static_cast&lt;目标类&gt; (源类对象)，否则会报错。</li>
<li>implicit 关键字：以隐式的方式完成转化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Point3D</span><span class="params">(Point2D &amp;p)</span> <span class="comment">//注:explicit 是个仅用于声明的关键字&#123;</span></span></span><br><span class="line">this-&gt;_x = p._x;this-&gt;_y = p._y;this-&gt;_z = 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Point2D <span class="title">p2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Point3D p3a = <span class="keyword">static_cast</span>&lt;Point3D&gt; (p2); <span class="comment">//(Point3D)p2;</span></span><br></pre></td></tr></table></figure>
<h4 id="用类型转换操作符函数进行转换"><a class="markdownIt-Anchor" href="#用类型转换操作符函数进行转换"></a> 用类型转换操作符函数进行转换</h4>
<ul>
<li>类型转化函数：转换函数必须是类方法，转换函数无参数，无返回。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 源类&#123;</span></span><br><span class="line"><span class="keyword">operator</span> 转化目标类(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">根据需求完成从源类型到目标类型的转换</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>举例</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Point3D</span><span class="params">()</span></span>;  <span class="comment">//无参数，无返回</span></span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">int</span> _x;<span class="keyword">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Point2D::<span class="keyword">operator</span> <span class="title">Point3D</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Point3D(_x,_y,<span class="number">0</span>);  <span class="comment">//无参数，无返回，但需要return目标类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line">Point3D p3a = p2;</span><br><span class="line">p3a.dis();</span><br></pre></td></tr></table></figure>
<h3 id="重载的高级用法"><a class="markdownIt-Anchor" href="#重载的高级用法"></a> 重载的高级用法</h3>
<h4 id="函数操作符仿函数"><a class="markdownIt-Anchor" href="#函数操作符仿函数"></a> 函数操作符<code>()</code>—仿函数</h4>
<ul>
<li>把类对象像函数名一样使用。仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">返值类型 operator()(参数类型)</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>举例</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">return</span> i*i;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;<span class="keyword">return</span> d*d;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//--------------</span></span><br><span class="line">Pow <span class="built_in">pow</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">pow</span>(<span class="number">4</span>); <span class="comment">//pow.opreator()(4);</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="built_in">pow</span>(<span class="number">5.5</span>);</span><br></pre></td></tr></table></figure>
<h4 id="堆内存操作符-new-delete"><a class="markdownIt-Anchor" href="#堆内存操作符-new-delete"></a> 堆内存操作符 （new delete）</h4>
<ul>
<li>适用于极个别情况需要定制的时候才用的到。注: operator new 中 size_t 参数是编译器自动计算传递的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *);</span><br></pre></td></tr></table></figure>
<ul>
<li>全局重载</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">malloc</span>(size);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;<span class="built_in">free</span>(p);&#125;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span> size)&#123;<span class="keyword">return</span> <span class="built_in">malloc</span>(size);&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *p)&#123;<span class="built_in">free</span>(p);&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类中重载</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;<span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// ((A*)p)-&gt;a = 100;return p;&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;<span class="built_in">free</span>(p);&#125;</span><br><span class="line">  <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span> size)&#123;<span class="keyword">return</span> <span class="built_in">malloc</span>(size);&#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *p)&#123;<span class="built_in">free</span>(p);&#125;</span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解引用与智能指针-"><a class="markdownIt-Anchor" href="#解引用与智能指针-"></a> 解引用与智能指针（<code>-&gt;</code> /<code>*</code>）</h4>
<ul>
<li>常规意义上讲，new 或是 malloc 出来的堆上的空间，都需要手动 delete 和 free 的。但在其它高级语言中，只需申请无需释放的功能是存在的。</li>
<li>智能指针，被auto_ptr托管以后，不需要关心delete问题，他会在ptr离开其栈空间的时候发生。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  ~A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hahaha&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;A&gt; <span class="title">p</span> <span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">p-&gt;func(); <span class="comment">//两种访问方式</span></span><br><span class="line">(*p).func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用重载实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PMA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PMA(A *p):_p(p)&#123;&#125;</span><br><span class="line">  ~PMA()&#123;<span class="keyword">delete</span> _p;&#125;</span><br><span class="line">  A&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *_p;&#125;</span><br><span class="line">  A* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> _p;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  A * _p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="继承与派生inheritderive"><a class="markdownIt-Anchor" href="#继承与派生inheritderive"></a> 继承与派生(Inherit&amp;&amp;Derive)</h2>
<ul>
<li>继承和派生实际描述的是一件事，只不过被描述对象不同，父类派生出子类，子类继承于父类。基类派生出派生类，派生类继承于基类。</li>
</ul>
<h3 id="语法-2"><a class="markdownIt-Anchor" href="#语法-2"></a> 语法</h3>
<ul>
<li>一个派生类可以同时有多个基类，这种情况称为多重继承，派生类只有一个基类，称为单继承。</li>
<li>默认继承方式是private</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名：[继承方式] 基类名&#123;</span></span><br><span class="line">  派生类成员声明；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="派生类的组成"><a class="markdownIt-Anchor" href="#派生类的组成"></a> 派生类的组成</h3>
<ul>
<li>派生类中的成员，包含两大部分，一类是从基类继承过来的，一类是自己增加的成员。从基类继承过过来的表现其共性，而新增的成员体现了其个性。
<ol>
<li>全盘接收，除了构造器与析构器。基类有可能会造成派生类的成员冗余，所以说基类是需设计的。</li>
<li>派生类有了自己的个性，使派生类有了意义。</li>
</ol>
</li>
</ul>
<h3 id="派生类的构造"><a class="markdownIt-Anchor" href="#派生类的构造"></a> 派生类的构造</h3>
<ul>
<li>派生类中由基类继承而来的成员的初始化工作还是由基类的构造函数完成，然后派生类中新增的成员在派生类的构造函数中初始化</li>
</ul>
<h4 id="语法-3"><a class="markdownIt-Anchor" href="#语法-3"></a> 语法</h4>
<ul>
<li>构造函数的初始化顺序是根据声明的顺序初始化。</li>
<li>如果基类中没有默认构造函数(无参)，那么在派生类的构造函数中必须显示调用基类构造函数，以初始化基类成员。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">派生类名::派生类名（参数总表）：基类名（参数表）,内嵌子对象（参数表）&#123;</span><br><span class="line">  派生类新增成员的初始化语句; <span class="comment">//也可出现地参数列表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果父类没有空参构造函数或者默认值构造函数，那么子类必须要使用参数列表的方式，显是的调用父类的构造器，否则无法完成父类的初始化。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------父类-------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Student(<span class="built_in">string</span> sn,<span class="keyword">int</span> n,<span class="keyword">char</span> s):name(sn),num(n),sex(s)&#123;&#125;;</span><br><span class="line">  ~Student();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> name;<span class="keyword">int</span> num;<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-----------子类-------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span>:</span><span class="keyword">public</span> Student</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Graduate(<span class="built_in">string</span> sn,<span class="keyword">int</span> in,<span class="keyword">char</span> cs,<span class="keyword">float</span> fs):Student(sn,in,cs),salary(fs)&#123;&#125;;  <span class="comment">//调用构造器</span></span><br><span class="line">  ~Graduate();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span></span>&#123;dis();<span class="built_in">cout</span>&lt;&lt;salary&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span>:</span><span class="keyword">public</span> Graduate  <span class="comment">//孙子类构造时，只需完成其父类即可，不用完成爷类构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Doctor(<span class="built_in">string</span> sn,<span class="keyword">int</span> in,<span class="keyword">char</span> cs,<span class="keyword">float</span> fs,<span class="built_in">string</span> st):Graduate(sn,in,cs,fs),title(st)&#123;&#125;;  </span><br><span class="line">  ~Doctor();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;dump();<span class="built_in">cout</span>&lt;&lt;title&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> title;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-----------父类2-------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Father()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;father&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  <span class="comment">//无参构造 可以实现子类自动的调用</span></span><br><span class="line">  <span class="comment">//Father(int i=0)&#123;cout&lt;&lt;&quot;father&quot;&lt;&lt;endl;&#125;  // 默认值构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------子类2-------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Son()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;son&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  <span class="comment">//首先会隐式的调用父类无参构造，再调用子类构造</span></span><br><span class="line">  <span class="comment">//Son():father()&#123;cout&lt;&lt;&quot;son&quot;&lt;&lt;endl;&#125;  //显示调用父类器构造</span></span><br><span class="line">  <span class="comment">//Son():father(11)&#123;cout&lt;&lt;&quot;son&quot;&lt;&lt;endl;&#125;  //显示调用父类器有参构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>派生类构造函数执行的次序：<strong>基类–&gt;成员中的类对象–&gt;子类–&gt;孙类</strong></p>
<ol>
<li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左到右）；</li>
<li>调用内嵌成员对象的构造函数，调用顺序按照它们在类中声明的顺序；</li>
<li>派生类的构造函数体中的内容</li>
</ol>
</li>
<li>
<p>子类构造器中，要么显示的调用父类的构造器(传参)，要么隐式的调用。</p>
</li>
<li>
<p>发生隐式调用时，父类要有无参构造器或是可以包含无参构造器的默认参数函数。子类对象亦然。</p>
</li>
</ul>
<h4 id="派生类的拷贝构造"><a class="markdownIt-Anchor" href="#派生类的拷贝构造"></a> 派生类的拷贝构造</h4>
<ul>
<li>派生类中的默认拷贝构造器会调用父类中默认或自实现拷贝构造器，若子类中自实现拷贝构造器，则必须显示的调用父类的拷贝构造器。</li>
<li>格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">派生类::派生类(const 派生类&amp; another)</span><br><span class="line">:基类(another),派生类新成员(another.新成员) &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------父类----------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student(<span class="built_in">string</span> sn,<span class="keyword">int</span> n,<span class="keyword">char</span> s):name(sn),num(n),sex(s)&#123;&#125;;</span><br><span class="line">Student(<span class="keyword">const</span> Student &amp; another)&#123;name = another.name;num = another.num;sex = another.sex;&#125;;  <span class="comment">//父类拷贝构造器</span></span><br><span class="line">~Student();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:<span class="built_in">string</span> name;<span class="keyword">int</span> num;<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//----------父类----------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span>:</span><span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Graduate(<span class="built_in">string</span> sn,<span class="keyword">int</span> in,<span class="keyword">char</span> cs,<span class="keyword">float</span> fs):Student(sn,in,cs),salary(fs)&#123;&#125;;</span><br><span class="line">~Graduate()&#123;&#125;;</span><br><span class="line">Graduate(<span class="keyword">const</span> Graduate &amp; another):Student(another),salary(another.salary)&#123;&#125;;  <span class="comment">//子类自实现拷贝构造，必须显式调用父类的构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span></span>&#123;dis();<span class="built_in">cout</span>&lt;&lt;salary&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">float</span> salary;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="派生类的赋值运算符重载"><a class="markdownIt-Anchor" href="#派生类的赋值运算符重载"></a> 派生类的赋值运算符重载</h4>
<ul>
<li>赋值运算符函数不是构造器，所以可以继承，语法上就没有构造器的严格一些。</li>
<li>派生类的默认赋值运算符重载函数，会调用父类的默认或自实现函数。派生类若自实现，则不会发生调用行为，也不报错(区别拷贝)，赋值错误，若要正确，需要显式的调用父类的构造器</li>
<li>格式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">子类&amp; 子类::<span class="keyword">operator</span>=(<span class="keyword">const</span> 子类&amp; another)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;another)</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//防止自赋值</span></span><br><span class="line">父类::<span class="keyword">operator</span> =(another); <span class="comment">// 调用父类的赋值运算符重载</span></span><br><span class="line"><span class="keyword">this</span>-&gt;salary = another.salary;<span class="comment">//子类成员初始化</span></span><br><span class="line"><span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Graduate &amp; Graduate::<span class="keyword">operator</span>=(<span class="keyword">const</span> Graduate &amp; another)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;another)</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">Student::<span class="keyword">operator</span> =(another);   <span class="comment">// 显式的调用父类的赋值运算符函数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;salary = another.salary;</span><br><span class="line"><span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于父类和子类的成员重名的方法(即使返回值和参数不同，只要函数名相同)，类似上面的父类的赋值运算函数，则需要使用<code>::</code>到父类的命名空间就可以了。</li>
</ul>
<h4 id="派生类友元函数"><a class="markdownIt-Anchor" href="#派生类友元函数"></a> 派生类友元函数</h4>
<ul>
<li>由于友元函数并非类成员，因引不能被继承，在某种需求下，可能希望派生类的友元函数能够使用基类中的友元函数。为此可以通过强制类型转换，将派生类的指针或是引用强转为其类的引用或是指针，然后使用转换后的引用或是指针来调用基类中的友元函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, Student &amp; stu)&#123;out&lt;&lt;stu.a&lt;&lt;<span class="string">&quot;--&quot;</span>&lt;&lt;stu.b&lt;&lt;<span class="built_in">endl</span>;&#125;; </span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">int</span> a;<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span>:</span><span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, Graduate &amp; gra)&#123;</span><br><span class="line">  out&lt;&lt;(Student&amp;)gra&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//强转为student，在使用student的&lt;&lt;操作符</span></span><br><span class="line">  out&lt;&lt;gra.c&lt;&lt;<span class="string">&quot;**&quot;</span>&lt;&lt;gra.d&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//调用自身的变量</span></span><br><span class="line">&#125;;  <span class="comment">// 声明友元</span></span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">int</span> c;<span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="comment">// Student a;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line">Graduate g;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;g&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="派生类析构函数的语法"><a class="markdownIt-Anchor" href="#派生类析构函数的语法"></a> 派生类析构函数的语法</h4>
<ul>
<li>派生类的析构函数的功能是在该对象消亡之前进行一些必要的清理工作，析构函数没有类型，也没有参数。析构函数的执行顺序与构造函数相反。</li>
<li>析构顺序：<strong>子类-&gt;成员-&gt;基类</strong></li>
<li>无需指明析构关系。why? 析构函数只有一种，无重载，无默参。</li>
</ul>
<h4 id="派生类成员的标识和访问"><a class="markdownIt-Anchor" href="#派生类成员的标识和访问"></a> 派生类成员的标识和访问</h4>
<h5 id="作用域分辨符"><a class="markdownIt-Anchor" href="#作用域分辨符"></a> 作用域分辨符</h5>
<ul>
<li>格式：<code>基类名::成员名；基类名::成员名（参数表）；</code></li>
<li>如果某派生类的多个基类拥有同名的成员，同时，派生类又新增这样的同名成员，在这种情况下，派生类成员将<code>shadow(隐藏)</code>所有基类的同名成员。这就需要这样的调用方式才能调用基类的同名成员。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">d.Base::func(<span class="number">3</span>); <span class="comment">//访问基类成员</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>重载和隐藏的区别</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>重载overload</td>
<td>同一作用域 ，函数同名不同参(个数，类型，顺序)</td>
</tr>
<tr>
<td>隐藏shadow</td>
<td>父子类中，标识符(函数，变量)相同，无关乎返值和参数(函数)，或声明类 型(变量)</td>
</tr>
</tbody>
</table>
<h5 id="继承方式"><a class="markdownIt-Anchor" href="#继承方式"></a> 继承方式</h5>
<ul>
<li>
<p>派生类成员属性划分为四种：</p>
<ol>
<li>公有成员</li>
<li>保护成员</li>
<li>私有成员</li>
<li>不可见的成员</li>
</ol>
</li>
<li>
<p>继承方式规定了如何访问基类继承的成员。继承方式有 public, private, protected。继承方式不影响派生类的访问权限，影响了从基类继承来的成员的访问权限，包括派生类内的访问权限和派生类对象。</p>
</li>
<li>
<p>pretected 对于外界访问属性来说，等同于私有，但可以派生类中可见。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>基类成员方式</th>
<th>派生类内部访问</th>
<th>派生类对象访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有继承</td>
<td>public<br>protected<br>private</td>
<td>public<br>protected<br>inaccess</td>
<td>public<br>inaccess<br>inaccess</td>
</tr>
<tr>
<td>保护继承</td>
<td>public<br>protected<br>private</td>
<td>protected<br>protected<br>inaccess</td>
<td>inaccess<br>inaccess<br>inaccess</td>
</tr>
<tr>
<td>私有继承</td>
<td>public<br>protected<br>private</td>
<td>private<br>private<br>inaccess</td>
<td>inaccess<br>inaccess<br>inaccess</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>public 公有继承</p>
<ul>
<li>当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。即基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。</li>
</ul>
</li>
<li>
<p>private 私有继承</p>
<ul>
<li>当类的继承方式为私有继承时，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象，都无法访问从基类继承的私有成员。通过多次私有继承后，对于基类的成员都会成为不可访问。因此私有继承比较少用。</li>
</ul>
</li>
<li>
<p>protected 保护继承</p>
<ul>
<li>保护继承中，基类的公有成员和私有成员都以保护成员的身份出现在派生类中，而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但是类外部通过派生类的对象无法访问它们，无论派生类的成员还是派生类的对象，都无法访问基类的私有成员。</li>
</ul>
</li>
<li>
<p>public作用：传承接口 间接的传承了数据(protected)</p>
</li>
<li>
<p>protected作用：传承数据，间接封杀了对外接口</p>
</li>
<li>
<p>private统杀了数据和接口</p>
<ol>
<li>只要是私有成员到派生类中,均不可访问. 正是体现的数据隐蔽性.其私有成员仅可被本类的成员函数访问</li>
<li>如果多级派生当中，均采用 public,直到最后一级，派生类中均可访问基类的public,protected 成员. 兼顾了数据的隐蔽性和接口传承和数据传递</li>
<li>如果多级派生当中，均采用 private,直到最后一级,派生类中基类的所有成员均变为不可见. 只兼顾了数据的隐蔽性</li>
<li>如果多级派生当中,均采用 protected,直到最后一级，派生类的基类的所有成员即使可见,也均不可被类外调用只兼顾了数据的隐蔽性和数据传递</li>
</ol>
</li>
</ul>
<h3 id="多继承"><a class="markdownIt-Anchor" href="#多继承"></a> 多继承</h3>
<ul>
<li>从继承类别上分，继承可分为单继承和多继承，前面讲的都是单继承。</li>
</ul>
<h4 id="继承语法"><a class="markdownIt-Anchor" href="#继承语法"></a> 继承语法</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">派生类名::派生类名（参数总表）：基类名 <span class="number">1</span>（参数表 <span class="number">1</span>），基类名（参数名 <span class="number">2</span>）....基类名 n（参数名 n），内嵌子对象 <span class="number">1</span>（参数表 <span class="number">1</span>），内嵌子对象 <span class="number">2</span>（参数表 <span class="number">2</span>）....内嵌子对象 n（参数表 n） &#123;</span><br><span class="line">  派生类新增成员的初始化语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三角问题二义性问题"><a class="markdownIt-Anchor" href="#三角问题二义性问题"></a> 三角问题(二义性问题)</h4>
<ul>
<li>多个父类中重名的成员，继承到子类中后，为了避免冲突，携带了各父类的作用域信息, 子类中要访问继承下来的重名成员，则会产生二义性，为了避免冲突，访问时需要还有父类的作用域信息。</li>
</ul>
<h4 id="虚继承"><a class="markdownIt-Anchor" href="#虚继承"></a> 虚继承</h4>
<ul>
<li>在多继承中，保存共同基类的多份同名成员，虽然有时是必要的，可以在不同的数据成员中分别存放不同的数据，但在大多数情况下，是我们不希望出现的。因为保留多份数据成员的拷贝，不仅占有较多的存储空间，还增加了访问的困难。</li>
<li>为此，c++提供了，虚基类和虚继承机制，实现了在多继承中只保留一份共同成员。 虚基类，需要设计和抽象，虚继承，是一种继承的扩展。
<ol>
<li>M 类称为虚基类(virtual base class )，是抽象和设计的结果。</li>
<li>虚继承语法：<code>class 派生类名:virtual 继承方式 基类</code></li>
<li>虚基类及间接类的实始化</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>A(<span class="keyword">int</span> i)&#123;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;B(<span class="keyword">int</span> n):A(n)&#123;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;C(<span class="keyword">int</span> n):A(n)&#123;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> C &#123;D(<span class="keyword">int</span> n):A(n),B(n),C(n)&#123;&#125;&#125;;  <span class="comment">// 这里ABC都要初始化</span></span><br></pre></td></tr></table></figure>
<h2 id="多态polymorphism"><a class="markdownIt-Anchor" href="#多态polymorphism"></a> 多态（PolyMorphism）</h2>
<ul>
<li>C++中所谓的多态(polymorphism)是指，由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应。</li>
<li>多态性是面向对象程序设计的一个重要特征，能增加程序的灵活性。可以减轻系统升级,维 护,调试的工作量和复杂度</li>
</ul>
<h3 id="赋值兼容多态实现的前提"><a class="markdownIt-Anchor" href="#赋值兼容多态实现的前提"></a> 赋值兼容(多态实现的前提)</h3>
<ul>
<li>子类对象（引用或指针）可以赋值给父类对象（引用和指针），并且是隐式的拷贝，子类的新成员父类无法获取。</li>
<li>赋值兼容规则是指在需要基类对象的任何地方都可以使用<strong>公有派生类</strong>的对象来替代。赋值兼容是一种默认行为，不需要任何的显示的转化步骤。</li>
<li>赋值兼容规则中所指的替代包括以下的情况：
<ul>
<li>派生类的对象可以赋值给基类对象。</li>
<li>派生类的对象可以初始化基类的引用。</li>
<li>派生类对象的地址可以赋给指向基类的指针。</li>
<li>只发生在共有派生的父子关系中。</li>
</ul>
</li>
<li>在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。</li>
<li>父类也可以通过强转的方式转化为子类。 父类对象强转为子类对象后，访问从父类继承下来的部分是可以的，但访问子类的部分，则会发生越界的风险，越界的结果是未知的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Shape(<span class="keyword">int</span> x,<span class="keyword">int</span> y):_x(x),_y(y)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;draw Shap &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;start (&quot;</span>&lt;&lt;_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;_y&lt;&lt;<span class="string">&quot;) &quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="keyword">protected</span>:<span class="keyword">int</span> _x;<span class="keyword">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Circle(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> r):Shape(x,y),_r(r)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;draw Circle &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;start (&quot;</span>&lt;&lt;_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;_y&lt;&lt;<span class="string">&quot;) &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;radio r = &quot;</span>&lt;&lt;_r&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">int</span> _r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------</span></span><br><span class="line"><span class="function">Shape <span class="title">s</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">s.draw();    <span class="comment">//shape的draw方法</span></span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">c.draw();    <span class="comment">//circle的draw覆盖了shape的方法</span></span><br><span class="line">s = c;</span><br><span class="line">s.draw();    <span class="comment">//发生赋值兼容，子类给父类对象，只能访问父类的方法</span></span><br><span class="line">Shape &amp;rs = c;</span><br><span class="line">rs.draw();</span><br><span class="line">Shape *ps = &amp;c;  <span class="comment">//给父类的引用</span></span><br><span class="line">ps-&gt;draw();</span><br><span class="line"><span class="comment">//c = static_cast&lt;Circle&gt;(s); //缺少转化函数</span></span><br><span class="line"><span class="comment">//c.draw();</span></span><br><span class="line">Circle * pc = <span class="keyword">static_cast</span>&lt;Circle*&gt;(&amp;s); <span class="comment">//父类通过强转的方式转化为子类</span></span><br><span class="line">pc-&gt;draw();    <span class="comment">//通过赋值兼容，导致父类接收子类时，强制变为了父类的结构</span></span><br></pre></td></tr></table></figure>
<h3 id="多态的形成"><a class="markdownIt-Anchor" href="#多态的形成"></a> 多态的形成</h3>
<h4 id="静多态"><a class="markdownIt-Anchor" href="#静多态"></a> 静多态</h4>
<ul>
<li>前面学习的函数重载，也是一种多态现象，通过命名倾轧在编译阶段决定，故称为静多态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">float</span> b)</span></span>;  <span class="comment">// func_i_f</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> a,<span class="keyword">int</span> b)</span></span>;  <span class="comment">// func_f_i  在编译时，对同名函数做了区分</span></span><br></pre></td></tr></table></figure>
<h4 id="动多态"><a class="markdownIt-Anchor" href="#动多态"></a> 动多态</h4>
<ul>
<li>动多态是在运行阶段决定，故称为动多态。动多态行成的</li>
<li>条件如下:
<ol>
<li>父类中有虚函数。</li>
<li>子类 override(覆写)父类中的虚函数。</li>
<li>通过己被子类对象赋值的父类指针或引用，调用共用接口。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Shape(<span class="keyword">int</span> x,<span class="keyword">int</span> y):_x(x),_y(y)&#123;&#125;</span><br><span class="line">  <span class="comment">//1、声明虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;draw Shap &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;start (&quot;</span>&lt;&lt;_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;_y&lt;&lt;<span class="string">&quot;) &quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="keyword">protected</span>:<span class="keyword">int</span> _x;<span class="keyword">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Circle(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> r):Shape(x,y),_r(r)&#123;&#125;</span><br><span class="line">  <span class="comment">//2、子类覆写虚函数，带不带virtual声明都没有关系</span></span><br><span class="line">  <span class="function">virttual <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;draw Circle &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;start (&quot;</span>&lt;&lt;_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;_y&lt;&lt;<span class="string">&quot;) &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;radio r = &quot;</span>&lt;&lt;_r&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">int</span> _r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------</span></span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">Shape *ps=&amp;c;  <span class="comment">//3、通过己被子类对象赋值的父类指针（或者引用），调用共用接口</span></span><br><span class="line">ps-&gt;draw();   <span class="comment">//此时ps体现的是子类的特性，而不是父类的特性了。</span></span><br></pre></td></tr></table></figure>
<h3 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h3>
<ol>
<li>只有类的成员函数才能声明为虚函数
<ul>
<li>虚函数仅适用于有继承关系的类对象，所以普通函数不能声明为虚函数。</li>
</ul>
</li>
<li>静态成员函数不能是虚函数
<ul>
<li>静态成员函数不受对象的捆绑，只有类的信息。</li>
</ul>
</li>
<li>内联函数不能是虚函数</li>
<li>构造函数不能是虚函数
<ul>
<li>构造时，对象的创建尚未完成。构造完成后，才能算一个名符其实的对象。</li>
</ul>
</li>
<li>析构函数可以是虚函数且通常声明为虚函数。</li>
</ol>
<h4 id="虚函数的声明"><a class="markdownIt-Anchor" href="#虚函数的声明"></a> 虚函数的声明</h4>
<ul>
<li>格式：<code>class 类名&#123;virtual 函数声明; &#125;</code></li>
<li>虚函数要点
<ol>
<li>在基类中用 virual 声明成员函数为虚函数。类外实现虚函数时，不必再加 virtual.</li>
<li>在派生类中重新定义此函数称为覆写，要求函数名，返值类型，函数参数个数及类型全部匹配。并根据派生类的需要重新定义函数体。</li>
<li>当一个成员函数被声明为虚函数后，其派生类中完全相同的函数（显示的写出）也为虚函数。 可以在其前加 virtual 以示清晰。</li>
<li>定义一个指基类对象的指针，并使其指向其子类的对象，通过该指针调用虚函数，此时调用的就是指针变量指向对象的同名函数。</li>
<li>子类中的覆写的函数，可以为任意访问类型，依子类需求决定。</li>
</ol>
</li>
</ul>
<h4 id="覆写override"><a class="markdownIt-Anchor" href="#覆写override"></a> 覆写override</h4>
<table>
<thead>
<tr>
<th>重载、隐藏、覆写的区别</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>重载overload</td>
<td>同一作用域 ，函数同名不同参(个数，类型，顺序)</td>
</tr>
<tr>
<td>隐藏shadow</td>
<td>父子类中，标识符(函数，变量)相同，无关乎返值和参数(函数)，或声明类 型(变量)</td>
</tr>
<tr>
<td>覆写override</td>
<td>父子类中含有virtual声明的同名、同参、同返回的虚函数，子类将其重写</td>
</tr>
</tbody>
</table>
<h4 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h4>
<ul>
<li>要点
<ol>
<li>含有纯虚函数的类，称为抽象基类，不可实列化。即不能创建对象，存在的意义就是被继承，提供族类的公共接口，java 中称为 interface。</li>
<li>纯虚函数只有声明，没有实现，被“初始化”为 0。</li>
<li>如果一个类中声明了纯虚函数，而在派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数，派生类仍然为纯虚基类。</li>
</ol>
</li>
<li>格式：<code>class 类名&#123;virtual 函数声明 = 0;&#125;</code> 0只是纯虚函数的格式，没有实现体</li>
<li>例举</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------Shape 类中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//------------Circle 类中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;draw Circle &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;start (&quot;</span>&lt;&lt;_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;_y&lt;&lt;<span class="string">&quot;) &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;radio r = &quot;</span>&lt;&lt;_r&lt;&lt;<span class="built_in">endl</span>;&#125; </span><br><span class="line"><span class="comment">//------------main()</span></span><br><span class="line"><span class="comment">// Shape s(1,2); //函数纯虚函数的类称为抽象基类</span></span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Rect <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">Shape *pc = &amp;c;</span><br><span class="line">pc-&gt;draw();</span><br><span class="line">pc = &amp;r;</span><br><span class="line">pc-&gt;draw();</span><br></pre></td></tr></table></figure>
<h4 id="含有虚函数的析构"><a class="markdownIt-Anchor" href="#含有虚函数的析构"></a> 含有虚函数的析构</h4>
<ul>
<li>含有虚函数的类，析构函数也应该声明为虚函数。在 delete 父类指针的时候，会调用子类的析构函数，实现完整析构。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Shape(<span class="keyword">int</span> x,<span class="keyword">int</span> y):_x(x),_y(y)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">  vitual ~Shape()&#123;&#125;;      <span class="comment">// 虚析构，能够将子类的和自身完整析构。</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="keyword">protected</span>:<span class="keyword">int</span> _x;<span class="keyword">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Circle(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> r):Shape(x,y),_r(r)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;draw Circle &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;start (&quot;</span>&lt;&lt;_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;_y&lt;&lt;<span class="string">&quot;) &quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;radio r = &quot;</span>&lt;&lt;_r&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:<span class="keyword">int</span> _r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">Shape *s = <span class="keyword">new</span> Circle(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">s.Show()</span><br><span class="line"><span class="keyword">delete</span> s;  <span class="comment">// 首先析构Cricle，再析构Shape，完成完整析构。</span></span><br></pre></td></tr></table></figure>
<h3 id="运行时类型信息rtti"><a class="markdownIt-Anchor" href="#运行时类型信息rtti"></a> 运行时类型信息(RTTI)</h3>
<ul>
<li>typeid、dynamic_cast是C++运行时类型信息RTTI(run time type identificaiton)重要组成部分。运行时信息，来自于多态，所以只用于基于多态的继承体系中。</li>
</ul>
<h4 id="typeid"><a class="markdownIt-Anchor" href="#typeid"></a> typeid</h4>
<ul>
<li>运算符 typeid 返回包含操作数数据类型信息的 type_info 对象的一个引用，信息中包括数据类型的名称，要使用 typeid,程序中需要包含头文件<code>&lt;typeinfo&gt;</code>。</li>
<li>其中 type_info 重载了操作符==, !=,分别用来比较是否相等、不等，函数 name()返回类型名称。type_info 的拷贝和赋值均是私有的，故不可拷贝和赋值。</li>
<li>常用于返回检查,调试之用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Func)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span><span class="keyword">public</span>:<span class="keyword">virtual</span> ~Base()&#123;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span><span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">int</span>).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">double</span>).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">char</span> *).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">char</span> **).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">const</span> <span class="keyword">char</span> *).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> ).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(Func).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(Base).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(Derive).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Derive d;</span><br><span class="line">Base &amp;b = d; <span class="comment">//Base 中没有虚函数时，有时？</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(b).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(d).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Base *p = &amp;d;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(p).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//判断指针是，其实是看不出其类型信息的</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(*p).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(d).name()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;boolalpha&lt;&lt;(<span class="keyword">typeid</span>(*p)== <span class="keyword">typeid</span>(d))&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>多态下使用 typeid 时要注意的问题:
<ol>
<li>确保基类定义了至少一个虚函数(虚析构也算)。</li>
<li>不要将 typeid 作用于指针，应该作用于引用，或解引用的指针。</li>
<li>typeid 是一个运算符，而不是函数。</li>
<li>typeid 运算符返回的 type_info 类型，其拷贝构造函数和赋值运算函数都声明为private 了，这意味着其不能用于 stl 容器，所以我们一般不能不直接保存 type_info 信息，而保存 type_info 的 name 信息</li>
</ol>
</li>
</ul>
<h4 id="typecast"><a class="markdownIt-Anchor" href="#typecast"></a> typecast</h4>
<h5 id="static_cast"><a class="markdownIt-Anchor" href="#static_cast"></a> static_cast</h5>
<ul>
<li>在一个方向上可以作隐式转换的，在另外一个方向上可以作静态转换。发生在编译阶段，不保证后序使用的正确性。</li>
</ul>
<h5 id="reinterpreter_cast"><a class="markdownIt-Anchor" href="#reinterpreter_cast"></a> reinterpreter_cast</h5>
<ul>
<li>既不在编译器期也不在运行期进行检查，安全性完全由程序员决定。</li>
</ul>
<h5 id="dynamic_cast"><a class="markdownIt-Anchor" href="#dynamic_cast"></a> dynamic_cast</h5>
<ul>
<li>dynamic_cast 一种运行时的类型转化方式,所以要在运行时作转换判断。检查指针所指类型，然后判断这一类型是否与正在转换成的类型有一种 “is a”的关系，如果是，dynamic_cast 返回对象地址。如果不是，dynamic_cast 返回 NULL。</li>
<li>dynamic_cast 常用多态继承中，判断父类指针的真实指向。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><span class="keyword">public</span>:<span class="keyword">virtual</span> ~A()&#123;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span>&#125;;</span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line">B b;</span><br><span class="line">A *pa = &amp;b;</span><br><span class="line">B *pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pa); <span class="comment">//成功</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">C *pc = <span class="keyword">dynamic_cast</span>&lt;C*&gt;(pa); <span class="comment">//成功 安全</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">D *pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pa); <span class="comment">//成功 安全</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">pb = <span class="keyword">static_cast</span>&lt;B*&gt;(pa); <span class="comment">//成功</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;C*&gt;(pa); <span class="comment">//成功 不安全</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// pd = static_cast&lt;D*&gt;(pa); //编译 不成功</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;pd&lt;&lt;endl;</span></span><br><span class="line">pb = <span class="keyword">reinterpret_cast</span>&lt;B*&gt;(pa); <span class="comment">//成功 不安全</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pb&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">pc = <span class="keyword">reinterpret_cast</span>&lt;C*&gt;(pa); <span class="comment">//成功 不安全</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">pd = <span class="keyword">reinterpret_cast</span>&lt;D*&gt;(pa); <span class="comment">//成功 不安全</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pd&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="多态实现原理"><a class="markdownIt-Anchor" href="#多态实现原理"></a> 多态实现原理</h3>
<h4 id="虚函数表"><a class="markdownIt-Anchor" href="#虚函数表"></a> 虚函数表</h4>
<ul>
<li>C++的多态是通过一张虚函数表（Virtual Table）来实现的，简称为 V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆写的问题，保证其真实反应实际的函数。</li>
<li>这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</li>
<li>虚函数表是在构造函数中生成的，所以构造函数不能为虚函数。同时，子类构造时，由于先进行主类构造，构造调用子类重写的虚函数是不成功的，因为虚函数表没有生成，所以就近调用自己的函数。还有析构时，子类优先析构，主类调用时也无法获得虚函数表，也会就近调用自己的虚函数。</li>
<li>这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中<strong>最前面的位置</strong>（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------获取虚函数表--------------</span></span><br><span class="line">Base b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;基类 b 的起始地址:&quot;</span>&lt;&lt;(<span class="keyword">int</span>*)(&amp;b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;VTalbe 的起始地址:&quot;</span>&lt;&lt;(<span class="keyword">int</span>**)(<span class="keyword">int</span>*)(&amp;b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">FUNC pf = <span class="literal">NULL</span>;</span><br><span class="line">pf = (FUNC)*((<span class="keyword">int</span>**)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>);</span><br><span class="line">pf();</span><br><span class="line">pf = (FUNC)*((<span class="keyword">int</span>**)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>);</span><br><span class="line">pf();</span><br><span class="line">pf = (FUNC)*((<span class="keyword">int</span>**)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>);</span><br><span class="line">pf();</span><br><span class="line">&gt;&gt;&gt; <span class="number">4</span></span><br><span class="line">&gt;&gt;&gt; 基类 b 的起始地址:<span class="number">0x28fea8</span></span><br><span class="line">&gt;&gt;&gt; VTalbe 的起始地址:<span class="number">0x28fea8</span></span><br><span class="line">&gt;&gt;&gt; Base::f</span><br><span class="line">&gt;&gt;&gt; Base::g</span><br><span class="line">&gt;&gt;&gt; Base::h</span><br></pre></td></tr></table></figure>
<ul>
<li>通过这个示例，我们可以看到，我们可以通过强行把&amp;b 转成 <code>int *</code>，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是 Base::f()，这在上面的程序中得到了验证（把 int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和 Base::h()，其代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>**)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>); <span class="comment">// Base::f()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>**)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>); <span class="comment">// Base::g()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>**)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>); <span class="comment">// Base::h()</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-53.png" alt="虚函数表" /></p>
<ul>
<li>在对象首地址指向的虚函数表的最后有一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。</li>
</ul>
<h4 id="无虚函数覆写继承"><a class="markdownIt-Anchor" href="#无虚函数覆写继承"></a> 无虚函数覆写继承</h4>
<ul>
<li>假设有下面父类和子类，在这个继承关系中，子类没有重载任何父类的函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive</span> :</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drive::f1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drive::g1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drive::h1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-54.png" alt="虚函数表" /></p>
<ul>
<li>则派生类的实例中，其虚函数表如下所示
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面</li>
</ol>
</li>
</ul>
<h4 id="有虚函数覆写继承"><a class="markdownIt-Anchor" href="#有虚函数覆写继承"></a> 有虚函数覆写继承</h4>
<ul>
<li>在这个继承关系中，子类覆盖了父类的一个函数：f()。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::g&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::h&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive</span> :</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drive::f&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drive::g1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Drive::h1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-55.png" alt="虚函数表" /></p>
<ul>
<li>可以看出
<ol>
<li>覆写的 f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Derive();</span><br><span class="line">b-&gt;f();</span><br></pre></td></tr></table></figure>
<ul>
<li>由 b 所指的内存中的虚函数表的 f()的位置已经被 Derive::f()函数地址所取代，于是在实际调用发生时，是 Derive::f()被调用了。这就实现了多态。</li>
<li>静态代码执行过程：当编译器看到这段代码的时候，并不知道 b 真实身份。编译器能作的就是用一段代码代替这段语句。
<ol>
<li>明确 b 类型。</li>
<li>然后通过指针虚函数表的指针 vptr 和偏移量,匹配虚函数的入口。</li>
<li>根据入口地址调用虚函数。</li>
</ol>
</li>
</ul>
<h1 id="c高级"><a class="markdownIt-Anchor" href="#c高级"></a> <code>C++</code>高级</h1>
<h2 id="模板templates"><a class="markdownIt-Anchor" href="#模板templates"></a> 模板(Templates)</h2>
<ul>
<li>泛型(Generic Programming)即是指具有在多种数据类型上皆可操作的含意。泛型编程的代表作品 STL 是一种高效、泛型、可交互操作的软件组件。</li>
<li>泛型编程最初诞生于 <code>C++</code>中，目的是为了实现 <code>C++</code>的 STL（标准模板库）。其语言支持机制就是模板（Templates）。模板的精神其实很简单：参数化类型。换句话说，把一个原本特定于某个类型的算法或类当中的类型信息抽掉，抽出来做成模板参数 T。</li>
</ul>
<h3 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h3>
<h4 id="函数重载实现的泛型"><a class="markdownIt-Anchor" href="#函数重载实现的泛型"></a> 函数重载实现的泛型</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">double</span>&amp; a,<span class="keyword">double</span>&amp; b)</span></span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="函数模板的引入"><a class="markdownIt-Anchor" href="#函数模板的引入"></a> 函数模板的引入</h4>
<ul>
<li>函数模板，只适用于函数的参数个数相同而类型不同，且函数体相同的情况。如果个数不同，则不能用函数模板。</li>
<li>语法格式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>/<span class="class"><span class="keyword">class</span> 类型参数表&gt;</span></span><br><span class="line"><span class="class">返回类型 函数模板名(函数参数列表) &#123;</span></span><br><span class="line">函数模板定义体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>template 是语义是模板的意思，尖括号中先写关键字 typename 或是 class ，后面跟一个类型 T,此类即是虚拟的类型。至于为什么用 T,用的人多了，也就是 T 了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;&#125;<span class="comment">//函数模板，根据具体类型产生模板函数</span></span><br><span class="line">swap&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">3</span>);     <span class="comment">//调用，&lt;int&gt;也可以省略</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> T2&gt;  <span class="comment">//多个类型定义</span></span><br></pre></td></tr></table></figure>
<h3 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h3>
<ul>
<li>由类模板，会生成对应的类，再生成类对象。</li>
<li>类模板语法</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------类模板定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span>&#125;</span><br><span class="line"><span class="comment">//---------类内定义成员函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&#123;</span><span class="keyword">public</span>:Stack(<span class="keyword">int</span> size)&#123;space = <span class="keyword">new</span> T[size];top = <span class="number">0</span>;&#125; &#125;</span><br><span class="line"><span class="comment">//---------类外定义函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push(T data)&#123;space[top++] = data;&#125;</span><br><span class="line"><span class="comment">//---------类模板实例化为模板类</span></span><br><span class="line">类模板是类的抽象，类是类模板的实例。</span><br><span class="line"><span class="function">Stack&lt;<span class="keyword">double</span>&gt; <span class="title">s</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="io-流"><a class="markdownIt-Anchor" href="#io-流"></a> IO 流</h2>
<ul>
<li>在<code>C++</code>中cin和cout充当了scanf和printf的功能。但他们并不是函数。而是类对象。</li>
</ul>
<p><img src="/images/pasted-56.png" alt="io 类关系" /></p>
<ul>
<li><strong>特点</strong></li>
<li>IO对象不可复制或赋值</li>
<li>IO对象是缓冲的，下面几种情况会导致刷缓冲
<ol>
<li>程序正常结束，作为 main 函数结束的一部分，将清空所有缓冲区。</li>
<li>缓冲区满，则会刷缓冲。</li>
<li>endl, flush 也会刷缓冲。</li>
<li>在每次输出操作执行完后，用 unitbuf 操作符设置流的内部状态，从而清空缓冲区。</li>
</ol>
</li>
<li>重载了&lt;&lt; 和 &gt;&gt;运算符</li>
</ul>
<h3 id="输入输出-io-流"><a class="markdownIt-Anchor" href="#输入输出-io-流"></a> 输入输出 IO 流</h3>
<h4 id="标准输出"><a class="markdownIt-Anchor" href="#标准输出"></a> 标准输出</h4>
<ul>
<li>C++提供的输出流对象有：
<ul>
<li>cout：输出基本类型数据时，不必考虑数据是什么类型，系统会自动判断，选择相应的重载函数；输出用户自己定义的类型数据时，要重载&lt;&lt;运算符。</li>
<li>cerr：是在屏幕上显示出错信息，与 cout 用法类似，不同的是只能在屏幕上，而不能在磁盘文件上输出错误信息；</li>
<li>clog：用法与 cerr 类似，不同点是它带有缓冲区。</li>
</ul>
</li>
</ul>
<h5 id="引用流算子iomanip"><a class="markdownIt-Anchor" href="#引用流算子iomanip"></a> 引用流算子iomanip</h5>
<ul>
<li>系统自带了一些格式化方法，不过设置很麻烦</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.unsetf(ios::dec);   <span class="comment">//取消10进制</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::hex);   <span class="comment">//16进制</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::hex);   <span class="comment">//取消16进制</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用流算子</li>
</ul>
<table>
<thead>
<tr>
<th>控制符</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>dec<br>hex<br>oct</td>
<td>十进制数输出<br> 十六进制输出<br> 八进制数输出</td>
<td><code>cout&lt;&lt;&quot;十进制 :&quot;&lt;&lt;n&lt;&lt;endl;</code><br><code>cout&lt;&lt;&quot;十六进制:&quot;&lt;&lt;hex&lt;&lt;n&lt;&lt;endl;</code><br><code>cout&lt;&lt;&quot;八进制 :&quot;&lt;&lt;oct&lt;&lt;n&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setfill©</td>
<td>在给定的输出域宽度内填充字符 c，需要与 setw(n)合用</td>
<td><code>cout&lt;&lt;setfill('*')&lt;&lt;setw(5)&lt;&lt;x&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setprecison(n)</td>
<td>设显示小数精度为 n 位，自动四舍五入</td>
<td><code>cout&lt;&lt;setprecision(2)&lt;&lt;dd&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setw(n)</td>
<td>设域宽为 n 个字符</td>
<td><code>cout&lt;&lt;setw(10)&lt;&lt;m&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::fixed)</td>
<td>固定的浮点显示，此时精度域表示小数位数</td>
<td><code>cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;dd&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::scientific)</td>
<td>指数显示，科学记数法，此时精度域表示小数位数</td>
<td><code>cout&lt;&lt;setiosflags(ios::scientific)&lt;&lt;dd&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::left)</td>
<td>左对齐</td>
<td><code>cout&lt;&lt;setiosflags(ios::left)&lt;&lt;setw(10)&lt;&lt;y&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::right)</td>
<td>右对齐</td>
<td></td>
</tr>
<tr>
<td>setiosflags(ios::showpoint)</td>
<td>强制显示小数点和尾</td>
<td><code>cout&lt;&lt;setiosflags(ios::showpoint)&lt;&lt;d1&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::showpos)</td>
<td>强制显示符号</td>
<td><code>cout&lt;&lt;setiosflags(ios::showpos)&lt;&lt;d2&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::skipws)</td>
<td>忽略前导空白</td>
<td></td>
</tr>
<tr>
<td>setiosflags(ios::uppercase)</td>
<td>十六进制数大写输出</td>
<td><code>cout&lt;&lt;&quot;以大写方式输出进制数: &quot;&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;num&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::lowercase)</td>
<td>十六进制数小写输出</td>
<td><code>cout&lt;&lt;&quot;16 进制数(默认：小写方式):&quot;&lt;&lt;hex&lt;&lt;num&lt;&lt;endl;</code></td>
</tr>
<tr>
<td>setiosflags(ios::showbase)</td>
<td>当按十六进制输出数据时，前面显示前导符 0x；当按八进制输出数据时，前面显示前导符 0</td>
<td></td>
</tr>
<tr>
<td>endl</td>
<td>输入一个换行符并刷新流</td>
<td></td>
</tr>
<tr>
<td>resetiosflags</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="标准输入-cin"><a class="markdownIt-Anchor" href="#标准输入-cin"></a> 标准输入 cin</h4>
<ul>
<li>在 C++中，默认的标准输入设备是键盘，在 iostream 文件中定义了 cin 输入流对象。</li>
<li>cin 对象与提取运算符&gt;&gt;、变量名或数组名一起构成输入语句，形式为 C++的格式化输入。</li>
<li>cin&gt;&gt;…&gt;&gt;…&gt;&gt;…；，能够连续输入多项内容。只要是基本数据类型，不管是 int、double、float，还是 <code>char</code>、<code>char *</code>等，都可以写成这种形式，这给用户提供了很大的方便。如果要输入用户自己定义的类型数据，就要用友元方式重载&gt;&gt;运算符;</li>
</ul>
<h5 id="成员函数"><a class="markdownIt-Anchor" href="#成员函数"></a> 成员函数</h5>
<table>
<thead>
<tr>
<th>控制符</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>char get()</code></td>
<td>读入一个字符并返回(包括回车、tab、空格等空白字符)，遇到ctrl+z才结束</td>
<td></td>
</tr>
<tr>
<td><code>istream&amp; get(char &amp;)</code></td>
<td>读入一个字符,如果读取成功则返回非 0 值(真),如失败(遇到文件结束符)，则函数返回 0 值(假)。</td>
<td></td>
</tr>
<tr>
<td><code>istream&amp; get(char *, int ,char )</code></td>
<td>istream&amp; get(字符数组，字符个数 n,终止字符)<br>istream &amp; get(字符指针，字符个数 n,终止字符)从输入流中读取 n-1 字符，赋给字符数组或字符指针所指向的数组。如果在读取 n-1 个字符之前遇到终止字符，则提前结束。如果成功则返回非 0，失败 则返回 0。会清空<code>char*</code>指向的空间，未读到 n-1 个字符或中止符，则会阻塞。不会越过中止符。</td>
<td></td>
</tr>
<tr>
<td><code>istream&amp; getline(char *, int , char)</code></td>
<td>与带三个参数的 get()功能类似，从输入流中读取 n-1 字符，赋给字符数组或字符指针所指向的空间。如果在读取 n-1 个字符之前遇到终止字符（如果不写，默认为’\n’），则提前结束。会清空 <code>char*</code>指向的空间，未读到 n-1 个字符或中止符，则会阻塞。会越过中止符</td>
<td></td>
</tr>
<tr>
<td><code>istream&amp;ignore(streamsize n = 1, int delim= EOF</code>);</td>
<td>跳过流中的 n 个字符，或遇到终止字符为止（包含）, 默认参数忽略一个字符。</td>
<td></td>
</tr>
<tr>
<td><code>int peek();</code></td>
<td>窥视 当前指针未发生移动</td>
<td></td>
</tr>
<tr>
<td><code>istream&amp; putback (char c);</code></td>
<td>回推 插入当前指针位置</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>get 和 getline 最大的区别就是，get 遇到界定符时，停止执行，但并不从流中提取界定符，再次调用会遇到同一个界定符，函数将立即返回，不会提取输入。getline 则不同，它将从输入流中提供界定符，但不会把它放到缓冲区中。</li>
</ul>
<h3 id="文件-io-流"><a class="markdownIt-Anchor" href="#文件-io-流"></a> 文件 IO 流</h3>
<ul>
<li>指程序与数据的交互是以流的形式进行的.进行 C 语言文件的存取时,都会先进行“打开文件”操作,这个操作就是在打开数据流,而“关闭文件”操作就是关闭数据流。</li>
</ul>
<h4 id="缓冲区buffer"><a class="markdownIt-Anchor" href="#缓冲区buffer"></a> 缓冲区(Buffer)</h4>
<ul>
<li>
<p>指在程序执行时,所提供的额外内存,可用来暂时存放做准备执行的数据.它的设置是为了提高存取效率,因为内存的存取速度比磁盘驱动器快得多. C++ 语言中带缓冲区的文件处理：</p>
</li>
<li>
<p>C++ 语言的文件处理功能依据系统是否设置“缓冲区”分为两种：</p>
<ul>
<li>一种是设置缓冲区</li>
<li>另一种是不设置缓冲区</li>
</ul>
</li>
<li>
<p>当使用标准 I/O 函数(包含在头文件 cstdio 中)时,系统会自动设置缓冲区,并通过数据流来读写文件. 当进行文件读取时,不会直接对磁盘进行读取,而是先打开数据流,将磁盘上的文件信息拷贝到缓冲区内,然后程序再从缓冲区中读取所需数据,如下图所示：</p>
</li>
<li>
<p>文件类型分为文本文件和二进制文件两种.</p>
</li>
<li>
<p>文件存取方式：包括顺序存取方式和随机存取方式两种.</p>
<ul>
<li>顺序读取：也就是从上往下,一笔一笔读取文件的内容.保存数据时,将数据附加在文件的末尾.这种存取方式常用于文本文件,而被存取的文件则称为顺序文件.</li>
<li>随机存取：多半以二进制文件为主.它会以一个完整的单位来进行数据的读取和写入,通常以结构为单位.</li>
</ul>
</li>
</ul>
<h4 id="借助文件指针读写文件"><a class="markdownIt-Anchor" href="#借助文件指针读写文件"></a> 借助文件指针读写文件</h4>
<ul>
<li>我们如果要访问文件,要借助于文本变量,即文件指针<code>FILE *</code>才可以完成。文件在进行读写操作之前要先打开,使用完毕要关闭.所谓打开文件,实际上是建立文件的各种有关信息,并使文件指针指向该文件,以便进行其它操作.关闭文件则断开指针与文件之间的联系,也就禁止再对该文件进行操作。</li>
</ul>
<h4 id="文件流类与文件流对象"><a class="markdownIt-Anchor" href="#文件流类与文件流对象"></a> 文件流类与文件流对象</h4>
<ul>
<li>对文件的操作是由文件流类完成的。文件流类在流与文件间建立连接。由于文件流分为三种：文件输入流、文件输出流、文件输入/输出流，所以相应的必须将文件流说明为 ifstream、ofstream 和 fstream 类的对象，然后利用文件流的对象对文件进行操作。</li>
<li>对文件的操作过程可按照一下四步进行：即定义文件流类的对象、打开文件、对文件进行读写操作、关闭文件。</li>
</ul>
<h4 id="文件的打开和关闭"><a class="markdownIt-Anchor" href="#文件的打开和关闭"></a> 文件的打开和关闭</h4>
<h5 id="定义流对象"><a class="markdownIt-Anchor" href="#定义流对象"></a> 定义流对象</h5>
<table>
<thead>
<tr>
<th>流类</th>
<th>流对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>ifstream ifile;</td>
<td>定义一个文件输入流对象</td>
</tr>
<tr>
<td>ofstream ofile;</td>
<td>定义一个文件输出流对象</td>
</tr>
<tr>
<td>fstream iofile;</td>
<td>定义一个文件输出/输入流对象</td>
</tr>
</tbody>
</table>
<h5 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h5>
<ul>
<li>定义了文件流对象后，就可以利用其成员函数 open（）打开需要操作的文件，该成员函数的函数原型为：<code>void open（const unsigned char *filename,int mode,int access=filebuf:openprot）；</code>其中：filename 是一个字符型指针，指定了要打开的文件名；mode 指定了文件的打开方式，其值如下表所示；access 指定了文件的系统属性：</li>
</ul>
<table>
<thead>
<tr>
<th>文件打开方式</th>
<th>值</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::in</td>
<td>0x01</td>
<td>以输入（读）方式打开文件，若文件不存在则报错。</td>
</tr>
<tr>
<td>ios::out</td>
<td>0x02</td>
<td>以输出（写）方式打开文件, 若文件不存则创建。</td>
</tr>
<tr>
<td>ios::app</td>
<td>0x08</td>
<td>打开一个文件使新的内容始终添加在文件的末尾，若文件不存在，则报错。</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>0x10</td>
<td>若文件存在，则清除文件所有内容；若文件不存在，则创建新文件。</td>
</tr>
<tr>
<td>ios::binary</td>
<td>0x80</td>
<td>以二进制方式打开文件，缺省时以文本方式打开文件。</td>
</tr>
<tr>
<td>ios::nocreate</td>
<td>0x20</td>
<td>打开一个已有文件，若该文件不存在，则打开失败。</td>
</tr>
<tr>
<td>ios::noreplace</td>
<td>0x40</td>
<td>若打开的文件已经存在，则打开失败。</td>
</tr>
</tbody>
</table>
<ul>
<li>说明：
<ul>
<li>在实际使用过程中，可以根据需要将以上打开文件的方式用“|”组合起来。如：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ios::in|ios::out 表示以读/写方式打开文件</span><br><span class="line">ios::in|ios:: binary 表示以二进制读方式打开文件</span><br><span class="line">ios::out|ios:: binary 表示以二进制写方式打开文件</span><br><span class="line">ios::in|ios::out|ios::binary 表示以二进制读/写方式打开文件</span><br></pre></td></tr></table></figure>
<ul>
<li>如果未指明以二进制方式打开文件，则默认是以文本方式打开文件。
<ul>
<li>对于 ifstream 流， mode 参数的默认值为 ios::in，</li>
<li>对于 ofstream 流，mode 的默 认值为 ios::out|ios::trunc,</li>
<li>对于 fstream 流， mode 的默认值为 ios::int|ios::out|ios::app</li>
</ul>
</li>
<li>也可以通过，构造函数打开文件。</li>
<li>出错处理是通过，对类对象进行判断的。若文件打开成功，返回 1，否则返回 0</li>
</ul>
<h5 id="文件的关闭"><a class="markdownIt-Anchor" href="#文件的关闭"></a> 文件的关闭</h5>
<ul>
<li>在文件操作结束（即读、写完毕）时应及时调用成员函数 close()来关闭文件。该函数比较简单，没有参数和返回值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;xxx.txt&quot;</span>,ios::in)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!ifs)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;open error1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">if</span>(ifs&gt;&gt;buf)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;yyy.txt&quot;</span>,ios::out|ios::app)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!ofs)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;open error2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">ofs&lt;&lt;<span class="string">&quot;abcefldkj&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;zzz.txt&quot;</span>,ios::in|ios::out|ios::app)</span></span>;<span class="comment">//app 有创建文件的功能 trunc 也有，但是清空</span></span><br><span class="line"><span class="keyword">if</span>(!fs)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;open error3&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">fs&lt;&lt;<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">fs.seekg(<span class="number">0</span>,ios::beg);</span><br><span class="line">fs&gt;&gt;buf;</span><br><span class="line"><span class="keyword">if</span>(fs)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="流文件状态与判断"><a class="markdownIt-Anchor" href="#流文件状态与判断"></a> 流文件状态与判断</h4>
<ul>
<li>系统为了标识当前文件操作的状态，提供了标识位和检查标识位的函数。</li>
<li>标识位：<code>ios_base.h</code></li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eof()</td>
<td>如果读文件到达文件末尾，返回 true。</td>
</tr>
<tr>
<td>bad()</td>
<td>如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</td>
</tr>
<tr>
<td>fail()</td>
<td>除了与 bad() 同样的情况下会返回 true 以外，加上格式错误时也返回 true ，例如当想要读入一个整数，而获得了一个字母的时候。或是遇到 eof。</td>
</tr>
<tr>
<td>good()</td>
<td>这是最通用的：如果调用以上任何一个函数返回 true 的话，此函数返回 false 。</td>
</tr>
<tr>
<td>clear()</td>
<td>标识位一旦被置位，这些标志将不会被改变，要想重置以上成员函数所检查的状态标志，你可以使用成员函数 clear()，没有参数。比如:通过函数移动文件指针，并不会使 eofbit</td>
</tr>
<tr>
<td>自动重置。</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="文件的读写操作"><a class="markdownIt-Anchor" href="#文件的读写操作"></a> 文件的读写操作</h4>
<ul>
<li>在打开文件后就可以对文件进行读写操作了。从一个文件中读出数据，可以使用文件流类的 get、getline、read 成员函数以及运算符“&gt;&gt;”；</li>
<li>而向一个文件写入数据，可以使用其 put、write 函数以及插入符“&lt;&lt;”，如下表所示：</li>
</ul>
<h5 id="流状态的查询和控制"><a class="markdownIt-Anchor" href="#流状态的查询和控制"></a> 流状态的查询和控制</h5>
<ul>
<li>可以如下管理输入操作</li>
<li>这个循环不断读入 cin，直到到达文件结束符或者发生不可恢复的读取错误为止。循环条件使用了逗号操作符。回顾逗号操作符的求解过程：首先计算它的每一个操作数，然后返回最右边操作数作为整个操作的结果。因此，循环条件只读入 cin 而忽略了其结果。该条件的结果是 !cin.eof() 的值。如果 cin 到达文件结束符，条件则为假，退出循环。如果 cin没有到达文件结束符，则不管在读取时是否发生了其他可能遇到的错误，都进入循环在循环中，首先检查流是否已破坏。如果是的放，抛出异常并退出循环。如果输入无效，则输出警告并清除 failbit 状态。在本例中，执行 continue 语句,回到 while 的开头，读入另一个值 ival。如果没有出现任何错误，那么循环体中余下的部分则可以很安全地使用ival</li>
</ul>
<h5 id="读写文件本文件"><a class="markdownIt-Anchor" href="#读写文件本文件"></a> 读写文件本文件</h5>
<ul>
<li>读出：
<ul>
<li>operator&gt;&gt;</li>
<li>int get();</li>
<li>istream&amp; get(int);</li>
<li>istream &amp; get(char*,int n, char deli ) istream&amp; getline(char * ,int n);</li>
</ul>
</li>
<li>写入:
<ul>
<li>operator&lt;&lt;</li>
<li>osream put(int)</li>
</ul>
</li>
</ul>
<h5 id="读写二进制文件"><a class="markdownIt-Anchor" href="#读写二进制文件"></a> 读写二进制文件</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * buffer,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(<span class="keyword">char</span> * buff, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="随机读写函数"><a class="markdownIt-Anchor" href="#随机读写函数"></a> 随机读写函数</h5>
<ul>
<li>与文件指针相关的函数如下：</li>
</ul>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>tellg();</td>
<td>返回当前指针位置 //输入流操作</td>
</tr>
<tr>
<td>seekg(绝对位置);</td>
<td>绝对移动，</td>
</tr>
<tr>
<td>seekg(相对位置,参照位置);</td>
<td>相对操作</td>
</tr>
<tr>
<td>seekp(绝对位置);</td>
<td>绝对移动， //输出流操作</td>
</tr>
<tr>
<td>seekp(相对位置,参照位置);</td>
<td>相对操作</td>
</tr>
<tr>
<td>tellp();</td>
<td>返回当前指针位置</td>
</tr>
</tbody>
</table>
<ul>
<li>用于输入的函数。p 代表 put 的意思，用于输出函数。如果是既可输入又可输出的文件，则任意使用。</li>
</ul>
<table>
<thead>
<tr>
<th>参照位置成员</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ios::beg = 0</td>
<td>相对于文件头</td>
</tr>
<tr>
<td>ios::cur = 1</td>
<td>相对于当前位置</td>
</tr>
<tr>
<td>ios::end = 2</td>
<td>相对于文件尾</td>
</tr>
</tbody>
</table>
<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">infile.seekg(<span class="number">100</span>); <span class="comment">//输入文件中的指针向前移到 100 个字节的位置</span></span><br><span class="line">infile.seekg(<span class="number">-50</span>,ios::cur); <span class="comment">//输入文件中的指针从当前位置后移 50 个字节</span></span><br><span class="line">outfile.seekp(<span class="number">-75</span>,iso::end); <span class="comment">//输出文件中指针从文件尾后移 50 个字节</span></span><br></pre></td></tr></table></figure>
<h2 id="异常exception"><a class="markdownIt-Anchor" href="#异常exception"></a> 异常(Exception)</h2>
<ul>
<li>
<p>c 语言中错误的处理，通常采用返回值的方式或是置位全局变量的方式。这就存在两个问题。如果返回值正是我们需要的数据，且返回数据同出错数据容错差不高。全局变量，在多线程中易引发竞争。而且，当错误发生时，上级函数要出错处理，层层上报，造成过多的出错处理代码，且传递的效率低下。为此 c++提供了异常。</p>
</li>
<li>
<p>数组的异常捕获</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc e)&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;e.what&lt;&lt;<span class="string">&quot;some err&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)<span class="keyword">int</span>[<span class="number">100</span>];<span class="comment">// 不抛出异常</span></span><br><span class="line"><span class="keyword">if</span>(pi==<span class="literal">NULL</span>)<span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="异常语法"><a class="markdownIt-Anchor" href="#异常语法"></a> 异常语法</h3>
<ul>
<li>
<p>异常使用</p>
<ol>
<li>把可能发生异常的语句放在 try 语句声当中。try 原有语句的执行流程。</li>
<li>若未发生异常，catch 子语句并不起作用。程序会流转到 catch 子句的后面执行。</li>
<li>若 try 块中发生异常，则通过 throw 抛出异常。throw 抛出异常后，程序立即离开本函数，转到上一级函数。所以 triangle 函数中的 return 语句不会执行。</li>
<li>throw 抛出数据，类型不限。既可以是基本数据类型，也可以是构造数据类型。</li>
<li>程序流转到 main 函数以后，try 语句块中 抛出进行匹配。匹配成功，执行 catch 语句，catch 语句执行完毕后。继续执行后面的语句。如无匹配，系统调用 terminate 终止程序。</li>
</ol>
</li>
<li>
<p>语法格式</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">被检查的语句</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常信息类型 [变量名])&#123;</span><br><span class="line">进行异常处理的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>语法要点：
<ol>
<li>被检语句必须放在 try 块中，否则不起作用。</li>
<li>try catch 中花括号不可省。</li>
<li>一个 try-catch 结构中，只能有一个 try 块，catch 块却可以有多个。以便与不同的类型信息匹配。</li>
<li>throw 抛出的类型，既可以是系统预定义的标准类型也可以是自定义类型。从抛出到catch 是一次复制拷贝的过程。如果有自定义类型，要考虑自定义类型的拷贝问题。</li>
<li>如果 catch 语句没有匹配异常类型信息，就可以用(…)表示可以捕获任何异常类型的信息。</li>
<li>try-catch 结构可以与 throw 在同一个函中数中，也可以不在同一个函数中，throw 抛出异常后，先在本函数内寻找与之匹配的 catch 块，找不到与之匹配的就转到上一层，如果上一层也没有，则转到更上一层的 catch 块。如果最终找不到与之匹配的 catch 块，系统则会调有生个系统函数，terminate,使程序终止。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">triangle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> area;<span class="keyword">double</span> s = (x+y+z)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x+y&gt;z &amp;&amp; y+z&gt;x &amp;&amp; x+z &gt;y)</span><br><span class="line">area = <span class="built_in">sqrt</span>(s*(s-x)*(s-y)*(s-z));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">4</span>; <span class="comment">//throw 数据为任意类型</span></span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b,c;<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a&gt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>&amp;&amp;c&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;triangle(a,b,c)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">int</span>)  <span class="comment">// 接收异常类型，和抛处类型要一致，否则会掉入C++默认的异常处理。</span></span><br><span class="line">&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;构不成三角形&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出类型声明"><a class="markdownIt-Anchor" href="#抛出类型声明"></a> 抛出类型声明</h3>
<ol>
<li>为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型。例如：<code>void func() throw (A, B, C , D);</code>这个函数 func（）能够且只能抛出类型 A B C D及其子类型的异常。</li>
<li>如果在函数声明中没有包含异常接口声明，则函数可以抛掷任何类型的异常，例如：<code>void func();</code></li>
<li>一个不抛掷任何类型异常的函数可以声明为：<code>void func() throw();</code></li>
<li>如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected 函数会被 调用，该函数默认行为调用 terminate 函数中止程序。</li>
</ol>
<h3 id="栈自旋"><a class="markdownIt-Anchor" href="#栈自旋"></a> 栈自旋</h3>
<ul>
<li>异常被抛出后，从进入 try 块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋(unwinding)。而堆上的空间，则会泄漏。</li>
</ul>
<h2 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h2>
<h2 id="c11"><a class="markdownIt-Anchor" href="#c11"></a> C11</h2>
<h2 id="boost"><a class="markdownIt-Anchor" href="#boost"></a> Boost</h2>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/13/yaml%E6%96%87%E4%BB%B6/"><i class="fa fa-chevron-left">  </i><span>yaml文件</span></a></div><div class="next-post pull-right"><a href="/2020/07/07/wsl2/"><span>wsl2</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'AdfkiqY89QUSUWbDY9xJuCh0-gzGzoHsz',
  appKey:'2cEvHcqEWsyoKwy4AUL3kPGh',
  placeholder:'劈个叉吧',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'100',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 By hero576</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>