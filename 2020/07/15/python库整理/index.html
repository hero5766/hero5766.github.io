<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python库整理"><meta name="keywords" content="python"><meta name="author" content="hero576"><meta name="copyright" content="hero576"><title>python库整理 | void land space</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5ff8fca367285c16c6dd5c16ca2ccc1b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.0.2'
} </script><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="void land space" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text"> 系统库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#os"><span class="toc-number">1.1.</span> <span class="toc-text"> os</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys"><span class="toc-number">1.2.</span> <span class="toc-text"> sys</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time"><span class="toc-number">1.3.</span> <span class="toc-text"> time</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#datetime"><span class="toc-number">1.4.</span> <span class="toc-text"> datetime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection"><span class="toc-number">1.5.</span> <span class="toc-text"> collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#counter"><span class="toc-number">1.5.1.</span> <span class="toc-text"> Counter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque"><span class="toc-number">1.5.2.</span> <span class="toc-text"> deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defaultdict"><span class="toc-number">1.5.3.</span> <span class="toc-text"> defaultdict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#namedtuple"><span class="toc-number">1.5.4.</span> <span class="toc-text"> namedtuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ordereddict"><span class="toc-number">1.5.5.</span> <span class="toc-text"> OrderedDict</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heapq"><span class="toc-number">1.6.</span> <span class="toc-text"> heapq</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#itertools"><span class="toc-number">1.7.</span> <span class="toc-text"> itertools</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.</span> <span class="toc-text"> 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tqdm"><span class="toc-number">2.1.</span> <span class="toc-text"> tqdm[1]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket"><span class="toc-number">2.2.</span> <span class="toc-text"> websocket</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/haimianbaobao.jpg"></div><div class="author-info__name text-center">hero576</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">83</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">void land space</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">python库整理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/programme/"> programme</a></div><div class="article-container" id="post-content"><blockquote>
<p>整理一些python遇到的库</p>
</blockquote>
<a id="more"></a>
<h1 id="系统库"><a class="markdownIt-Anchor" href="#系统库"></a> 系统库</h1>
<h2 id="os"><a class="markdownIt-Anchor" href="#os"></a> os</h2>
<ul>
<li>引入：<code>import os</code></li>
<li>函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>os.access(path, mode)</td>
<td>检验权限模式</td>
<td></td>
</tr>
<tr>
<td>os.chdir(path)</td>
<td>改变当前工作目录</td>
<td></td>
</tr>
<tr>
<td>os.chflags(path, flags)</td>
<td>设置路径的标记为数字标记。</td>
<td></td>
</tr>
<tr>
<td>os.chmod(path, mode)</td>
<td>更改权限</td>
<td></td>
</tr>
<tr>
<td>os.chown(path, uid, gid)</td>
<td>更改文件所有者</td>
<td></td>
</tr>
<tr>
<td>os.chroot(path)</td>
<td>改变当前进程的根目录</td>
<td></td>
</tr>
<tr>
<td>os.close(fd)</td>
<td>关闭文件描述符 fd</td>
<td></td>
</tr>
<tr>
<td>os.closerange(fd_low, fd_high)</td>
<td>关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
<td></td>
</tr>
<tr>
<td>os.dup(fd)</td>
<td>复制文件描述符 fd</td>
<td></td>
</tr>
<tr>
<td>os.dup2(fd, fd2)</td>
<td>将一个文件描述符 fd 复制到另一个 fd2</td>
<td></td>
</tr>
<tr>
<td>os.fchdir(fd)</td>
<td>通过文件描述符改变当前工作目录</td>
<td></td>
</tr>
<tr>
<td>os.fchmod(fd, mode)</td>
<td>改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
<td></td>
</tr>
<tr>
<td>os.fchown(fd, uid, gid)</td>
<td>修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
<td></td>
</tr>
<tr>
<td>os.fdatasync(fd)</td>
<td>强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
<td></td>
</tr>
<tr>
<td>os.fdopen(fd[, mode[, bufsize]])</td>
<td>通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
<td></td>
</tr>
<tr>
<td>os.fpathconf(fd, name)</td>
<td>返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
<td></td>
</tr>
<tr>
<td>os.fstat(fd)</td>
<td>返回文件描述符fd的状态，像stat()。</td>
<td></td>
</tr>
<tr>
<td>os.fstatvfs(fd)</td>
<td>返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td>
<td></td>
</tr>
<tr>
<td>os.fsync(fd)</td>
<td>强制将文件描述符为fd的文件写入硬盘。</td>
<td></td>
</tr>
<tr>
<td>os.ftruncate(fd, length)</td>
<td>裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
<td></td>
</tr>
<tr>
<td>os.getcwd()</td>
<td>返回当前工作目录</td>
<td></td>
</tr>
<tr>
<td>os.getcwdu()</td>
<td>返回一个当前工作目录的Unicode对象</td>
<td></td>
</tr>
<tr>
<td>os.isatty(fd)</td>
<td>如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
<td></td>
</tr>
<tr>
<td>os.lchflags(path, flags)</td>
<td>设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
<td></td>
</tr>
<tr>
<td>os.lchmod(path, mode)</td>
<td>修改连接文件权限</td>
<td></td>
</tr>
<tr>
<td>os.lchown(path, uid, gid)</td>
<td>更改文件所有者，类似 chown，但是不追踪链接。</td>
<td></td>
</tr>
<tr>
<td>os.link(src, dst)</td>
<td>创建硬链接，名为参数 dst，指向参数 src</td>
<td></td>
</tr>
<tr>
<td>os.listdir(path)</td>
<td>返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
<td></td>
</tr>
<tr>
<td>os.lseek(fd, pos, how)</td>
<td>设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
<td></td>
</tr>
<tr>
<td>os.lstat(path)</td>
<td>像stat(),但是没有软链接</td>
<td></td>
</tr>
<tr>
<td>os.major(device)</td>
<td>从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
<td></td>
</tr>
<tr>
<td>os.makedev(major, minor)</td>
<td>以major和minor设备号组成一个原始设备号</td>
<td></td>
</tr>
<tr>
<td>os.makedirs(path[, mode])</td>
<td>递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
<td></td>
</tr>
<tr>
<td>os.minor(device)</td>
<td>从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
<td></td>
</tr>
<tr>
<td>os.mkdir(path[, mode])</td>
<td>以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
<td></td>
</tr>
<tr>
<td>os.mkfifo(path[, mode])</td>
<td>创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
<td></td>
</tr>
<tr>
<td>os.mknod(filename[, mode=0600, device])</td>
<td>创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://os.name">os.name</a></td>
<td>判断现在正在实用的平台，Windows 返回 ‘nt‘; Linux 返回posix</td>
<td></td>
</tr>
<tr>
<td>os.open(file, flags[, mode])</td>
<td>打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
<td></td>
</tr>
<tr>
<td>os.openpty()</td>
<td>打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
<td></td>
</tr>
<tr>
<td>os.pathconf(path, name)</td>
<td>返回相关文件的系统配置信息。</td>
<td></td>
</tr>
<tr>
<td>os.pipe()</td>
<td>创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
<td></td>
</tr>
<tr>
<td>os.popen(command[, mode[, bufsize]])</td>
<td>从一个 command 打开一个管道，从 version 2.6起: 所有的popen*()函数已抛弃. 使用subprocess模块</td>
<td></td>
</tr>
<tr>
<td>os.read(fd, n)</td>
<td>从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
<td></td>
</tr>
<tr>
<td>os.readlink(path)</td>
<td>返回软链接所指向的文件</td>
<td></td>
</tr>
<tr>
<td>os.remove(path)</td>
<td>删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
<td></td>
</tr>
<tr>
<td>os.removedirs(path)</td>
<td>递归删除目录。</td>
<td></td>
</tr>
<tr>
<td>os.rename(src, dst)</td>
<td>重命名文件或目录，从 src 到 dst</td>
<td></td>
</tr>
<tr>
<td>os.renames(old, new)</td>
<td>递归地对目录进行更名，也可以对文件进行更名。</td>
<td></td>
</tr>
<tr>
<td>os.rmdir(path)</td>
<td>删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
<td></td>
</tr>
<tr>
<td>os.stat(path)</td>
<td>获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
<td></td>
</tr>
<tr>
<td>os.stat_float_times([newvalue])</td>
<td>决定stat_result是否以float对象显示时间戳</td>
<td></td>
</tr>
<tr>
<td>os.statvfs(path)</td>
<td>获取指定路径的文件系统统计信息</td>
<td></td>
</tr>
<tr>
<td>os.symlink(src, dst)</td>
<td>创建一个软链接</td>
<td></td>
</tr>
<tr>
<td>os.system()</td>
<td>执行shell命令</td>
<td><code>var=123;os.environ[‘var‘]=str(var) //注意此处[]内得是 “字符串”;</code><br><code>os.system('echo $var')</code></td>
</tr>
<tr>
<td>os.tcgetpgrp(fd)</td>
<td>返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
<td></td>
</tr>
<tr>
<td>os.tcsetpgrp(fd, pg)</td>
<td>设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
<td></td>
</tr>
<tr>
<td>os.tempnam([dir[, prefix]])</td>
<td>Python3 中已删除。返回唯一的路径名用于创建临时文件。</td>
<td></td>
</tr>
<tr>
<td>os.tmpfile()</td>
<td>Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
<td></td>
</tr>
<tr>
<td>os.tmpnam()</td>
<td>Python3 中已删除。为创建一个临时文件返回一个唯一的路径</td>
<td></td>
</tr>
<tr>
<td>os.ttyname(fd)</td>
<td>返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
<td></td>
</tr>
<tr>
<td>os.unlink(path)</td>
<td>删除文件路径</td>
<td></td>
</tr>
<tr>
<td>os.utime(path, times)</td>
<td>返回指定的path文件的访问和修改的时间。</td>
<td></td>
</tr>
<tr>
<td>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</td>
<td>输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
<td></td>
</tr>
<tr>
<td>os.write(fd, str)</td>
<td>写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
<td></td>
</tr>
<tr>
<td>os.path 模块</td>
<td>获取文件的属性信息。</td>
<td></td>
</tr>
<tr>
<td>os.pardir()</td>
<td>获取当前目录的父目录，以字符串形式显示目录名。</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>os.path 模块</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>os.path.abspath(path)</td>
<td>返回绝对路径</td>
<td></td>
</tr>
<tr>
<td>os.path.basename(path)</td>
<td>返回文件名</td>
<td></td>
</tr>
<tr>
<td>os.path.commonprefix(list)</td>
<td>返回list(多个路径)中，所有path共有的最长的路径</td>
<td></td>
</tr>
<tr>
<td>os.path.dirname(path)</td>
<td>返回文件路径</td>
<td></td>
</tr>
<tr>
<td>os.path.exists(path)</td>
<td>路径存在则返回True,路径损坏返回False</td>
<td></td>
</tr>
<tr>
<td>os.path.lexists	路径存在则返回True,路径损坏也返回True</td>
<td></td>
<td></td>
</tr>
<tr>
<td>os.path.expanduser(path)</td>
<td>把path中包含的&quot;<sub>&quot;和&quot;</sub>user&quot;转换成用户目录</td>
<td></td>
</tr>
<tr>
<td>os.path.expandvars(path)</td>
<td>根据环境变量的值替换path中包含的<code>$name</code>和<code>$&#123;name&#125;</code></td>
<td></td>
</tr>
<tr>
<td>os.path.getatime(path)</td>
<td>返回最近访问时间（浮点型秒数）</td>
<td></td>
</tr>
<tr>
<td>os.path.getmtime(path)</td>
<td>返回最近文件修改时间</td>
<td></td>
</tr>
<tr>
<td>os.path.getctime(path)</td>
<td>返回文件 path 创建时间</td>
<td></td>
</tr>
<tr>
<td>os.path.getsize(path)</td>
<td>返回文件大小，如果文件不存在就返回错误</td>
<td></td>
</tr>
<tr>
<td>os.path.isabs(path)</td>
<td>判断是否为绝对路径</td>
<td></td>
</tr>
<tr>
<td>os.path.isfile(path)</td>
<td>判断路径是否为文件</td>
<td></td>
</tr>
<tr>
<td>os.path.isdir(path)</td>
<td>判断路径是否为目录</td>
<td></td>
</tr>
<tr>
<td>os.path.islink(path)</td>
<td>判断路径是否为链接</td>
<td></td>
</tr>
<tr>
<td>os.path.ismount(path)</td>
<td>判断路径是否为挂载点</td>
<td></td>
</tr>
<tr>
<td>os.path.join(path1[, path2[, …]])</td>
<td>把目录和文件名合成一个路径</td>
<td></td>
</tr>
<tr>
<td>os.path.normcase(path)</td>
<td>转换path的大小写和斜杠</td>
<td></td>
</tr>
<tr>
<td>os.path.normpath(path)</td>
<td>规范path字符串形式</td>
<td></td>
</tr>
<tr>
<td>os.path.realpath(path)</td>
<td>返回path的真实路径</td>
<td></td>
</tr>
<tr>
<td>os.path.relpath(path[, start])</td>
<td>从start开始计算相对路径</td>
<td></td>
</tr>
<tr>
<td>os.path.samefile(path1, path2)</td>
<td>判断目录或文件是否相同</td>
<td></td>
</tr>
<tr>
<td>os.path.sameopenfile(fp1, fp2)</td>
<td>判断fp1和fp2是否指向同一文件</td>
<td></td>
</tr>
<tr>
<td>os.path.samestat(stat1, stat2)</td>
<td>判断stat tuple stat1和stat2是否指向同一个文件</td>
<td></td>
</tr>
<tr>
<td>os.path.split(path)</td>
<td>把路径分割成 dirname 和 basename，返回一个元组</td>
<td></td>
</tr>
<tr>
<td>os.path.splitdrive(path)</td>
<td>一般用在 windows 下，返回驱动器名和路径组成的元组</td>
<td></td>
</tr>
<tr>
<td>os.path.splitext(path)</td>
<td>分割路径中的文件名与拓展名</td>
<td></td>
</tr>
<tr>
<td>os.path.splitunc(path)</td>
<td>把路径分割为加载点与文件</td>
<td></td>
</tr>
<tr>
<td>os.path.walk(path, visit, arg)</td>
<td>遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数</td>
<td></td>
</tr>
<tr>
<td>os.path.supports_unicode_filenames</td>
<td>设置是否支持unicode路径名</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="sys"><a class="markdownIt-Anchor" href="#sys"></a> sys</h2>
<ul>
<li>引入：<code>import sys</code></li>
<li>函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>sys.argv</td>
<td>接收命令行参数，生成一个List，第一个元素是程序本身路径</td>
<td></td>
</tr>
<tr>
<td>sys.modules</td>
<td>返回系统导入的模块字段，key是模块名，value是模块</td>
<td></td>
</tr>
<tr>
<td>sys.modules.keys()</td>
<td>返回所有已经导入的模块列表</td>
<td></td>
</tr>
<tr>
<td>sys.modules.values()</td>
<td>返回所有已经导入的模块</td>
<td></td>
</tr>
<tr>
<td>sys.exc_info()</td>
<td>获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息</td>
<td></td>
</tr>
<tr>
<td>sys.exit(n)</td>
<td>退出程序，正常退出时exit(0)</td>
<td></td>
</tr>
<tr>
<td>sys.hexversion</td>
<td>获取Python解释程序的版本值，16进制格式如：0x020403F0</td>
<td></td>
</tr>
<tr>
<td>sys.version</td>
<td>获取Python解释程序的版本信息</td>
<td></td>
</tr>
<tr>
<td>sys.maxint</td>
<td>最大的Int值</td>
<td></td>
</tr>
<tr>
<td>sys.maxunicode</td>
<td>最大的Unicode值</td>
<td></td>
</tr>
<tr>
<td>sys.modules</td>
<td>返回系统导入的模块字段，key是模块名，value是模块</td>
<td></td>
</tr>
<tr>
<td>sys.path</td>
<td>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</td>
<td></td>
</tr>
<tr>
<td>sys.platform</td>
<td>返回操作系统平台名称</td>
<td></td>
</tr>
<tr>
<td>sys.stdout</td>
<td>标准输出</td>
<td>sys.stdout.write(‘please:’)</td>
</tr>
<tr>
<td>sys.stdin</td>
<td>标准输入</td>
<td>val = sys.stdin.readline()[:-1]</td>
</tr>
<tr>
<td>sys.stderr</td>
<td>错误输出</td>
<td></td>
</tr>
<tr>
<td>sys.exc_clear()</td>
<td>用来清除当前线程所出现的当前的或最近的错误信息</td>
<td></td>
</tr>
<tr>
<td>sys.exec_prefix</td>
<td>返回平台独立的python文件安装的位置</td>
<td></td>
</tr>
<tr>
<td>sys.byteorder</td>
<td>本地字节规则的指示器，big-endian平台的值是’big’,little-endian平台的值是’little’</td>
<td></td>
</tr>
<tr>
<td>sys.copyright</td>
<td>记录python版权相关的东西</td>
<td></td>
</tr>
<tr>
<td>sys.api_version</td>
<td>解释器的C的API版本</td>
<td></td>
</tr>
<tr>
<td>sys.version_info</td>
<td>‘final’表示最终,也有’candidate’表示候选，serial表示版本级别，是否有后继的发行</td>
<td></td>
</tr>
<tr>
<td>sys.displayhook(value)</td>
<td>如果value非空，这个函数会把他输出到sys.stdout，并且将他保存进<code>__builtin__._.</code>指在python的交互式解释器里，’_’ 代表上次你输入得到的结果，hook是钩子的意思，将上次的结果钩过来</td>
<td></td>
</tr>
<tr>
<td>sys.getdefaultencoding()</td>
<td>返回当前你所用的默认的字符编码格式</td>
<td></td>
</tr>
<tr>
<td>sys.getfilesystemencoding()</td>
<td>返回将Unicode文件名转换成系统文件名的编码的名字</td>
<td></td>
</tr>
<tr>
<td>sys.setdefaultencoding(name)</td>
<td>用来设置当前默认的字符编码，如果name和任何一个可用的编码都不匹配，抛出 LookupError，这个函数只会被site模块的sitecustomize使用，一旦别site模块使用了，他会从sys模块移除</td>
<td></td>
</tr>
<tr>
<td>sys.builtin_module_names</td>
<td>Python解释器导入的模块列表</td>
<td></td>
</tr>
<tr>
<td>sys.executable</td>
<td>Python解释程序路径</td>
<td></td>
</tr>
<tr>
<td>sys.getwindowsversion()</td>
<td>获取Windows的版本</td>
<td></td>
</tr>
<tr>
<td>sys.copyright</td>
<td>记录python版权相关的东西</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="time"><a class="markdownIt-Anchor" href="#time"></a> time</h2>
<h2 id="datetime"><a class="markdownIt-Anchor" href="#datetime"></a> datetime</h2>
<h2 id="collection"><a class="markdownIt-Anchor" href="#collection"></a> collection</h2>
<ul>
<li>
<p>Python拥有一些内置的数据类型，比如str, int, list, tuple, dict等， collections模块在这些内置数据类型的基础上，提供了许多有用的集合类。<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47f66ff4ab7b">更多详细内容</a></p>
<ol>
<li>namedtuple(): 生成可以使用名字来访问元素内容的tuple子类</li>
<li>deque: 双端队列，可以快速的从另外一侧追加和推出对象</li>
<li>Counter: 计数器，主要用来计数</li>
<li>OrderedDict: 有序字典</li>
<li>defaultdict: 带有默认值的字典</li>
</ol>
</li>
<li>
<p>引入：<code>from collection import *</code></p>
</li>
</ul>
<h3 id="counter"><a class="markdownIt-Anchor" href="#counter"></a> Counter</h3>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = Counter()<span class="comment">#一个新的，空的counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter()</span><br><span class="line">c = Counter(<span class="string">&quot;gallahad&quot;</span>)<span class="comment">#从可迭代的字符串初始化counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">c = Counter(&#123;<span class="string">&#x27;red&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;blue&#x27;</span>:<span class="number">2</span>&#125;)<span class="comment">#从映射初始化counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">&#x27;red&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;blue&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">c = Counter(cats = <span class="number">4</span>,dogs = <span class="number">8</span>)<span class="comment">#从args初始化counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">&#x27;dogs&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;cats&#x27;</span>: <span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter([<span class="string">&#x27;eggs&#x27;</span>,<span class="string">&#x27;ham&#x27;</span>])</span><br><span class="line"><span class="comment"># Counter对象类似于字典，如果某个项缺失，会返回0，而不是报出KeyError；</span></span><br><span class="line">c[<span class="string">&#x27;bacon&#x27;</span>]<span class="comment">#没有&#x27;bacon&#x27; 返回0</span></span><br><span class="line">c[<span class="string">&#x27;eggs&#x27;</span>]<span class="comment">#有&#x27;eggs&#x27; 返回1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除：将一个元素的数目设置为0，并不能将它从counter中删除，使用del可以将这个元素删除；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Counter(&#123;<span class="string">&#x27;eggs&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;ham&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">c[<span class="string">&#x27;eggs&#x27;</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">&#x27;ham&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;eggs&#x27;</span>: <span class="number">0</span>&#125;)<span class="comment">#&#x27;eggs&#x27;依然存在</span></span><br><span class="line"><span class="keyword">del</span> c[<span class="string">&#x27;eggs&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">&#x27;ham&#x27;</span>: <span class="number">1</span>&#125;)<span class="comment">#&#x27;eggs&#x27;不存在  </span></span><br></pre></td></tr></table></figure>
<ul>
<li>Counter对象支持以下三个字典不支持的方法</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>element()</td>
<td>返回一个迭代器，每个元素重复的次数为它的数目，顺序是任意的顺序，如果一个元素的数目少于1，那么elements()就会忽略它；</td>
<td></td>
</tr>
<tr>
<td>most_common()</td>
<td>返回一个列表，包含counter中n个最大数目的元素，如果忽略n或者为None，most_common()将会返回counter中的所有元素，元素有着相同数目的将会以任意顺序排列；</td>
<td></td>
</tr>
<tr>
<td>subtract()</td>
<td>从一个可迭代对象中或者另一个映射（或counter）中，元素相减，类似于dict.update()，但是subtracts 数目而不是替换它们，输入和输出都有可能为0或者为负；</td>
<td></td>
</tr>
<tr>
<td>update()</td>
<td>从一个可迭代对象中或者另一个映射（或counter）中所有元素相加，类似于dict.update，是数目相加而非替换它们，另外，可迭代对象是一个元素序列，而非(key,value)对构成的序列；</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># element</span><br><span class="line">c &#x3D; Counter(a&#x3D;2,b&#x3D;4,c&#x3D;0,d&#x3D;-2,e &#x3D; 1)</span><br><span class="line">list(c.elements())</span><br><span class="line">&gt;&gt;&gt; [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;e&#39;]</span><br><span class="line"># most_common</span><br><span class="line">Counter(&#39;abracadabra&#39;).most_common(3)</span><br><span class="line">&gt;&gt;&gt; [(&#39;a&#39;, 5), (&#39;r&#39;, 2), (&#39;b&#39;, 2)]</span><br><span class="line"># subtract</span><br><span class="line">c &#x3D; Counter(a&#x3D;4,b&#x3D;2,c&#x3D;0,d&#x3D;-2);d &#x3D; Counter(a&#x3D;1,b&#x3D;2,c&#x3D;-3,d&#x3D;4);c.subtract(d);</span><br><span class="line">&gt;&gt;&gt; Counter(&#123;&#39;a&#39;: 3, &#39;c&#39;: 3, &#39;b&#39;: 0, &#39;d&#39;: -6&#125;)</span><br><span class="line"># update</span><br><span class="line">c &#x3D; Counter(a&#x3D;4,b&#x3D;2,c&#x3D;0,d&#x3D;-2);d &#x3D; Counter(a&#x3D;1,b&#x3D;2,c&#x3D;-3,d&#x3D;4);c.subtract(d);c.update(d)</span><br><span class="line">&gt;&gt;&gt; Counter(&#123;&#39;a&#39;: 5, &#39;b&#39;: 4, &#39;d&#39;: 2, &#39;c&#39;: -3&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>其他常见操作</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>sum(c.values())</td>
<td>统计所有的数目</td>
<td>c=Counter({‘a’: 5, ‘b’: 4, ‘d’: 2, ‘c’: -3})</td>
</tr>
<tr>
<td>list©</td>
<td>列出所有唯一的元素</td>
<td>[‘a’, ‘c’, ‘b’, ‘d’]</td>
</tr>
<tr>
<td>set©</td>
<td>转换为set</td>
<td>set([‘a’, ‘c’, ‘b’, ‘d’])</td>
</tr>
<tr>
<td>dict©</td>
<td>转换为常规的dict</td>
<td>{‘a’: 5, ‘c’: -3, ‘b’: 4, ‘d’: 2}</td>
</tr>
<tr>
<td>c.items()</td>
<td>转换为(elem,cnt)对构成的列表</td>
<td>[(‘a’, 5), (‘c’, -3), (‘b’, 4), (‘d’, 2)]</td>
</tr>
<tr>
<td>c.most_common()[:-4:-1]</td>
<td>输出n个数目最小元素</td>
<td>[(‘c’, -3), (‘d’, 2), (‘b’, 4)]</td>
</tr>
<tr>
<td>c += Counter()</td>
<td>删除数目为0和为负的元素</td>
<td>Counter({‘a’: 5, ‘b’: 4, ‘d’: 2})</td>
</tr>
<tr>
<td>Counter(dict(c.items()))</td>
<td>从(elem,cnt)对构成的列表转换为counter</td>
<td>Counter({‘a’: 5, ‘b’: 4, ‘d’: 2})</td>
</tr>
<tr>
<td>c.clear()</td>
<td>清空counter</td>
<td></td>
</tr>
<tr>
<td>c = Counter(a=3,b=1,c=-2)<br>d = Counter(a=1,b=2,c=4)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>c+d</td>
<td>求和</td>
<td>Counter({‘a’: 4, ‘b’: 3, ‘c’: 2})</td>
</tr>
<tr>
<td>c-d</td>
<td>求差</td>
<td>Counter({‘a’: 2})</td>
</tr>
<tr>
<td>c &amp; d</td>
<td>求交集</td>
<td>Counter({‘a’: 1, ‘b’: 1})</td>
</tr>
<tr>
<td><code>c | d</code></td>
<td>求并集</td>
<td>Counter({‘c’: 4, ‘a’: 3, ‘b’: 2})</td>
</tr>
</tbody>
</table>
<h3 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> deque</h3>
<ul>
<li>deque是栈和队列的一种广义实现，deque是&quot;double-end queue&quot;的简称；deque支持线程安全、有效内存地以近似O(1)的性能在deque的两端插入和删除元素，尽管list也支持相似的操作，但是它主要在固定长度操作上的优化，从而在pop(0)和insert(0,v)（会改变数据的位置和大小）上有O(n)的时间复杂度。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>append(x)</td>
<td>将x添加到deque的右侧；</td>
<td></td>
</tr>
<tr>
<td>appendleft(x)</td>
<td>将x添加到deque的左侧；</td>
<td></td>
</tr>
<tr>
<td>clear()</td>
<td>将deque中的元素全部删除，最后长度为0；</td>
<td></td>
</tr>
<tr>
<td>count(x)</td>
<td>返回deque中元素等于x的个数；</td>
<td></td>
</tr>
<tr>
<td>extend(iterable)</td>
<td>将可迭代变量iterable中的元素添加至deque的右侧；</td>
<td></td>
</tr>
<tr>
<td>extendleft(iterable)</td>
<td>将变量iterable中的元素添加至deque的左侧，往左侧添加序列的顺序与可迭代变量iterable中的元素相反；</td>
<td></td>
</tr>
<tr>
<td>pop()</td>
<td>移除和返回deque中最右侧的元素，如果没有元素，将会报出IndexError；</td>
<td></td>
</tr>
<tr>
<td>popleft()</td>
<td>移除和返回deque中最左侧的元素，如果没有元素，将会报出IndexError；</td>
<td></td>
</tr>
<tr>
<td>remove(value)</td>
<td>移除第一次出现的value，如果没有找到，报出ValueError；</td>
<td></td>
</tr>
<tr>
<td>reverse()</td>
<td>反转deque中的元素，并返回None；</td>
<td></td>
</tr>
<tr>
<td>rotate(n)</td>
<td>从右侧反转n步，如果n为负数，则从左侧反转，d.rotate(1)等于d.appendleft(d.pop())；</td>
<td></td>
</tr>
<tr>
<td>maxlen</td>
<td>只读的属性，deque的最大长度，如果无解，就返回None；</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>除了以上的方法之外，deque还支持迭代、序列化、len(d)、reversed(d)、copy.copy(d)、copy.deepcopy(d)，通过in操作符进行成员测试和下标索引，索引的时间复杂度是在两端是O(1)，在中间是O(n)，为了快速获取，可以使用list代替。</p>
</li>
<li>
<p>还有更多有意思的功能，例如实现类似linux的tail的功能</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span>(<span class="params">filename,n = <span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;Return the last n lines of a file&quot;</span></span><br><span class="line">    <span class="keyword">return</span> deque(open(filename),n)</span><br><span class="line"><span class="keyword">print</span> (tail(<span class="string">&quot;temp.txt&quot;</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>使用deque维护一个序列（右侧添加元素，左侧删除元素）中窗口的平均值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moving_average</span>(<span class="params">iterable,n = <span class="number">3</span></span>):</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    d = deque(itertools.islice(it,n<span class="number">-1</span>))</span><br><span class="line">    <span class="comment"># 第一次只有两个元素，再右移的过程中，需要先删除最左端的元素，因此现在最左端加入0</span></span><br><span class="line">    d.appendleft(<span class="number">0</span>)</span><br><span class="line">    s = sum(d)</span><br><span class="line">    <span class="keyword">for</span> ele <span class="keyword">in</span> it:</span><br><span class="line">        <span class="comment"># 删除最左端的元素，再加上新元素</span></span><br><span class="line">        s += ele - d.popleft()</span><br><span class="line">        <span class="comment"># 右端添加新元素</span></span><br><span class="line">        d.append(ele)</span><br><span class="line">        <span class="keyword">yield</span> s / float(n)</span><br><span class="line">array = [<span class="number">40</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">46</span>,<span class="number">39</span>,<span class="number">44</span>]</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> moving_average(array,n=<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">print</span> (ele)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">t = deque(maxlen=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t.append(i)</span><br><span class="line">    print(t)</span><br></pre></td></tr></table></figure>
<h3 id="defaultdict"><a class="markdownIt-Anchor" href="#defaultdict"></a> defaultdict</h3>
<ul>
<li>efaultdict是内置数据类型dict的一个子类，基本功能与dict一样，只是重写了一个方法missing(key)和增加了一个可写的对象变量default_factory。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>missing(key)</td>
<td>1、如果default_factory属性为None，就报出以key作为遍历的KeyError异常；<br>2、如果default_factory不为None，就会向给定的key提供一个默认值，这个值插入到词典中，并返回；<br>3、如果调用default_factory报出异常，这个异常在传播时不会改变；<br>4、这个方法是当要求的key不存在时，dict类中的getitem()方法所调用，无论它返回或者报出什么，最终返回或报出给getitem()；<br>5、只有getitem()才能调用missing()，这意味着，如果get()起作用，如普通的词典，将会返回None作为默认值，而不是使用default_factory；</td>
<td></td>
</tr>
<tr>
<td>default_factory</td>
<td>这个属性用于missing()方法，使用构造器中的第一个参数初始化；<br>设置list会创建空的list，遇到key则将对应的value值append到列表中；<br>设置int会提供一个默认为0的计数，遇到相同的key会递增操作；<br>设置set则可以建立一个空的set</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>使用list作为default_factory，很容易将一个key-value的序列转换为一个关于list的词典；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [(<span class="string">&#x27;yellow&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;blue&#x27;</span>,<span class="number">2</span>),(<span class="string">&#x27;yellow&#x27;</span>,<span class="number">3</span>),(<span class="string">&#x27;blue&#x27;</span>,<span class="number">4</span>),(<span class="string">&#x27;red&#x27;</span>,<span class="number">5</span>)]</span><br><span class="line">d = defaultdict(list) //设置default_factory为list，append操作会将value值append这个list</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> s: d[k].append(v)</span><br><span class="line">d.items()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">&#x27;blue&#x27;</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">&#x27;red&#x27;</span>, [<span class="number">5</span>]), (<span class="string">&#x27;yellow&#x27;</span>, [<span class="number">1</span>, <span class="number">3</span>])]</span><br></pre></td></tr></table></figure>
<h3 id="namedtuple"><a class="markdownIt-Anchor" href="#namedtuple"></a> namedtuple</h3>
<ul>
<li>命名的元组，意味给元组中的每个位置赋予含义，意味着代码可读性更强，namedtuple可以在任何常规元素使用的地方使用，而且它可以通过名称来获取字段信息而不仅仅是通过位置索引。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Point = namedtuple(<span class="string">&#x27;Point&#x27;</span>,[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>],verbose = <span class="literal">True</span>)</span><br><span class="line">p = Point(<span class="number">11</span>,y = <span class="number">22</span>) <span class="comment"># 实例化一个对象，可以使用位置或者关键字</span></span><br><span class="line">p[<span class="number">0</span>] + p[<span class="number">1</span>] <span class="comment"># 通过索引访问元组中的元素</span></span><br><span class="line">x,y = p <span class="comment"># 分开，类似于常规的元组</span></span><br><span class="line">print(x,y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">p.x + p.y <span class="comment"># 通过名称访问元素</span></span><br><span class="line">p <span class="comment"># 可读的__repr__，通过name = value风格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point(x=<span class="number">11</span>, y=<span class="number">22</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>除了从tuples继承的方法之外，namedtuple还支持三种方法和一个属性</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>somenamedtuple._make()</code></td>
<td>从已有的序列或者可迭代的对象中创建一个新的对象；</td>
<td><code>t = [11,22];Point._make(t)</code></td>
</tr>
<tr>
<td><code>somenamedtuple._asdict()</code></td>
<td>返回一个OrderDict，由名称到对应值建立的映射；</td>
<td><code>p._asdict() ==&gt; OrderedDict([('x', 11), ('y', 22)])</code></td>
</tr>
<tr>
<td><code>somenamedtuple._replace()</code></td>
<td>返回一个新的namedtuple对象，用新值替换指定名称中的值；</td>
<td><code>p._replace(x = 33) ==&gt; Point(x=33, y=22)</code></td>
</tr>
<tr>
<td><code>somenamedtuple._fields</code></td>
<td>以字符串构成的元组的形式返回namedtuple中的名称，在自省或者基于一个已经存在的namedtuple中创建新的namedtuple时，非常有用；</td>
<td><code>p._fields ==&gt; ('x', 'y')</code></td>
</tr>
<tr>
<td><code>getattr()</code></td>
<td>检索存储在字符串中的名称</td>
<td><code>getattr(p,'x')==&gt;11</code></td>
</tr>
<tr>
<td><code>**操作符</code></td>
<td>将一个字典转换成namedtuple</td>
<td><code>d = &#123;'x':11,'y':22&#125;;Point(**d)</code></td>
</tr>
</tbody>
</table>
<ul>
<li>由于namedtuple也是Python中的一个类，因此在子类中，它很容易添加或者修改一些功能，如下是添加一个可计算名称和固定长度的输出格式；子类中的slots是一个空的元组，可以通过避免词典实例的创建来节约内存；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>(<span class="params">namedtuple(<span class="params"><span class="string">&#x27;Point&#x27;</span>,<span class="string">&#x27;x y&#x27;</span></span>)</span>):</span></span><br><span class="line">    __slots__ = ()</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hypot</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.x ** <span class="number">2</span> + self.y**<span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point:x = %6.3f  y = %6.3f  hypot = %6.3f&quot;</span> %(self.x,self.y,self.hypot)</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> Point(<span class="number">3</span>,<span class="number">4</span>),Point(<span class="number">14</span>,<span class="number">5</span>/<span class="number">7.</span>):</span><br><span class="line">    <span class="keyword">print</span> (p)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point:x =  <span class="number">3.000</span>  y =  <span class="number">4.000</span>  hypot =  <span class="number">5.000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point:x = <span class="number">14.000</span>  y =  <span class="number">0.714</span>  hypot = <span class="number">14.018</span></span><br></pre></td></tr></table></figure>
<h3 id="ordereddict"><a class="markdownIt-Anchor" href="#ordereddict"></a> OrderedDict</h3>
<ul>
<li>OrderedDict类似于正常的词典，只是它记住了元素插入的顺序，当在有序的词典上迭代时，返回的元素就是它们第一次添加的顺序。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>popitem(last=True)</td>
<td>返回和删除一个(key,value)对，如果last=True，就以LIFO方式执行，否则以FIFO方式执行</td>
<td></td>
</tr>
<tr>
<td>reversed()</td>
<td>反向迭代</td>
<td></td>
</tr>
<tr>
<td>==</td>
<td>相等测试，OrderedDict对象之间对顺序敏感，和其他的映射对象不敏感</td>
<td></td>
</tr>
<tr>
<td>update()</td>
<td>OrderedDict构造器和update()方法可以接受关键字变量，但是它们丢失了顺序，因为Python的函数调用机制是将一个无序的词典传入关键字变量</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>使用举例</li>
<li>创建一个有序的词典，可以记住最后插入的key的顺序，如果一个新的元素要重写已经存在的元素，那么原始的插入位置就会改变成末尾，</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LastUpdatedOrderedDict</span>(<span class="params">OrderedDict</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self,key,value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">del</span> self[key]</span><br><span class="line">        OrderedDict.__setitem__(self, key, value)</span><br><span class="line">obj = LastUpdatedOrderedDict();obj[<span class="string">&quot;apple&quot;</span>] = <span class="number">2</span>;obj[<span class="string">&quot;windows&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LastUpdatedOrderedDict([(<span class="string">&#x27;apple&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;windows&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line">obj[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LastUpdatedOrderedDict([(<span class="string">&#x27;windows&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>)])</span><br></pre></td></tr></table></figure>
<ul>
<li>一个有序的词典可以和Counter类一起使用，counter对象就可以记住元素首次出现的顺序；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrderedCounter(Counter,OrderedDict):</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;%s(%r)&quot;%(self.__class__.__name__,OrderedDict(self))</span><br><span class="line"></span><br><span class="line">    def __reduce__(self):</span><br><span class="line">        return self.__class__,(OrderedDict(self))</span><br><span class="line">#和OrderDict一起使用的Counter对象</span><br><span class="line">obj &#x3D; OrderedCounter()</span><br><span class="line">wordList &#x3D; [&quot;b&quot;,&quot;a&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;a&quot;]</span><br><span class="line">for word in wordList:</span><br><span class="line">    obj[word] +&#x3D; 1</span><br><span class="line">print (obj)</span><br><span class="line"># 普通的Counter对象</span><br><span class="line">cnt &#x3D; Counter()</span><br><span class="line">wordList &#x3D; [&quot;b&quot;,&quot;a&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;a&quot;]</span><br><span class="line">for word in wordList:</span><br><span class="line">    cnt[word] +&#x3D; 1</span><br><span class="line">print (cnt)</span><br><span class="line">&gt;&gt;&gt; OrderedCounter(OrderedDict([(&#39;b&#39;, 1), (&#39;a&#39;, 3), (&#39;c&#39;, 2)]))</span><br><span class="line">&gt;&gt;&gt; Counter(&#123;&#39;a&#39;: 3, &#39;c&#39;: 2, &#39;b&#39;: 1&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="heapq"><a class="markdownIt-Anchor" href="#heapq"></a> heapq</h2>
<ul>
<li>堆是一种特殊的树形结构，通常我们所说的堆的数据结构指的是完全二叉树，并且根节点的值小于等于该节点所有子节点的值</li>
<li>堆是一种优先队列。优先队列让你能够以任意顺序添加对象，并随时（可能是在两次添加对象之间）找出（并删除）最小的元素。相比于列表方法min，这样做的效率要高得多。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>heappush(heap,item)</code></td>
<td>往堆中插入一条新的值，构造成最小堆</td>
<td></td>
</tr>
<tr>
<td><code>heappop(heap)</code></td>
<td>从堆中弹出最小值</td>
<td></td>
</tr>
<tr>
<td><code>heapreplace(heap,item)</code></td>
<td>从堆中弹出最小值，并往堆中插入item</td>
<td></td>
</tr>
<tr>
<td><code>heappushpop(heap,item)</code></td>
<td>Python3中的heappushpop更高级</td>
<td></td>
</tr>
<tr>
<td><code>heapify(x)</code></td>
<td>以线性时间将一个列表转化为堆</td>
<td></td>
</tr>
<tr>
<td><code>merge(*iterables,key=None,reverse=False)</code></td>
<td>合并对个堆，然后输出</td>
<td></td>
</tr>
<tr>
<td><code>nlargest(n,iterable,key=None)</code></td>
<td>返回可枚举对象中的n个最大值并返回一个结果集list</td>
<td></td>
</tr>
<tr>
<td><code>nsmallest(n,iterable,key=None)</code></td>
<td>返回可枚举对象中的n个最小值并返回一个结果集list</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>创建堆：可以遍历列表，然后通过heapq.heappush()函数把值加入堆中，还可以使用heap.heapify(list)转换列表成为堆结构。</p>
</li>
<li>
<p>访问堆内容：堆创建好后，可以通过<code>heapq.heappop()</code>函数弹出堆中最小值。</p>
</li>
<li>
<p>获取堆最大或最小值：如果需要获取堆中最大或最小的范围值，则可以使用<code>heapq.nlargest()</code>或<code>heapq.nsmallest()</code>函数</p>
</li>
<li>
<p>heapq支持最大堆：<br />
|函数|说明|举例|<br />
|–|--|–|<br />
|<code>_heapify_max(list)</code>|生成最大堆||<br />
|<code>_heappop_max(heap)</code>|从堆中弹出最大值||<br />
|<code>_heapreplace_max(heap,item)</code>|从对中弹出最大值，并插入item||</p>
</li>
<li>
<p>但是heapq不支持maxpush，push数值得到的堆不是最大堆。</p>
</li>
<li>
<p>改进方法可以在数据添加负号来解决调性。</p>
</li>
</ul>
<h2 id="itertools"><a class="markdownIt-Anchor" href="#itertools"></a> itertools</h2>
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<h2 id="tqdm"><a class="markdownIt-Anchor" href="#tqdm"></a> tqdm<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<ul>
<li>进度条：<code>pip install tqdm</code></li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">bar = tqdm([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> pbar:</span><br><span class="line">    pbar.set_description(<span class="string">&quot;Processing %s&quot;</span> % char)</span><br></pre></td></tr></table></figure>
<ul>
<li>手动控制更新</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">with</span> tqdm(total=<span class="number">100</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        pbar.update(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">pbar = tqdm(total=<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    pbar.update(<span class="number">10</span>)</span><br><span class="line">pbar.close()        </span><br></pre></td></tr></table></figure>
<ul>
<li>在Shell的tqdm用法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ time find . -name <span class="string">&#x27;*.py&#x27;</span> -<span class="built_in">exec</span> cat \&#123;&#125; \; | wc -l</span><br><span class="line">857365</span><br><span class="line"> </span><br><span class="line">real    0m3.458s</span><br><span class="line">user    0m0.274s</span><br><span class="line">sys     0m3.325s</span><br><span class="line"> </span><br><span class="line">$ time find . -name <span class="string">&#x27;*.py&#x27;</span> -<span class="built_in">exec</span> cat \&#123;&#125; \; | tqdm | wc -l</span><br><span class="line">857366it [00:03, 246471.31it/s]</span><br><span class="line">857365</span><br><span class="line"> </span><br><span class="line">real    0m3.585s</span><br><span class="line">user    0m0.862s</span><br><span class="line">sys     0m3.358s</span><br><span class="line"></span><br><span class="line">$ find . -name <span class="string">&#x27;*.py&#x27;</span> -<span class="built_in">exec</span> cat \&#123;&#125; \; |</span><br><span class="line">    tqdm --unit loc --unit_scale --total 857366 &gt;&gt; /dev/null</span><br><span class="line">100%|███████████████████████████████████| 857K/857K [00:04&lt;00:00, 246Kloc/s]</span><br></pre></td></tr></table></figure>
<h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> websocket</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://websockets.readthedocs.io/en/stable/intro.html">官方文档</a></li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://langbin.blog.csdn.net/article/details/54798823">连接</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/17/Qt5/"><i class="fa fa-chevron-left">  </i><span>Qt5</span></a></div><div class="next-post pull-right"><a href="/2020/07/13/yaml%E6%96%87%E4%BB%B6/"><span>yaml文件</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'AdfkiqY89QUSUWbDY9xJuCh0-gzGzoHsz',
  appKey:'2cEvHcqEWsyoKwy4AUL3kPGh',
  placeholder:'劈个叉吧',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'100',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By hero576</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>