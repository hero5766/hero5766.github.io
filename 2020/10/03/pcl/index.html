<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="pcl"><meta name="keywords" content="robotic"><meta name="author" content="hero576"><meta name="copyright" content="hero576"><title>pcl | void land space</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5ff8fca367285c16c6dd5c16ca2ccc1b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.0.2'
} </script><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="void land space" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text"> 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.</span> <span class="toc-text"> 版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text"> 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 调用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 模块介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83"><span class="toc-number">1.4.</span> <span class="toc-text"> 环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#windows"><span class="toc-number">1.4.1.</span> <span class="toc-text"> windows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 样例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pcl%E5%BC%80%E5%8F%91"><span class="toc-number">2.</span> <span class="toc-text"> PCL开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89pcl%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text"> 编写自定义PCL类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bilateralh"><span class="toc-number">2.1.1.</span> <span class="toc-text"> bilateral.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bilateralhpp"><span class="toc-number">2.1.2.</span> <span class="toc-text"> bilateral.hpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bilateralcpp"><span class="toc-number">2.1.3.</span> <span class="toc-text"> bilateral.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmakeliststxt"><span class="toc-number">2.1.4.</span> <span class="toc-text"> CMakeLists.txt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pcl%E8%87%AA%E5%AE%9A%E4%B9%89%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text"> PCL自定义点类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pcl%E5%AE%9A%E4%B9%89%E7%9A%84%E7%82%B9%E7%B1%BB%E5%9E%8Bpointt"><span class="toc-number">2.2.1.</span> <span class="toc-text"> PCL定义的点类型PointT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9Epointt%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 新增PointT类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B8%E5%8F%AF"><span class="toc-number">2.3.</span> <span class="toc-text"> 许可</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A"><span class="toc-number">2.4.</span> <span class="toc-text"> 代码注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text"> 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 使用异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-2"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 异常处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text"> 数据操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text"> 简单使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%A4%E6%B3%A2"><span class="toc-number">4.</span> <span class="toc-text"> 滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text"> 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text"> 直通滤波器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%93%E7%B4%A0%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text"> 体素滤波器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text"> 统计滤波器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text"> 条件滤波器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%8F%90%E5%8F%96"><span class="toc-number">4.6.</span> <span class="toc-text"> 索引提取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A2"><span class="toc-number">5.</span> <span class="toc-text"> 最近邻搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kdtree"><span class="toc-number">5.1.</span> <span class="toc-text"> KDTree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#octree"><span class="toc-number">5.2.</span> <span class="toc-text"> OcTree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%89%B2"><span class="toc-number">6.</span> <span class="toc-text"> 分割</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88%E8%8E%B7%E5%8F%96%E5%B9%B3%E9%9D%A2"><span class="toc-number">6.1.</span> <span class="toc-text"> 通过数据拟合获取平面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plane-model"><span class="toc-number">6.2.</span> <span class="toc-text"> Plane model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text"> 聚类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%8B%9F%E5%90%88%E8%81%9A%E7%B1%BB"><span class="toc-number">6.3.1.</span> <span class="toc-text"> 分割拟合聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.2.</span> <span class="toc-text"> 欧几里德聚类算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%88%86%E5%89%B2"><span class="toc-number">6.3.3.</span> <span class="toc-text"> 区域分割</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E5%87%86"><span class="toc-number">7.</span> <span class="toc-text"> 配准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#icp"><span class="toc-number">7.1.</span> <span class="toc-text"> ICP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8-2"><span class="toc-number">7.1.1.</span> <span class="toc-text"> 简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.1.2.</span> <span class="toc-text"> 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%91%E9%85%8D%E5%87%86%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text"> 点云配准方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E9%85%8D%E5%87%86"><span class="toc-number">7.3.</span> <span class="toc-text"> 广义配准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#matching-features"><span class="toc-number">7.3.1.</span> <span class="toc-text"> Matching Features</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%81%87%E5%8C%B9%E9%85%8D"><span class="toc-number">7.3.2.</span> <span class="toc-text"> 虚假匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-2"><span class="toc-number">7.3.3.</span> <span class="toc-text"> 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E5%87%86api"><span class="toc-number">7.4.</span> <span class="toc-text"> 配准API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text"> 关键点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#iss"><span class="toc-number">8.1.</span> <span class="toc-text"> ISS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#harris3d"><span class="toc-number">8.2.</span> <span class="toc-text"> Harris3D</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sift"><span class="toc-number">8.3.</span> <span class="toc-text"> SIFT</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E5%AD%90"><span class="toc-number">9.</span> <span class="toc-text"> 描述子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2"><span class="toc-number">9.1.</span> <span class="toc-text"> 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">9.2.</span> <span class="toc-text"> 示例</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/haimianbaobao.jpg"></div><div class="author-info__name text-center">hero576</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">66</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">void land space</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">pcl</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/programme/"> programme</a></div><div class="article-container" id="post-content"><blockquote></blockquote>
<a id="more"></a>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://pointclouds.org/">官方网址</a></li>
<li><a target="_blank" rel="noopener" href="https://pcl.readthedocs.io/projects/tutorials/en/latest/">官方教程</a></li>
</ul>
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<ul>
<li>PCL(Point Cloud Library)收集了点云相关研究的一个开源的<code>C++</code>库，实现了大量点云相关的通用算法和高效数据结构，设计点云获取、滤波、分割、配准、检索、特征提取、识别、追踪、曲面重建、可视化等。同时具有高可移植性，在ROS、Android、Ubuntu、等主流linux平台都可以使用</li>
</ul>
<h2 id="版本"><a class="markdownIt-Anchor" href="#版本"></a> 版本</h2>
<ul>
<li></li>
</ul>
<h2 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h2>
<ul>
<li>对于3D点云处理来说，PCL完全是一个模块化的现代化C++模块库，主要基于Boost、Eigen、FLANN、VTKCUDA、OpenNI、QHull等第三方库。
<ul>
<li>OpenMP、GPU、CUDA：高性能计算技术，通过并行化实现高性能</li>
<li>FLANN：K近邻搜索操作的架构基于FLANN(Fast Library for Approximate Nearest Neighbors)，是目前技术中最快的</li>
<li>Boost：目前PCL所有的模块和算法都是通过Boost共享指针来传送数据，从而避免多次复制系统中已存在的数据需要</li>
</ul>
</li>
</ul>
<h3 id="调用流程"><a class="markdownIt-Anchor" href="#调用流程"></a> 调用流程</h3>
<ul>
<li>PCL中一个处理管道的基本接口程序：
<ul>
<li>创建处理对象，例如：过滤、特征估计、分割等</li>
<li>使用setInputCloud通过输入点云数据，处理模块</li>
<li>设置算法相关参数</li>
<li>调用计算得到输出</li>
</ul>
</li>
</ul>
<h3 id="模块介绍"><a class="markdownIt-Anchor" href="#模块介绍"></a> 模块介绍</h3>
<table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>filters</td>
<td>实现采样、去除离群点、特征提取、拟合估计等数据过滤</td>
</tr>
<tr>
<td>features</td>
<td>实现多种三维特征，如曲面发现、曲率、边界点估计、矩不变量、主曲率、PFH、FPFH特征、旋转图像、积分图像、NARF描述子、RIFT、相对标准差、数据前度的筛选等</td>
</tr>
<tr>
<td>IO</td>
<td>实现数据的输入和输出操作，例如点云数据文件PCD文件的读写</td>
</tr>
<tr>
<td>segmentation</td>
<td>实现聚类提取，如通过采样一致性方法对一系列参数模型进行模型拟合点云分割提取</td>
</tr>
<tr>
<td>surface</td>
<td>表面重建技术，如网格重建、凸包重建、移动最小二乘法平滑等</td>
</tr>
<tr>
<td>register</td>
<td>实现点云配准方法，ICP</td>
</tr>
<tr>
<td>keypoints</td>
<td>实现不同的关键点的提取方法，这可以用来作为预处理步骤，决定在哪里提取特征描述符</td>
</tr>
<tr>
<td>range</td>
<td>实现支持不同点云数据继承的范围图像</td>
</tr>
</tbody>
</table>
<h2 id="环境"><a class="markdownIt-Anchor" href="#环境"></a> 环境</h2>
<h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> windows</h3>
<table>
<thead>
<tr>
<th>组件搭建</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>kinect v1 SDK</td>
<td><a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=40278">link</a></td>
</tr>
<tr>
<td>openni</td>
<td><a target="_blank" rel="noopener" href="http://fivedots.coe.psu.ac.th/~ad/kinect/installation.html">openni1</a>，<a target="_blank" rel="noopener" href="https://structure.io/openni">openni2</a>，openni1.x的组件安装之后，我的kinect无法连接，只能使用openni2</td>
</tr>
<tr>
<td>VTK</td>
<td><a target="_blank" rel="noopener" href="https://vtk.org/download/">link</a>，不能使用太高的版本，否则visualization这个组件无法生成项目</td>
</tr>
<tr>
<td>glut</td>
<td>Glut库太老了，x64编译时一直报错，需要使用freeglut替代</td>
</tr>
</tbody>
</table>
<ul>
<li>缺失的组件在windows下都可以通过vcpkg工具进行查找和自动编译需要注意x86和x64的问题，vcpkg安装的库默认x86，如果系统是x64的：<code>vcpkg install xxx --triplet x64-windows</code></li>
</ul>
<table>
<thead>
<tr>
<th>vcpkg</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>vcpkg search</td>
<td>搜索缺失包名</td>
</tr>
<tr>
<td>vcpkg install</td>
<td>进行安装，将lib、include路径配置到cmake</td>
</tr>
<tr>
<td>下载过慢问题</td>
<td>可以单独下载文件，重命名后再放入/vcpkg/download</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>PCL安装</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>下载PCL</td>
<td><a target="_blank" rel="noopener" href="https://github.com/PointCloudLibrary/pcl">下载链接</a></td>
</tr>
<tr>
<td>cmake编译</td>
<td>必须选择BUILD_CUDA才能编译kinfu，如果使用openni2，需要在with中勾选该选项</td>
</tr>
</tbody>
</table>
<h3 id="样例数据"><a class="markdownIt-Anchor" href="#样例数据"></a> 样例数据</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/PointCloudLibrary/data">官方pcd数据下载</a></li>
</ul>
<h3 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h3>
<ul>
<li>读取pcd文件并进行展示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\pcl_viewerd.exe ism_test_cat.pcd -bc 255,255,255</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-284.png" alt="test_cat" /></p>
<h1 id="pcl开发"><a class="markdownIt-Anchor" href="#pcl开发"></a> PCL开发</h1>
<h2 id="编写自定义pcl类"><a class="markdownIt-Anchor" href="#编写自定义pcl类"></a> 编写自定义PCL类</h2>
<ul>
<li>假设我们将新的算法bilateral作为滤波库的一部分，首先在目录中建立三个文件
<ul>
<li>include/pcl/filters/bilateral.h：包含定义和声明</li>
<li>include/pcl/filters/impl/bilateral.hpp：包含模板类的具体实现</li>
<li>src/bilateral.cpp：包含具体的不同点类型的模板类实例化</li>
</ul>
</li>
<li>我们定义新的类，命名为BilateralFilter。滤波器接口规定每个算法必须有两个声明和实现可供使用，一个操作<code>PointCloud&lt;T&gt;</code>，一个操作<code>Point-Cloud2</code>。这里实现<code>PointCloud&lt;T&gt;</code></li>
</ul>
<h3 id="bilateralh"><a class="markdownIt-Anchor" href="#bilateralh"></a> bilateral.h</h3>
<ul>
<li>类的声明，实现Filter类的的各种setters和getters虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCL_FILTERS_BILATERAL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCL_FILTERS_BILATERAL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/filter.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> pcl&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> PointT&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BilateralFilter</span>:</span><span class="keyword">public</span> Filter&lt;PointT&gt;&#123;</span><br><span class="line">    <span class="keyword">using</span> Filter&lt;PointT&gt;::input_; <span class="comment">//using声明后确保不需输入完整引用即可访问父类成员变量input_</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Filter&lt;PointT&gt;::PointCloud PointCloud;<span class="comment">//方便使用PointCloud类</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> pcl::KdTree&lt;PointT&gt;::Ptr KdTreePtr;<span class="comment">//方便使用Ptr类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BilateralFilter():sigma_s_(<span class="number">0</span>),sigma_r_(<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::max())&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setSigmaS</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> sigma_s)</span></span>&#123;</span><br><span class="line">    sigma_s_=sigma_s</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> getSigmaS()&#123;</span><br><span class="line">    <span class="keyword">return</span> sigma_s_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setSigmaR</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> sigma_r)</span></span>&#123;</span><br><span class="line">    sigma_r_=sigma_r</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> getSigmaR()&#123;</span><br><span class="line">    <span class="keyword">return</span> sigma_r_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">applyFilter</span><span class="params">(PointCloud &amp;output)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">computePointWeight</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> pid,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;indices,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp;distances)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setSearchMethod</span><span class="params">(<span class="keyword">const</span> KdTreePtr &amp;tree)</span></span>&#123;tree_=tree;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> sigma_s_;</span><br><span class="line">  <span class="keyword">double</span> sigma_r_;</span><br><span class="line">  KdTreePtr tree_;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCL_FILTERS_BILATERAL_H_</span></span></span><br></pre></td></tr></table></figure>
<h3 id="bilateralhpp"><a class="markdownIt-Anchor" href="#bilateralhpp"></a> bilateral.hpp</h3>
<ul>
<li>完成声明函数的具体实现，applyFilter和computePointWeight
<ul>
<li>applyFilter：利用输入数据构建的kd树，把所有输入数据复制到输出，然后计算新的点的强度，复制到点云数据output，</li>
<li>computePointWeight：通过传递一个要计算的强度重量的point索引，索引指示的点是由欧式空间的邻域组成。</li>
</ul>
</li>
<li>完成类声明PCL_INSTANTIATE用于实例化模板类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCL_FILTERS_BILATERAL_IMPL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCL_FILTERS_BILATERAL_IMPL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/bilateral.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PointT&gt;<span class="keyword">double</span> pcl::BilateralFilter&lt;PointT&gt;::computePointWeight(<span class="keyword">const</span> <span class="keyword">int</span> pid,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;indices,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp;distances)&#123;</span><br><span class="line">  <span class="keyword">double</span> BF=<span class="number">0</span>,W=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">size_t</span> nid=<span class="number">0</span>;n_id&lt;indices.size();++n_id)&#123;</span><br><span class="line">    <span class="keyword">double</span> id=indices[n_id];</span><br><span class="line">    <span class="keyword">double</span> dist=<span class="built_in">std</span>::<span class="built_in">sqrt</span>(distances[n_id]);</span><br><span class="line">    <span class="keyword">double</span> intensity_dist = <span class="built_in">abs</span>(input_-&gt;points[pid].intensity-input_-&gt;points[id].intensity);</span><br><span class="line">    <span class="keyword">double</span> weight = kernel(dist,sigma_s_)*kernel(intensity_dist,sigma_r_);</span><br><span class="line">    BF += weight*input_-&gt;points[id].intensity;</span><br><span class="line">    W += weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (BF/W);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PointT&gt;<span class="keyword">void</span> pcl::BilateralFilter&lt;PointT&gt;::applyFilter(PointCloud &amp;output)&#123;</span><br><span class="line">  <span class="keyword">if</span>(sigma_s_==<span class="number">0</span>)&#123;</span><br><span class="line">    PCL_ERROR(<span class="string">&quot;[pcl::BilateralFilter::applyFilter] Need a sigma_s value given before continuing.\n&quot;</span>);<span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tree_)&#123;</span><br><span class="line">    <span class="keyword">if</span> (input_-&gt;isOrganized())<span class="comment">//点云有序则使用OrganizedDataIndex有序搜索方法</span></span><br><span class="line">      tree_.reset(<span class="keyword">new</span> pcl::OrganizedDataIndex&lt;PointT&gt;());</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则使用KdTreeFLANN中的Kd树</span></span><br><span class="line">      tree_.reset(<span class="keyword">new</span> pcl::KdTreeFLANN&lt;PointT&gt;(<span class="literal">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  tree_-&gt;setInputCloud(input_);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;k_indices;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;k_distances;</span><br><span class="line">  output = *input_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> point_id=<span class="number">0</span>;point_id&lt;input_-&gt;points.size();++point_id)&#123;</span><br><span class="line">    tree_-&gt;radiusSearch(point_id,sigma_s_*<span class="number">2</span>,k_indices,k_distances);</span><br><span class="line">    output.points[point_id].intensity=computePointWeight(point_id,k_indices,k_distances);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCL_INSTANTIATE_BilateralFilter(T) template class PCL_EXPORTS pcl::BilateralFilter<span class="meta-string">&lt;T&gt;;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCL_FILTERS_BILATERAL_IMPL_H_</span></span></span><br></pre></td></tr></table></figure>
<h3 id="bilateralcpp"><a class="markdownIt-Anchor" href="#bilateralcpp"></a> bilateral.cpp</h3>
<ul>
<li>为BilateralFilter类实例化并预编译实例化若干模板，增加编译时间，但是能够提高使用时的速度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/impl/instantiate.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/bilateral.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/impl/bilateral.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> pcl;</span><br><span class="line"><span class="comment">//template class PCL_EXPORTS BilateralFilter&lt;PointXYZ&gt;; </span></span><br><span class="line"><span class="comment">//template class PCL_EXPORTS BilateralFilter&lt;PointXYZI&gt;; </span></span><br><span class="line"><span class="comment">//template class PCL_EXPORTS BilateralFilter&lt;PointXYRGB&gt;; </span></span><br><span class="line"><span class="comment">//... 上面这种根据类型添加会使代码变得冗余</span></span><br><span class="line">PCL_INSTANTIATE(BilateralFilter,PCL_XYZ_POINT_TYPES);</span><br><span class="line"><span class="comment">//使用宏PCL_INSTANTIATE，可以对所有在point_types.h中定义的XYZ点类型对模板进行实例化</span></span><br></pre></td></tr></table></figure>
<ul>
<li>需要实现模板类<code>PCL_INSTANTIATE</code>和<code>pcl::filter</code>的纯虚函数，才能成功编译</li>
</ul>
<h3 id="cmakeliststxt"><a class="markdownIt-Anchor" href="#cmakeliststxt"></a> CMakeLists.txt</h3>
<ul>
<li>将新建的文件添加到编译文件中，就可以实现编译连接的过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(srcs</span><br><span class="line">  src&#x2F;bilateral.cpp</span><br><span class="line">)</span><br><span class="line">set(incs</span><br><span class="line">  include&#x2F;pcl&#x2F;$(SUBSYS_NAME)&#x2F;bilateral.h</span><br><span class="line">)</span><br><span class="line">set(impl_incs</span><br><span class="line">  include&#x2F;pcl&#x2F;$(SUBSYS_NAME)&#x2F;impl&#x2F;bilateral.hpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="pcl自定义点类型"><a class="markdownIt-Anchor" href="#pcl自定义点类型"></a> PCL自定义点类型</h2>
<h3 id="pcl定义的点类型pointt"><a class="markdownIt-Anchor" href="#pcl定义的点类型pointt"></a> PCL定义的点类型PointT</h3>
<ul>
<li>在point_types.hpp中有完成目录，如果存在用户就不需要重复定义了</li>
</ul>
<table>
<thead>
<tr>
<th>PointT</th>
<th>成员</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PointXY</td>
<td>float x,y</td>
<td>点数据类型xy坐标</td>
</tr>
<tr>
<td>PointXYZ</td>
<td>float x,y,z</td>
<td>点数据类型xyz坐标</td>
</tr>
<tr>
<td>PointXYZI</td>
<td>float x,y,z,intensity</td>
<td>xyz坐标,indensity:强度值</td>
</tr>
<tr>
<td>PointXYZRGB</td>
<td>float x,y,z,rgb</td>
<td>xyz坐标,RGB</td>
</tr>
<tr>
<td>PointXYZRGBA</td>
<td>float x,y,z;uint32_t rgba</td>
<td>xyz坐标,RGBA</td>
</tr>
<tr>
<td>InterestPoint</td>
<td>float x,y,z,strength</td>
<td>xyz坐标,strength关键点的强度测量值</td>
</tr>
<tr>
<td>Normal</td>
<td>float normal[3],curvature</td>
<td>法向量以及曲率的测量值</td>
</tr>
<tr>
<td>PointNormal</td>
<td>float x,y,z,normal[3],curvature</td>
<td>xyz,法向量及曲率</td>
</tr>
<tr>
<td>PointXYZRGBNormal</td>
<td>float x,y,z,rgb,normal[3],curvature</td>
<td>xyzrgb,法向量及曲率</td>
</tr>
<tr>
<td>PointXYZINormal</td>
<td>float x,y,z,intensity,normal[3],curvature</td>
<td>xyz,强度值,法向量及曲率</td>
</tr>
<tr>
<td>PointWithRange</td>
<td>float x,y,z,range</td>
<td>xyz,range包含视点到采样点的距离测量值</td>
</tr>
<tr>
<td>PointWithViewpoint</td>
<td>float x,y,z,vp_x,vp_y,vp_z</td>
<td>xyz,vp_x,vp_y,vp_z</td>
</tr>
<tr>
<td>MomentInvariants</td>
<td>float j1,j2,j3</td>
<td>包含采样曲面上面片的3个不变矩的point类型，描述面片上质量的分布情况</td>
</tr>
<tr>
<td>PrincipalRadiiRSD</td>
<td>float r_min,r_max</td>
<td>包含曲面块上两个RSD半径的point类型</td>
</tr>
<tr>
<td>Boundary</td>
<td>uint8_t boundary_point</td>
<td>存储一个点是否位于曲面边界上</td>
</tr>
<tr>
<td>PrincipalCurvature</td>
<td>float principal_curvature[3],pc1,pc2</td>
<td>包含给定点主曲率的简单point类型</td>
</tr>
<tr>
<td>PFHSignature125</td>
<td>float pfh[125]</td>
<td>包含给定点PFH(点特征直方图)的point类型</td>
</tr>
<tr>
<td>FPFHSignature33</td>
<td>float fpfh[33]</td>
<td>包含给定点FPFH(快速点特征直方图)的point类型</td>
</tr>
<tr>
<td>VFHSignature308</td>
<td>float vfh[308]</td>
<td>包含给定点VFH(快速点特征直方图)的point类型</td>
</tr>
<tr>
<td>Narf36</td>
<td>float xyz,roll,pitch,yaw,descriptor[36]</td>
<td>包含给定点NARF(归一化对齐半径特征)的point类型</td>
</tr>
<tr>
<td>BorderDescription</td>
<td>int x,y;BorderTraits traits</td>
<td>给定点边界类型</td>
</tr>
<tr>
<td>IntensityGradient</td>
<td>float gradie[3]</td>
<td>给定点强度的梯度</td>
</tr>
<tr>
<td>Histogram</td>
<td>float histogram[N]</td>
<td>n维直方图</td>
</tr>
<tr>
<td>PointWithScale</td>
<td>float x,y,z,scale</td>
<td>x,y,z,scale几何操作尺度</td>
</tr>
<tr>
<td>PointSurfel</td>
<td>float x,y,z,normal[3],rgba,radius,confidence,curvature</td>
<td>复杂point信息</td>
</tr>
</tbody>
</table>
<ul>
<li>几种PointT类型示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PointXY</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">float</span> x,y;&#125;;</span><br><span class="line"><span class="comment">//PointXYZ</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="keyword">float</span> data[<span class="number">4</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">float</span> x,y,z;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PointXXYZI:intensity</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> intensity;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">float</span> data_c[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//PointXXYRGBA:uint32_t rgba</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> rgba;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">float</span> data_c[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PointXXYRGB:rgb</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> rgb;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">float</span> data_c[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//InterestPoint:strength</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> strength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">float</span> data_c[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Normal:float normal,curvature;法向量，以及曲率的测量值</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="keyword">float</span> data_n[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">float</span> normal[<span class="number">3</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> normal_x,normal_y,normal_z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> curvature;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">float</span> data_c[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PointNormal:xyz,normal[3],curvature;xyz数据，采样点对应发现和曲率</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="keyword">float</span> data[<span class="number">4</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x,y,z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="keyword">float</span> data_n[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">float</span> normal[<span class="number">3</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> normal_x,normal_y,normal_z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> curvature;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">float</span> data_c[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PointXTZRGBNormal:xyz,rgb,normal[3],curvature</span></span><br></pre></td></tr></table></figure>
<h3 id="新增pointt类型"><a class="markdownIt-Anchor" href="#新增pointt类型"></a> 新增PointT类型</h3>
<ul>
<li>定义新的类型，需要包含PCL特定的类/算法模板头文件的实现，这样才能在其共同使用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/bilateral.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/impl/bilateral.hpp&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPointType</span>&#123;</span></span><br><span class="line">  <span class="keyword">float</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是库的一部分，可以被他人使用，需要将自己的类型显式实例化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPointType</span>&#123;</span></span><br><span class="line">  PCL_ADD_POINT4D;</span><br><span class="line">  <span class="keyword">float</span> test;</span><br><span class="line">  EIGEN_MAKE_ALIGNED_OPERAROE_NEW</span><br><span class="line">&#125;EIGEN_ALIGN16;</span><br><span class="line">POINT_CLOUD_REGISTER_POINT_STRUCT(MyPointType,(<span class="keyword">float</span>,x,x),(<span class="keyword">float</span>,y,y),(<span class="keyword">float</span>,z,z),(<span class="keyword">float</span>,test,test))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;MyPointType&gt;cloud;</span><br><span class="line">  cloud.points.resize(<span class="number">2</span>);</span><br><span class="line">  cloud.width=<span class="number">2</span>;</span><br><span class="line">  cloud.height=<span class="number">1</span>;</span><br><span class="line">  cloud.points[<span class="number">0</span>].test=<span class="number">1</span>;</span><br><span class="line">  cloud.points[<span class="number">1</span>].test=<span class="number">1</span>;</span><br><span class="line">  cloud.points[<span class="number">0</span>].x=cloud.points[<span class="number">0</span>].y=cloud.points[<span class="number">0</span>].z=<span class="number">0</span>;</span><br><span class="line">  cloud.points[<span class="number">1</span>].x=cloud.points[<span class="number">1</span>].y=cloud.points[<span class="number">1</span>].z=<span class="number">3</span>;</span><br><span class="line">  pcl::io::savePCDFile(<span class="string">&quot;test.pcd&quot;</span>,cloud);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="许可"><a class="markdownIt-Anchor" href="#许可"></a> 许可</h2>
<ul>
<li>建议每个文件报验一个描述代码作者的许可，使用户对约束有清晰的了解。PCL是100%的BSD许可的，可以在文件中以<code>C++</code>注释的形式嵌入该许可证。如果需要声明其他版权，则添加类似内容即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) XXX, respective authors.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="代码注释"><a class="markdownIt-Anchor" href="#代码注释"></a> 代码注释</h2>
<ul>
<li>PCL支持Doxygen的文档生成，注释中可以对API进行完善</li>
</ul>
<h2 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h2>
<h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3>
<ul>
<li>PCL规定新定义的异常类必须继承PCLException类，具体定义在pcl/exceptions.h中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* * \class MyException</span></span><br><span class="line"><span class="comment"> * \brief An exception that is thrown when i want it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCL_EXPROTS</span> <span class="title">MyException</span>:</span><span class="keyword">public</span> PCLException&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MyException(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;error_description,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; file_name=<span class="string">&quot;&quot;</span>,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; function_name=<span class="string">&quot;&quot;</span>,<span class="keyword">unsigned</span> line_number=<span class="number">0</span>) <span class="keyword">throw</span>():pcl::PCLException(error_description,file_name,function_name,line_number)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用异常"><a class="markdownIt-Anchor" href="#使用异常"></a> 使用异常</h3>
<ul>
<li>为了方便使用自定义异常，定义宏</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCL_THROW_EXCEPTION(ExceptionName,message)&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">ostringstream</span> s;</span><br><span class="line">  s&lt;&lt;message;</span><br><span class="line">  <span class="keyword">throw</span> ExceptionName(s.str(),__FILE__,<span class="string">&quot;&quot;</span>,__LINE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异常抛出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(my_requirements!=the_parameters_used_)</span><br><span class="line">  PCL_THROW_EXCEPTION(MyExcption,<span class="string">&quot;My requirements are not set&quot;</span>&lt;&lt;the_parameter_used);</span><br></pre></td></tr></table></figure>
<h3 id="异常处理-2"><a class="markdownIt-Anchor" href="#异常处理-2"></a> 异常处理</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  myObject.myFunc(some_params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(pcl::MyException&amp; e)&#123;</span><br><span class="line">  <span class="comment">//MyException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">catch</span>(exception&amp; e)&#123;</span><br><span class="line">  <span class="comment">//任意异常的铺货</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="数据操作"><a class="markdownIt-Anchor" href="#数据操作"></a> 数据操作</h1>
<h2 id="简单使用"><a class="markdownIt-Anchor" href="#简单使用"></a> 简单使用</h2>
<ul>
<li>生成点云并保存为pcdld文件</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.6</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(MY_GRAND_PROJECT)</span><br><span class="line"><span class="keyword">find_package</span>(PCL <span class="number">1.3</span> REQUIRED COMPONENTS common io)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PCL_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PCL_LIBRARY_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;PCL_DEFINITIONS&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(pcd_write_test pcd_write.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(pcd_write_test <span class="variable">$&#123;PCL_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;</span><br><span class="line">  <span class="comment">// Fill in the cloud data</span></span><br><span class="line">  cloud.width    = <span class="number">5</span>;</span><br><span class="line">  cloud.height   = <span class="number">1</span>;</span><br><span class="line">  cloud.is_dense = <span class="literal">false</span>;</span><br><span class="line">  cloud.points.resize (cloud.width * cloud.height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point: cloud)  &#123;</span><br><span class="line">    point.x = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.y = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.z = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pcl::io::savePCDFileASCII (<span class="string">&quot;test_pcd.pcd&quot;</span>, cloud);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Saved &quot;</span> &lt;&lt; cloud.size () &lt;&lt; <span class="string">&quot; data points to test_pcd.pcd.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; point.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取pcd点云文件并展示</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/registration/icp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> pcl;</span><br><span class="line">PointCloud&lt;PointXYZI&gt;::<span class="function">Ptr <span class="title">getPoint</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; infile)</span></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(infile.c_str(), ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!input.good())&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not read file: &quot;</span> &lt;&lt; infile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    input.seekg(<span class="number">0</span>, ios::beg);</span><br><span class="line">    PointCloud&lt;PointXYZI&gt;::<span class="function">Ptr <span class="title">points</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointXYZI&gt;)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; input.good() &amp;&amp; !input.eof(); i++) &#123;</span><br><span class="line">        PointXYZI point;</span><br><span class="line">        input.read((<span class="keyword">char</span> *) &amp;point.x, <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">        input.read((<span class="keyword">char</span> *) &amp;point.intensity, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">        points-&gt;push_back(point);</span><br><span class="line">    &#125;</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">view</span> <span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr&amp; cloud)</span></span>&#123;</span><br><span class="line">    <span class="function">visualization::CloudViewer <span class="title">viewer</span> <span class="params">(<span class="string">&quot;Simple Cloud Viewer&quot;</span>)</span></span>;</span><br><span class="line">    viewer.showCloud (cloud);</span><br><span class="line">    <span class="keyword">while</span> (!viewer.wasStopped ())&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    PointCloud&lt;PointXYZI&gt;::Ptr cloud_in = getPoint(<span class="string">&quot;velodyne/000000.bin&quot;</span>);</span><br><span class="line">    PointCloud&lt;PointXYZI&gt;::Ptr cloud_out = getPoint(<span class="string">&quot;velodyne/000001.bin&quot;</span>);</span><br><span class="line">    view(cloud_in);</span><br><span class="line">    view(cloud_out);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="滤波"><a class="markdownIt-Anchor" href="#滤波"></a> 滤波</h1>
<h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>直通滤波器</td>
<td><code>pcl::PassThrought&lt;pcl::PointXYZ&gt;pass;</code></td>
<td>想要固定某一区域的</td>
</tr>
<tr>
<td>体素滤波器</td>
<td><code>pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt;vox;</code><br><code>pcl::ApproximateVoxelGrid&lt;pcl::PCLPointCloud2&gt;vox;</code>哈希map，速度更快</td>
<td>体素化</td>
</tr>
<tr>
<td>统计滤波器</td>
<td><code>pcl::StatistcalOutlierRemoval&lt;pcl::PointXYZ&gt;sor;</code></td>
<td>去除噪声</td>
</tr>
<tr>
<td>半径滤波器</td>
<td><code>pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt;rador;</code></td>
<td>统计半径里面多少点，不足就去除</td>
</tr>
<tr>
<td>均匀采样</td>
<td><code>pcl::UniformSampling&lt;pcl::PointXYZ&gt;rador;</code></td>
<td><code>setInputCloud(cloud)</code><br><code>setRadiusSearch(0.5)</code><br><code>comput(indices)</code></td>
</tr>
<tr>
<td>条件滤波器</td>
<td><code>pcl::ConditionalRemoval&lt;pcl::PointXYZ&gt;condr;</code></td>
<td></td>
</tr>
<tr>
<td>投影滤波器</td>
<td><code>pcl::ProjectInliers&lt;pcl::PointXYZ&gt;proj;</code></td>
<td></td>
</tr>
<tr>
<td>模型滤波器</td>
<td><code>pcl::ModelOutlierRemoval&lt;pcl::PointXYZ&gt;modr;</code></td>
<td>通过模型参数模拟，将超出阈值的点去除</td>
</tr>
<tr>
<td>索引提取</td>
<td><code>pcl::ExtractIndices&lt;pcl::PointXYZ&gt;extr;</code></td>
<td></td>
</tr>
<tr>
<td>空间裁减滤波</td>
<td><code>pcl::Clipper3D&lt;pcl::PointXYZ&gt;;</code><br><code>pcl::BoxCliper3D&lt;pcl::PointXYZ&gt;</code><br><code>pcl::CropBax&lt;pcl::PointXYZ&gt;</code><br><code>pcl::CropHull&lt;pcl::PointXYZ&gt;</code></td>
<td>CropHull凸包</td>
</tr>
<tr>
<td>双边滤波器</td>
<td><code>pcl::BilateralFilter&lt;pcl::PointXYZ&gt;bf;</code></td>
<td>保存边界的去噪声</td>
</tr>
<tr>
<td>高斯滤波器</td>
<td><code>pcl::filters::GuassianKernal&lt;PointInT,PointOutT&gt;;</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="直通滤波器"><a class="markdownIt-Anchor" href="#直通滤波器"></a> 直通滤波器</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/passthrough.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_filtered</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="comment">// Fill in the cloud data</span></span><br><span class="line">  cloud-&gt;width  = <span class="number">5</span>;</span><br><span class="line">  cloud-&gt;height = <span class="number">1</span>;</span><br><span class="line">  cloud-&gt;points.resize (cloud-&gt;width * cloud-&gt;height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point: *cloud) &#123;</span><br><span class="line">    point.x = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.y = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.z = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Cloud before filtering: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: *cloud)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; point.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// Create the filtering object</span></span><br><span class="line">  pcl::PassThrough&lt;pcl::PointXYZ&gt; pass;</span><br><span class="line">  pass.setInputCloud (cloud);</span><br><span class="line">  pass.setFilterFieldName (<span class="string">&quot;z&quot;</span>);</span><br><span class="line">  pass.setFilterLimits (<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">  <span class="comment">//pass.setFilterLimitsNegative (true);</span></span><br><span class="line">  pass.filter (*cloud_filtered);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Cloud after filtering: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: *cloud_filtered)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-354.png" alt="" /></p>
<h2 id="体素滤波器"><a class="markdownIt-Anchor" href="#体素滤波器"></a> 体素滤波器</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pcl::<span class="function">PCLPointCloud2::Ptr <span class="title">cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;</span><br><span class="line">  pcl::<span class="function">PCLPointCloud2::Ptr <span class="title">cloud_filtered</span> <span class="params">(<span class="keyword">new</span> pcl::PCLPointCloud2 ())</span></span>;</span><br><span class="line">  <span class="comment">// Fill in the cloud data</span></span><br><span class="line">  pcl::PCDReader reader;</span><br><span class="line">  <span class="comment">// Replace the path below with the path where you saved your file</span></span><br><span class="line">  reader.read (<span class="string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud); <span class="comment">// Remember to download the file first!</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;PointCloud before filtering: &quot;</span> &lt;&lt; cloud-&gt;width * cloud-&gt;height &lt;&lt; <span class="string">&quot; data points (&quot;</span> &lt;&lt; pcl::getFieldsList (*cloud) &lt;&lt; <span class="string">&quot;).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// Create the filtering object</span></span><br><span class="line">  pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;</span><br><span class="line">  sor.setInputCloud (cloud);</span><br><span class="line">  sor.setLeafSize (<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);<span class="comment">//设置滤波时创建1cm的立方体</span></span><br><span class="line">  sor.filter (*cloud_filtered);<span class="comment">//执行滤波</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;PointCloud after filtering: &quot;</span> &lt;&lt; cloud_filtered-&gt;width * cloud_filtered-&gt;height &lt;&lt; <span class="string">&quot; data points (&quot;</span> &lt;&lt; pcl::getFieldsList (*cloud_filtered) &lt;&lt; <span class="string">&quot;).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pcl::PCDWriter writer;</span><br><span class="line">  writer.write (<span class="string">&quot;table_scene_lms400_downsampled.pcd&quot;</span>, *cloud_filtered,   Eigen::Vector4f::Zero (), Eigen::Quaternionf::Identity (), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-355.png" alt="" /></p>
<ul>
<li>在每个voxel中保留了重心，可以看出并不是特别均匀。</li>
</ul>
<h2 id="统计滤波器"><a class="markdownIt-Anchor" href="#统计滤波器"></a> 统计滤波器</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_filtered</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="comment">// Fill in the cloud data</span></span><br><span class="line">  pcl::PCDReader reader;</span><br><span class="line">  <span class="comment">// Replace the path below with the path where you saved your file</span></span><br><span class="line">  reader.read&lt;pcl::PointXYZ&gt; (<span class="string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Cloud before filtering: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; *cloud &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// Create the filtering object</span></span><br><span class="line">  pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;</span><br><span class="line">  sor.setInputCloud (cloud);</span><br><span class="line">  sor.setMeanK (<span class="number">50</span>);</span><br><span class="line">  sor.setStddevMulThresh (<span class="number">1.0</span>);</span><br><span class="line">  sor.filter (*cloud_filtered);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Cloud after filtering: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; *cloud_filtered &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pcl::PCDWriter writer;</span><br><span class="line">  writer.write&lt;pcl::PointXYZ&gt; (<span class="string">&quot;table_scene_lms400_inliers.pcd&quot;</span>, *cloud_filtered, <span class="literal">false</span>);</span><br><span class="line">  sor.setNegative (<span class="literal">true</span>);</span><br><span class="line">  sor.filter (*cloud_filtered);</span><br><span class="line">  writer.write&lt;pcl::PointXYZ&gt; (<span class="string">&quot;table_scene_lms400_outliers.pcd&quot;</span>, *cloud_filtered, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-356.png" alt="" /></p>
<h2 id="条件滤波器"><a class="markdownIt-Anchor" href="#条件滤波器"></a> 条件滤波器</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/radius_outlier_removal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/conditional_removal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;please specify command line arg &#x27;-r&#x27; or &#x27;-c&#x27;&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_filtered</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="comment">// Fill in the cloud data</span></span><br><span class="line">  cloud-&gt;width  = <span class="number">5</span>;</span><br><span class="line">  cloud-&gt;height = <span class="number">1</span>;</span><br><span class="line">  cloud-&gt;resize (cloud-&gt;width * cloud-&gt;height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point: *cloud)  &#123;</span><br><span class="line">    point.x = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.y = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.z = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-r&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem;</span><br><span class="line">    <span class="comment">// build the filter</span></span><br><span class="line">    outrem.setInputCloud(cloud);</span><br><span class="line">    outrem.setRadiusSearch(<span class="number">0.8</span>);</span><br><span class="line">    outrem.setMinNeighborsInRadius (<span class="number">2</span>);</span><br><span class="line">    outrem.setKeepOrganized(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// apply filter</span></span><br><span class="line">    outrem.filter (*cloud_filtered);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-c&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// build the condition</span></span><br><span class="line">    pcl::ConditionAnd&lt;pcl::PointXYZ&gt;::Ptr range_cond (<span class="keyword">new</span>      pcl::ConditionAnd&lt;pcl::PointXYZ&gt; ());</span><br><span class="line">    range_cond-&gt;addComparison (pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr (<span class="keyword">new</span> pcl::FieldComparison&lt;pcl::PointXYZ&gt; (<span class="string">&quot;z&quot;</span>, pcl::ComparisonOps::GT, <span class="number">0.0</span>)));</span><br><span class="line">    range_cond-&gt;addComparison (pcl::FieldComparison&lt;pcl::PointXYZ&gt;::ConstPtr (<span class="keyword">new</span> pcl::FieldComparison&lt;pcl::PointXYZ&gt; (<span class="string">&quot;z&quot;</span>, pcl::ComparisonOps::LT, <span class="number">0.8</span>)));</span><br><span class="line">    <span class="comment">// build the filter</span></span><br><span class="line">    pcl::ConditionalRemoval&lt;pcl::PointXYZ&gt; condrem;</span><br><span class="line">    condrem.setCondition (range_cond);</span><br><span class="line">    condrem.setInputCloud (cloud);</span><br><span class="line">    condrem.setKeepOrganized(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// apply filter</span></span><br><span class="line">    condrem.filter (*cloud_filtered);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;please specify command line arg &#x27;-r&#x27; or &#x27;-c&#x27;&quot;</span> &lt;&lt; ::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Cloud before filtering: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: *cloud)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.y &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// display pointcloud after filtering</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Cloud after filtering: &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: *cloud_filtered)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.y &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引提取"><a class="markdownIt-Anchor" href="#索引提取"></a> 索引提取</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/ModelCoefficients.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/method_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/model_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  pcl::PCLPointCloud2::Ptr cloud_blob (new pcl::PCLPointCloud2), cloud_filtered_blob (new pcl::PCLPointCloud2);</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered (new pcl::PointCloud&lt;pcl::PointXYZ&gt;), cloud_p (new pcl::PointCloud&lt;pcl::PointXYZ&gt;), cloud_f (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);</span><br><span class="line">  <span class="comment">// Fill in the cloud data</span></span><br><span class="line">  pcl::PCDReader reader;</span><br><span class="line">  reader.read (<span class="string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud_blob);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;PointCloud before filtering: &quot;</span> &lt;&lt; cloud_blob-&gt;width * cloud_blob-&gt;height &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// Create the filtering object: downsample the dataset using a leaf size of 1cm</span></span><br><span class="line">  pcl::VoxelGrid&lt;pcl::PCLPointCloud2&gt; sor;</span><br><span class="line">  sor.setInputCloud (cloud_blob);</span><br><span class="line">  sor.setLeafSize (<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);</span><br><span class="line">  sor.filter (*cloud_filtered_blob);</span><br><span class="line">  <span class="comment">// Convert to the templated PointCloud</span></span><br><span class="line">  pcl::fromPCLPointCloud2 (*cloud_filtered_blob, *cloud_filtered);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;PointCloud after filtering: &quot;</span> &lt;&lt; cloud_filtered-&gt;width * cloud_filtered-&gt;height &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// Write the downsampled version to disk</span></span><br><span class="line">  pcl::PCDWriter writer;</span><br><span class="line">  writer.write&lt;pcl::PointXYZ&gt; (<span class="string">&quot;table_scene_lms400_downsampled.pcd&quot;</span>, *cloud_filtered, <span class="literal">false</span>);</span><br><span class="line">  pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients ())</span></span>;</span><br><span class="line">  pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices ())</span></span>;</span><br><span class="line">  <span class="comment">// Create the segmentation object</span></span><br><span class="line">  pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;</span><br><span class="line">  <span class="comment">// Optional</span></span><br><span class="line">  seg.setOptimizeCoefficients (<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Mandatory</span></span><br><span class="line">  seg.setModelType (pcl::SACMODEL_PLANE);</span><br><span class="line">  seg.setMethodType (pcl::SAC_RANSAC);</span><br><span class="line">  seg.setMaxIterations (<span class="number">1000</span>);</span><br><span class="line">  seg.setDistanceThreshold (<span class="number">0.01</span>);</span><br><span class="line">  <span class="comment">// Create the filtering object</span></span><br><span class="line">  pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, nr_points = (<span class="keyword">int</span>) cloud_filtered-&gt;size ();</span><br><span class="line">  <span class="comment">// While 30% of the original cloud is still there</span></span><br><span class="line">  <span class="keyword">while</span> (cloud_filtered-&gt;size () &gt; <span class="number">0.3</span> * nr_points)  &#123;</span><br><span class="line">    <span class="comment">// Segment the largest planar component from the remaining cloud</span></span><br><span class="line">    seg.setInputCloud (cloud_filtered);</span><br><span class="line">    seg.segment (*inliers, *coefficients);</span><br><span class="line">    <span class="keyword">if</span> (inliers-&gt;indices.size () == <span class="number">0</span>)    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Could not estimate a planar model for the given dataset.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Extract the inliers</span></span><br><span class="line">    extract.setInputCloud (cloud_filtered);</span><br><span class="line">    extract.setIndices (inliers);</span><br><span class="line">    extract.setNegative (<span class="literal">false</span>);</span><br><span class="line">    extract.filter (*cloud_p);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;PointCloud representing the planar component: &quot;</span> &lt;&lt; cloud_p-&gt;width * cloud_p-&gt;height &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;table_scene_lms400_plane_&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;.pcd&quot;</span>;</span><br><span class="line">    writer.write&lt;pcl::PointXYZ&gt; (ss.str (), *cloud_p, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// Create the filtering object</span></span><br><span class="line">    extract.setNegative (<span class="literal">true</span>);</span><br><span class="line">    extract.filter (*cloud_f);</span><br><span class="line">    cloud_filtered.swap (cloud_f);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最近邻搜索"><a class="markdownIt-Anchor" href="#最近邻搜索"></a> 最近邻搜索</h1>
<ul>
<li>
<p>空间索引结构</p>
<ul>
<li>BSP树</li>
<li>KD树</li>
<li>KDB树</li>
<li>R树</li>
<li>四叉树</li>
<li>八叉树</li>
</ul>
</li>
<li>
<p>点云中常用的基础结构</p>
<ul>
<li>OcTree</li>
<li>KdTree</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>搜索（邻域、半径、体素）</li>
<li>将采样（体素网格、体素质心滤波）</li>
<li>点云压缩</li>
<li>空间变化检测</li>
<li>空间点密度分析</li>
<li>占用检查、占用地图</li>
<li>碰撞检测</li>
<li>点云合并</li>
</ul>
</li>
</ul>
<h2 id="kdtree"><a class="markdownIt-Anchor" href="#kdtree"></a> KDTree</h2>
<ul>
<li>KDTree实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/kdtree/kdtree_flann.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  srand (time (<span class="literal">NULL</span>));</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="comment">// Generate pointcloud data</span></span><br><span class="line">  cloud-&gt;width = <span class="number">1000</span>;</span><br><span class="line">  cloud-&gt;height = <span class="number">1</span>;</span><br><span class="line">  cloud-&gt;points.resize (cloud-&gt;width * cloud-&gt;height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;size (); ++i)  &#123;</span><br><span class="line">    (*cloud)[i].x = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    (*cloud)[i].y = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    (*cloud)[i].z = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pcl::KdTreeFLANN&lt;pcl::PointXYZ&gt; kdtree;</span><br><span class="line">  kdtree.setInputCloud (cloud);</span><br><span class="line">  pcl::PointXYZ searchPoint;</span><br><span class="line">  searchPoint.x = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  searchPoint.y = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  searchPoint.z = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  <span class="comment">// K nearest neighbor search</span></span><br><span class="line">  <span class="keyword">int</span> K = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pointIdxNKNSearch</span><span class="params">(K)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; <span class="title">pointNKNSquaredDistance</span><span class="params">(K)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;K nearest neighbor search at (&quot;</span> &lt;&lt; searchPoint.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.z&lt;&lt; <span class="string">&quot;) with K=&quot;</span> &lt;&lt; K &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span> ( kdtree.nearestKSearch (searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) &gt; <span class="number">0</span> )  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pointIdxNKNSearch.size (); ++i)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    &quot;</span>  &lt;&lt;   (*cloud)[ pointIdxNKNSearch[i] ].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxNKNSearch[i] ].y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxNKNSearch[i] ].z &lt;&lt; <span class="string">&quot; (squared distance: &quot;</span> &lt;&lt; pointNKNSquaredDistance[i] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Neighbors within radius search</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pointIdxRadiusSearch;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; pointRadiusSquaredDistance;</span><br><span class="line">  <span class="keyword">float</span> radius = <span class="number">256.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Neighbors within radius search at (&quot;</span> &lt;&lt; searchPoint.x </span><br><span class="line">            &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.y </span><br><span class="line">            &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.z</span><br><span class="line">            &lt;&lt; <span class="string">&quot;) with radius=&quot;</span> &lt;&lt; radius &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span> ( kdtree.radiusSearch (searchPoint, radius, pointIdxRadiusSearch, pointRadiusSquaredDistance) &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pointIdxRadiusSearch.size (); ++i)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    &quot;</span>  &lt;&lt;   (*cloud)[ pointIdxRadiusSearch[i] ].x </span><br><span class="line">                &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxRadiusSearch[i] ].y </span><br><span class="line">                &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxRadiusSearch[i] ].z </span><br><span class="line">                &lt;&lt; <span class="string">&quot; (squared distance: &quot;</span> &lt;&lt; pointRadiusSquaredDistance[i] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>法向量估计</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建特征估计对象</span></span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ,pcl::Normal&gt;ne;</span><br><span class="line"><span class="comment">//设置搜索法那个法，创建一个kd树并将其传递给特性估计器</span></span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span><span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;())</span></span>;</span><br><span class="line">ne.setSearchMethod(tree);</span><br><span class="line"><span class="comment">//指定计算特征时使用的局部邻域大小</span></span><br><span class="line">ne.setRadiusSearch(r);<span class="comment">//ne.setNearestKSearch(k);</span></span><br><span class="line"><span class="comment">//设置输入点云</span></span><br><span class="line">ne.setInputCloud(cloud);</span><br><span class="line"><span class="comment">//计算</span></span><br><span class="line">pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">cloud_normals</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">ne.compute(*cloud_normals);</span><br></pre></td></tr></table></figure>
<h2 id="octree"><a class="markdownIt-Anchor" href="#octree"></a> OcTree</h2>
<p>使用|说明<br />
检查给定坐标体素是否存在|<code>double X=1.,Y=2.,Z=3.;bool occupied=octree.isVoxelOccupiedAtPoint(X,Y,Z);</code><br />
获取所占用体素的中心点|<code>vector&lt;PointXYZ&gt;pointGrid;octree.getOccupiedVoxelCenters(pointGrid);</code><br />
查询点所在的体素内的近邻点|<code>vector&lt;int&gt;pointIdxVec;octree.voxelSearch(searchPoint,pointIdxVec);</code><br />
查询点所在的半径内的近邻点|<code>vector&lt;int&gt;pointIdxVec;vector&lt;float&gt;pointSquaredDistance;float radius=0.1;octree.radiusSearch(searchPoint,radius,pointIdxVec,pointSquaredDistance);</code>扫描所有候选体素<br><code>octree.approxNearestSearch(searchPoint,radius,pointIdxVec,pointSquaredDistance);</code>只扫描搜索点体素<br />
K紧邻搜索|<code>vector&lt;int&gt;pointIdxVec;vector&lt;float&gt;pointSquaredDistance;int K=10;octree.nearestSearch(searchPoint,K,pointIdxVec,pointSquaredDistance);</code><br />
光线跟踪|<code>PointCloud&lt;PointXYZ&gt;::Ptr voxelCenters(new PointCloud&lt;PointXYZ&gt;());Eigen::Vector3f origin(0.,0.,0.),direction(0.1,0.2,0.3);octree.getIntersectedVoxelCenters(origin,direction,voxelCenters-&gt;points)</code><br />
密度估计|<code>OctreePointCloudDensity&lt;PintXYZ&gt;</code><br />
空间变化检测(双缓冲)|<code>octree.setInputCloud(cloudA_ptr);</code>设置输入点云<br><code>octree.addPointsFromInputCloud();</code>从输入点云构建八叉树<br><code>octree.switchBuffers();</code>交换八叉树缓存，但cloudA对应的八叉树结构仍在内存中<br><code>octree.setInputCloud(cloudB_ptr);</code>添加B<br><code>octree.addPointsFromInputCloud();</code><br><code>vector&lt;int&gt;newPointIdxVector;</code><br><code>octree.getPointIndicesFromNewVoxels(newPointIdxVector);</code>获取A的八叉树，在B对应的八叉树中A内没有的点集<br />
删除体素|<code>PointXYZ point_arg(1.,2.,3.);octree.deleteVoxelAtPoint(point);</code><br />
迭代器|<code>OctreePointCloud&lt;PointXYZ&gt;::Iterator it(octreeA);</code>迭代所有octree节点<br><code>OctreePointCloud&lt;PointXYZ&gt;::LeafNodeIterator itL(octreeA);</code>迭代所有octree叶节点</p>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/octree/octree_search.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  srand ((<span class="keyword">unsigned</span> <span class="keyword">int</span>) time (<span class="literal">NULL</span>));</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="comment">// Generate pointcloud data</span></span><br><span class="line">  cloud-&gt;width = <span class="number">1000</span>;</span><br><span class="line">  cloud-&gt;height = <span class="number">1</span>;</span><br><span class="line">  cloud-&gt;points.resize (cloud-&gt;width * cloud-&gt;height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;size (); ++i)&#123;</span><br><span class="line">    (*cloud)[i].x = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    (*cloud)[i].y = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    (*cloud)[i].z = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">float</span> resolution = <span class="number">128.0f</span>;</span><br><span class="line">  pcl::<span class="function">octree::OctreePointCloudSearch&lt;pcl::PointXYZ&gt; <span class="title">octree</span> <span class="params">(resolution)</span></span>;</span><br><span class="line">  octree.setInputCloud (cloud);</span><br><span class="line">  octree.addPointsFromInputCloud ();</span><br><span class="line">  pcl::PointXYZ searchPoint;</span><br><span class="line">  searchPoint.x = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  searchPoint.y = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  searchPoint.z = <span class="number">1024.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  <span class="comment">// Neighbors within voxel search</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pointIdxVec;</span><br><span class="line">  <span class="keyword">if</span> (octree.voxelSearch (searchPoint, pointIdxVec))&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Neighbors within voxel search at (&quot;</span> &lt;&lt; searchPoint.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.z &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pointIdxVec.size (); ++i)</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; (*cloud)[pointIdxVec[i]].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[pointIdxVec[i]].y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[pointIdxVec[i]].z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// K nearest neighbor search</span></span><br><span class="line">  <span class="keyword">int</span> K = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pointIdxNKNSearch;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; pointNKNSquaredDistance;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;K nearest neighbor search at (&quot;</span> &lt;&lt; searchPoint.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.z&lt;&lt; <span class="string">&quot;) with K=&quot;</span> &lt;&lt; K &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span> (octree.nearestKSearch (searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pointIdxNKNSearch.size (); ++i)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    &quot;</span>  &lt;&lt;   (*cloud)[ pointIdxNKNSearch[i] ].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxNKNSearch[i] ].y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxNKNSearch[i] ].z &lt;&lt; <span class="string">&quot; (squared distance: &quot;</span> &lt;&lt; pointNKNSquaredDistance[i] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Neighbors within radius search</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pointIdxRadiusSearch;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; pointRadiusSquaredDistance;</span><br><span class="line">  <span class="keyword">float</span> radius = <span class="number">256.0f</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Neighbors within radius search at (&quot;</span> &lt;&lt; searchPoint.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; searchPoint.z&lt;&lt; <span class="string">&quot;) with radius=&quot;</span> &lt;&lt; radius &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">if</span> (octree.radiusSearch (searchPoint, radius, pointIdxRadiusSearch, pointRadiusSquaredDistance) &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pointIdxRadiusSearch.size (); ++i)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    &quot;</span>  &lt;&lt;   (*cloud)[ pointIdxRadiusSearch[i] ].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxRadiusSearch[i] ].y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*cloud)[ pointIdxRadiusSearch[i] ].z &lt;&lt; <span class="string">&quot; (squared distance: &quot;</span> &lt;&lt; pointRadiusSquaredDistance[i] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分割"><a class="markdownIt-Anchor" href="#分割"></a> 分割</h1>
<ul>
<li>几何分割</li>
<li>语义分割</li>
<li>实例分割</li>
</ul>
<h2 id="通过数据拟合获取平面"><a class="markdownIt-Anchor" href="#通过数据拟合获取平面"></a> 通过数据拟合获取平面</h2>
<ul>
<li>pcl提供的RANSAC方法</li>
</ul>
<table>
<thead>
<tr>
<th>采样一致性算法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机采样一致性算法</td>
<td>RANSAC</td>
</tr>
<tr>
<td>加权采样一致性算法</td>
<td>MSAC</td>
</tr>
<tr>
<td>最大似然一致性算法</td>
<td>MLESAC</td>
</tr>
<tr>
<td>最小中值方差一致性算法</td>
<td>LMEDS</td>
</tr>
<tr>
<td>渐进采样一致性算法</td>
<td>PROSAC</td>
</tr>
</tbody>
</table>
<ul>
<li>采样一致性接口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pcl::SampleConsensusModel&lt;PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelPlane&lt;PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelLine&lt;PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelCircle3D&lt;PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelCircle2D&lt;PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelSphere&lt;PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelCone&lt;PointT,PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelCylinder&lt;PointT,PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelRegistration&lt;PointT&gt;;</span><br><span class="line">pcl::SampleConsensusModelStick&lt;PointT&gt;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>拟合模型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>平面模型</td>
<td><code>SACMODEL_PLANE[normal_x,normal_y,normal_z,d]</code></td>
</tr>
<tr>
<td>线模型</td>
<td><code>SACMODEL_LINE[point_on_line.x,point_on_line.y,point_on_line.z,point_direction.x,point_direction.y,point_direction.z]</code></td>
</tr>
<tr>
<td>平面圆模型</td>
<td><code>SACMODEL_CIRCLE2D[center.x,center.y,center.z,radius]</code></td>
</tr>
<tr>
<td>三维圆模型</td>
<td><code>SACMODEL_CIRCLE3D[center.x,center.y,center.z,radius,normal.x,normal.y,normal.z]</code></td>
</tr>
<tr>
<td>球模型</td>
<td><code>SACMODEL_SPHERE</code></td>
</tr>
<tr>
<td>圆柱体模型</td>
<td><code>SACMODEL_CYLINDER[point_on_axis.x,point_on_axis.y,point_on_axis.z,axis_direction.x,axis_direction.y,axis_direction.z,radius]</code></td>
</tr>
<tr>
<td>圆锥体模型</td>
<td><code>SACMODEL_CONE[apex.x,apex.y,apex.z,aixis_direction.x,aixis_direction.y,aixis_direction.z,opening_angle]</code></td>
</tr>
</tbody>
</table>
<h2 id="plane-model"><a class="markdownIt-Anchor" href="#plane-model"></a> Plane model</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/ModelCoefficients.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/method_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/model_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="comment">// Fill in the cloud data</span></span><br><span class="line">  cloud-&gt;width  = <span class="number">15</span>;</span><br><span class="line">  cloud-&gt;height = <span class="number">1</span>;</span><br><span class="line">  cloud-&gt;points.resize (cloud-&gt;width * cloud-&gt;height);</span><br><span class="line">  <span class="comment">// Generate the data</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point: *cloud)  &#123;</span><br><span class="line">    point.x = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.y = <span class="number">1024</span> * rand () / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.z = <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Set a few outliers</span></span><br><span class="line">  (*cloud)[<span class="number">0</span>].z = <span class="number">2.0</span>;(*cloud)[<span class="number">3</span>].z = <span class="number">-2.0</span>;(*cloud)[<span class="number">6</span>].z = <span class="number">4.0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Point cloud data: &quot;</span> &lt;&lt; cloud-&gt;size () &lt;&lt; <span class="string">&quot; points&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: *cloud)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; point.x &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.y &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; point.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//模型系数</span></span><br><span class="line">  pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;</span><br><span class="line">  pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">  <span class="comment">// Create the segmentation object</span></span><br><span class="line">  pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;</span><br><span class="line">  <span class="comment">// Optional优化模型系数</span></span><br><span class="line">  seg.setOptimizeCoefficients (<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Mandatory设置模型和采样方法</span></span><br><span class="line">  seg.setModelType (pcl::SACMODEL_PLANE);<span class="comment">//平面模型</span></span><br><span class="line">  seg.setMethodType (pcl::SAC_RANSAC);<span class="comment">//随即一致性采样</span></span><br><span class="line">  seg.setDistanceThreshold (<span class="number">0.01</span>);</span><br><span class="line">  seg.setInputCloud (cloud);</span><br><span class="line">  seg.segment (*inliers, *coefficients);</span><br><span class="line">  <span class="keyword">if</span> (inliers-&gt;indices.size () == <span class="number">0</span>)  &#123;</span><br><span class="line">    PCL_ERROR (<span class="string">&quot;Could not estimate a planar model for the given dataset.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Model coefficients: &quot;</span> &lt;&lt; coefficients-&gt;values[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; coefficients-&gt;values[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; coefficients-&gt;values[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; coefficients-&gt;values[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Model inliers: &quot;</span> &lt;&lt; inliers-&gt;indices.size () &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inliers-&gt;indices.size (); ++i)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; idx: inliers-&gt;indices)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; cloud-&gt;points[idx].x &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; cloud-&gt;points[idx].y &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; cloud-&gt;points[idx].z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="聚类"><a class="markdownIt-Anchor" href="#聚类"></a> 聚类</h2>
<ul>
<li>根据平面模型分割出物体表面上的物体</li>
<li>聚类找出例如桌面上的东西</li>
<li>计算平面的凸包，分割出物体</li>
</ul>
<h3 id="分割拟合聚类"><a class="markdownIt-Anchor" href="#分割拟合聚类"></a> 分割拟合聚类</h3>
<ul>
<li>ExtractPolygonalPrismData</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;pcl/ModelCoefficients.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/method_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/model_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/passthrough.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/project_inliers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/surface/convex_hull.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;), cloud_filtered (new pcl::PointCloud&lt;pcl::PointXYZ&gt;), cloud_projected (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);</span><br><span class="line">  pcl::PCDReader reader;</span><br><span class="line">  reader.read (<span class="string">&quot;table_scene_mug_stereo_textured.pcd&quot;</span>, *cloud);</span><br><span class="line">  <span class="comment">// Build a filter to remove spurious NaNs</span></span><br><span class="line">  pcl::PassThrough&lt;pcl::PointXYZ&gt; pass;</span><br><span class="line">  pass.setInputCloud (cloud);</span><br><span class="line">  pass.setFilterFieldName (<span class="string">&quot;z&quot;</span>);</span><br><span class="line">  pass.setFilterLimits (<span class="number">0</span>, <span class="number">1.1</span>);</span><br><span class="line">  pass.filter (*cloud_filtered);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;PointCloud after filtering has: &quot;</span> &lt;&lt; cloud_filtered-&gt;size () &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;</span><br><span class="line">  pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">  <span class="comment">// Create the segmentation object</span></span><br><span class="line">  pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;</span><br><span class="line">  <span class="comment">// Optional</span></span><br><span class="line">  seg.setOptimizeCoefficients (<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Mandatory</span></span><br><span class="line">  seg.setModelType (pcl::SACMODEL_PLANE);</span><br><span class="line">  seg.setMethodType (pcl::SAC_RANSAC);</span><br><span class="line">  seg.setDistanceThreshold (<span class="number">0.01</span>);</span><br><span class="line">  seg.setInputCloud (cloud_filtered);</span><br><span class="line">  seg.segment (*inliers, *coefficients);</span><br><span class="line">  <span class="comment">// Project the model inliers</span></span><br><span class="line">  pcl::ProjectInliers&lt;pcl::PointXYZ&gt; proj;</span><br><span class="line">  proj.setModelType (pcl::SACMODEL_PLANE);</span><br><span class="line">  proj.setInputCloud (cloud_filtered);</span><br><span class="line">  proj.setIndices (inliers);</span><br><span class="line">  proj.setModelCoefficients (coefficients);</span><br><span class="line">  proj.filter (*cloud_projected);</span><br><span class="line">  <span class="comment">// Create a Convex Hull representation of the projected inliers</span></span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_hull</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  pcl::ConvexHull&lt;pcl::PointXYZ&gt; chull;</span><br><span class="line">  chull.setInputCloud (cloud_projected);</span><br><span class="line">  chull.reconstruct (*cloud_hull);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Convex hull has: &quot;</span> &lt;&lt; cloud_hull-&gt;size () &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pcl::PCDWriter writer;</span><br><span class="line">  writer.write (<span class="string">&quot;table_scene_mug_stereo_textured_hull.pcd&quot;</span>, *cloud_hull, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧几里德聚类算法"><a class="markdownIt-Anchor" href="#欧几里德聚类算法"></a> 欧几里德聚类算法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/ModelCoefficients.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/extract_indices.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/voxel_grid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/features/normal_3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/kdtree/kdtree.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/method_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/sample_consensus/model_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/segmentation/sac_segmentation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/segmentation/extract_clusters.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Read in the cloud data</span></span><br><span class="line">  pcl::PCDReader reader;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt;), cloud_f (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);</span><br><span class="line">  reader.read (<span class="string">&quot;table_scene_lms400.pcd&quot;</span>, *cloud);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PointCloud before filtering has: &quot;</span> &lt;&lt; cloud-&gt;size () &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//*</span></span><br><span class="line">  <span class="comment">// Create the filtering object: downsample the dataset using a leaf size of 1cm</span></span><br><span class="line">  pcl::VoxelGrid&lt;pcl::PointXYZ&gt; vg;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_filtered</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  vg.setInputCloud (cloud);</span><br><span class="line">  vg.setLeafSize (<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);</span><br><span class="line">  vg.filter (*cloud_filtered);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PointCloud after filtering has: &quot;</span> &lt;&lt; cloud_filtered-&gt;size ()  &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//*</span></span><br><span class="line">  <span class="comment">// Create the segmentation object for the planar model and set all the parameters</span></span><br><span class="line">  pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;</span><br><span class="line">  pcl::<span class="function">PointIndices::Ptr <span class="title">inliers</span> <span class="params">(<span class="keyword">new</span> pcl::PointIndices)</span></span>;</span><br><span class="line">  pcl::<span class="function">ModelCoefficients::Ptr <span class="title">coefficients</span> <span class="params">(<span class="keyword">new</span> pcl::ModelCoefficients)</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_plane</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">  pcl::PCDWriter writer;</span><br><span class="line">  seg.setOptimizeCoefficients (<span class="literal">true</span>);</span><br><span class="line">  seg.setModelType (pcl::SACMODEL_PLANE);</span><br><span class="line">  seg.setMethodType (pcl::SAC_RANSAC);</span><br><span class="line">  seg.setMaxIterations (<span class="number">100</span>);</span><br><span class="line">  seg.setDistanceThreshold (<span class="number">0.02</span>);</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, nr_points = (<span class="keyword">int</span>) cloud_filtered-&gt;size ();</span><br><span class="line">  <span class="keyword">while</span> (cloud_filtered-&gt;size () &gt; <span class="number">0.3</span> * nr_points)&#123;</span><br><span class="line">    <span class="comment">// Segment the largest planar component from the remaining cloud</span></span><br><span class="line">    seg.setInputCloud (cloud_filtered);</span><br><span class="line">    seg.segment (*inliers, *coefficients);</span><br><span class="line">    <span class="keyword">if</span> (inliers-&gt;indices.size () == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Could not estimate a planar model for the given dataset.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Extract the planar inliers from the input cloud</span></span><br><span class="line">    pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">    extract.setInputCloud (cloud_filtered);</span><br><span class="line">    extract.setIndices (inliers);</span><br><span class="line">    extract.setNegative (<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// Get the points associated with the planar surface</span></span><br><span class="line">    extract.filter (*cloud_plane);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PointCloud representing the planar component: &quot;</span> &lt;&lt; cloud_plane-&gt;size () &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Remove the planar inliers, extract the rest</span></span><br><span class="line">    extract.setNegative (<span class="literal">true</span>);</span><br><span class="line">    extract.filter (*cloud_f);</span><br><span class="line">    *cloud_filtered = *cloud_f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Creating the KdTree object for the search method of the extraction</span></span><br><span class="line">  pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  tree-&gt;setInputCloud (cloud_filtered);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointIndices&gt; cluster_indices;</span><br><span class="line">  pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;</span><br><span class="line">  ec.setClusterTolerance (<span class="number">0.02</span>); <span class="comment">// 2cm</span></span><br><span class="line">  ec.setMinClusterSize (<span class="number">100</span>);</span><br><span class="line">  ec.setMaxClusterSize (<span class="number">25000</span>);</span><br><span class="line">  ec.setSearchMethod (tree);</span><br><span class="line">  ec.setInputCloud (cloud_filtered);</span><br><span class="line">  ec.extract (cluster_indices);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pcl::PointIndices&gt;::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it)&#123;</span><br><span class="line">    pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_cluster</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator pit = it-&gt;indices.begin (); pit != it-&gt;indices.end (); ++pit)</span><br><span class="line">      cloud_cluster-&gt;push_back ((*cloud_filtered)[*pit]); <span class="comment">//*</span></span><br><span class="line">    cloud_cluster-&gt;width = cloud_cluster-&gt;size ();</span><br><span class="line">    cloud_cluster-&gt;height = <span class="number">1</span>;</span><br><span class="line">    cloud_cluster-&gt;is_dense = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;PointCloud representing the Cluster: &quot;</span> &lt;&lt; cloud_cluster-&gt;size () &lt;&lt; <span class="string">&quot; data points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;cloud_cluster_&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;.pcd&quot;</span>;</span><br><span class="line">    writer.write&lt;pcl::PointXYZ&gt; (ss.str (), *cloud_cluster, <span class="literal">false</span>); <span class="comment">//*</span></span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区域分割"><a class="markdownIt-Anchor" href="#区域分割"></a> 区域分割</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/search/search.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/search/kdtree.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/features/normal_3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/cloud_viewer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/passthrough.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/segmentation/region_growing.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> ( pcl::io::loadPCDFile &lt;pcl::PointXYZ&gt; (<span class="string">&quot;region_growing_tutorial.pcd&quot;</span>, *cloud) == <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cloud reading failed.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pcl::search::Search&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  pcl::PointCloud &lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud &lt;pcl::Normal&gt;)</span></span>;</span><br><span class="line">  pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; normal_estimator;</span><br><span class="line">  normal_estimator.setSearchMethod (tree);</span><br><span class="line">  normal_estimator.setInputCloud (cloud);</span><br><span class="line">  normal_estimator.setKSearch (<span class="number">50</span>);</span><br><span class="line">  normal_estimator.compute (*normals);</span><br><span class="line">  <span class="function">pcl::IndicesPtr <span class="title">indices</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;)</span></span>;</span><br><span class="line">  pcl::PassThrough&lt;pcl::PointXYZ&gt; pass;</span><br><span class="line">  pass.setInputCloud (cloud);</span><br><span class="line">  pass.setFilterFieldName (<span class="string">&quot;z&quot;</span>);</span><br><span class="line">  pass.setFilterLimits (<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">  pass.filter (*indices);</span><br><span class="line">  pcl::RegionGrowing&lt;pcl::PointXYZ, pcl::Normal&gt; reg;</span><br><span class="line">  reg.setMinClusterSize (<span class="number">50</span>);</span><br><span class="line">  reg.setMaxClusterSize (<span class="number">1000000</span>);</span><br><span class="line">  reg.setSearchMethod (tree);</span><br><span class="line">  reg.setNumberOfNeighbours (<span class="number">30</span>);</span><br><span class="line">  reg.setInputCloud (cloud);</span><br><span class="line">  <span class="comment">//reg.setIndices (indices);</span></span><br><span class="line">  reg.setInputNormals (normals);</span><br><span class="line">  reg.setSmoothnessThreshold (<span class="number">3.0</span> / <span class="number">180.0</span> * M_PI);</span><br><span class="line">  reg.setCurvatureThreshold (<span class="number">1.0</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;pcl::PointIndices&gt; clusters;</span><br><span class="line">  reg.extract (clusters);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Number of clusters is equal to &quot;</span> &lt;&lt; clusters.size () &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;First cluster has &quot;</span> &lt;&lt; clusters[<span class="number">0</span>].indices.size () &lt;&lt; <span class="string">&quot; points.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;These are the indices of the points of the initial&quot;</span> &lt;&lt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;cloud that belong to the first cluster:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (counter &lt; clusters[<span class="number">0</span>].indices.size ())&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; clusters[<span class="number">0</span>].indices[counter] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span> (counter % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pcl::PointCloud &lt;pcl::PointXYZRGB&gt;::Ptr colored_cloud = reg.getColoredCloud ();</span><br><span class="line">  pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span> <span class="params">(<span class="string">&quot;Cluster viewer&quot;</span>)</span></span>;</span><br><span class="line">  viewer.showCloud(colored_cloud);</span><br><span class="line">  <span class="keyword">while</span> (!viewer.wasStopped ())  &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配准"><a class="markdownIt-Anchor" href="#配准"></a> 配准</h1>
<h2 id="icp"><a class="markdownIt-Anchor" href="#icp"></a> ICP</h2>
<p><strong>算法步骤：</strong></p>
<ul>
<li>
<p>(1)对点集A中每个点Pa施加出事变换T0，得到Pa’；</p>
</li>
<li>
<p>(2)从点集B中寻找距离点Pa’最近的点Pb，形成对应点对；</p>
</li>
<li>
<p>(3)求解最优变换△T；</p>
</li>
<li>
<p>(4)根据前后两次的迭代误差以及迭代次数等条件判断是否收敛，如果收敛，则输出最终结果：<code>T=△T*T0</code>，否则<code>T0=△T*T0</code>，重复步骤(1)</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">△</mi><mi>T</mi><mo>=</mo><mo><mi mathvariant="normal">arg min</mi><mo>⁡</mo></mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></msub><mi>n</mi><mi mathvariant="normal">∥</mi><msub><mi>p</mi><mrow><mi>b</mi><mi>i</mi></mrow></msub><mo>−</mo><mo stretchy="false">(</mo><mi>R</mi><msub><mi>p</mi><mrow><mi>a</mi><mi>i</mi></mrow></msub><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><msubsup><mi mathvariant="normal">∥</mi><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\triangle T=\argmin\sum_{i=1}{n}\|p_{bi}-(Rp_{ai}+t)\|^2_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">△</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">m</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mord">∥</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">△</mi><mi>T</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>R</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>t</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\triangle T=\begin{bmatrix}R&amp;t\\0&amp;1\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">△</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></p>
</li>
</ul>
<p><strong>终止条件：</strong></p>
<ul>
<li>(1)最大迭代次数</li>
<li>(2)收敛标准：估计点云变换不再变化：当前变换和上次变换的差值之和小于用户定义的阈值</li>
<li>(3)找到解：误差平方和小于用户自定义阈值</li>
</ul>
<h3 id="简单使用-2"><a class="markdownIt-Anchor" href="#简单使用-2"></a> 简单使用</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pcl::IterativeClosestPoint&lt;pcl::PointXYZ,pcl::PointXYZ&gt; icp;</span><br><span class="line">icp.setInputCloud(cloud_in);</span><br><span class="line">icp.setInputTarget(cloud_out);</span><br><span class="line">icp.setMaximumIterations(nr_iterations);</span><br><span class="line">icp.setTransformationEpsilon(epsilon);</span><br><span class="line">icp.setEuclideanFitnessEpsilon(distance);</span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;Final;</span><br><span class="line">icp.align(Final);</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<table>
<thead>
<tr>
<th>常用接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例化</td>
<td><code>pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp;</code></td>
</tr>
<tr>
<td>最大迭代次数</td>
<td><code>icp.setMaximumIterations(100);</code></td>
</tr>
<tr>
<td>源点云，转换的点云</td>
<td><code>icp.setInputSource(cloud_in);</code></td>
</tr>
<tr>
<td>目标点云，参考点云</td>
<td><code>icp.setInputTarget(cloud_out);</code></td>
</tr>
<tr>
<td>设置查找近邻时是否双向搜索</td>
<td><code>icp.setUseReciprocalCorrespondences(false);</code></td>
</tr>
<tr>
<td>设置最大临近点距离，超过则不参与计算</td>
<td><code>icp.setMaxCorrespondenceDistance(0.5);</code></td>
</tr>
<tr>
<td>设置匹配对剔除器</td>
<td><code>icp.addCorrespondenceRejector(rejector);</code></td>
</tr>
<tr>
<td>设置迭代误差收敛阈值</td>
<td><code>icp.setEuclideanFitnessEpsilon(0.0001);</code></td>
</tr>
<tr>
<td>设置icp计算方法：SVD、LM</td>
<td><code>icp.setTransformationEstimation(te);</code></td>
</tr>
<tr>
<td>执行运算</td>
<td><code>icp.align(*cloud_icp);</code></td>
</tr>
<tr>
<td>获取icp是否收敛</td>
<td><code>icp.hasConverged();</code></td>
</tr>
<tr>
<td>获取icp匹配得到的变换矩阵</td>
<td><code>Eigen::Matrix4f transformation_matrix = icp.getFinalTransformation();</code></td>
</tr>
<tr>
<td>获取icp得分</td>
<td><code>icp.getFitnessScore();</code></td>
</tr>
</tbody>
</table>
<h2 id="点云配准方法"><a class="markdownIt-Anchor" href="#点云配准方法"></a> 点云配准方法</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Eigen::Matrix4f transformation;</span><br><span class="line">TransformationEstimationSVD&lt;PointT,PointT&gt;svd;</span><br><span class="line">svd.estimateRigidTransformation(src,target,corres,trans);</span><br></pre></td></tr></table></figure>
<h2 id="广义配准"><a class="markdownIt-Anchor" href="#广义配准"></a> 广义配准</h2>
<ul>
<li>ICP使用最近邻迭代搜索，容易调入局部极小，并且初始变换矩阵影响算法结果。广义配准利用点云特征匹配，可以很好的估计两组点云的变换状态，能够得到良好的效果。</li>
</ul>
<p><strong>算法步骤：</strong></p>
<ul>
<li>(1)采集原始点云，分析两个原点云关键点k；</li>
<li>(2)在每个关键点k处，计算相应的特征描述子f</li>
<li>(3)根据特征描述子f和对应的xyz坐标值，估计对应匹配关系；</li>
<li>(4)因为噪声或虚假匹配，并非所有的对应关系都有效，根据规则排除虚假对应匹配；</li>
<li>(5)根据有效对应匹配关系，估计刚体变换关系；</li>
</ul>
<h3 id="matching-features"><a class="markdownIt-Anchor" href="#matching-features"></a> Matching Features</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CorrespondenceEstimation&lt;FeatureT,FeatureT&gt;est;</span><br><span class="line">est.setInputClout(source_features);</span><br><span class="line">est.setInputTarget(target_features);</span><br><span class="line">est.determineCorrespondences(correspondences);</span><br></pre></td></tr></table></figure>
<h3 id="虚假匹配"><a class="markdownIt-Anchor" href="#虚假匹配"></a> 虚假匹配</h3>
<p><strong>用sac排除虚假匹配(outliers)</strong></p>
<ul>
<li>(1)选择三对对应匹配对d，m；</li>
<li>(2)估计选择样本的变换关系(R,t)；</li>
<li>(3)用((Rd+t)-m)2&lt;c确定内点对；</li>
<li>(4)重复N次，使得(R,t)有更多的内点；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CorrespondenceRejectorSampleConsensus&lt;PointT&gt; sac;</span><br><span class="line">sac.setInputCloud(source);</span><br><span class="line">sac.setTargetCloud(target);</span><br><span class="line">sac.setInlierThreshold(epsilon);</span><br><span class="line">sac.setMaxIterations(N);</span><br><span class="line">sac.setInputCorrespondences(correspondences);</span><br><span class="line">sac.getCorrespondences(inliers);</span><br><span class="line">Eigen::Matrix4f t_matrix = sac.getBestTransformation();</span><br></pre></td></tr></table></figure>
<p><strong>sac-ia(Sampled Consesus-Initial Alignment)</strong></p>
<ul>
<li>(1)在原点云中选择n个点d；</li>
<li>(2)对每个点d：1、选择k个最近匹配；2、选择其中一个为匹配点m；</li>
<li>(3)估计选择样本的变换关系(R,t)；</li>
<li>(4)用((Rd+t)-m)2&lt;c确定内点对；</li>
<li>(5)重复N次，使得(R,t)有更多的内点；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pcl::SampleConsensusInitalAlignment&lt;PointT,PointT,FeatureT&gt; sac_ia;</span><br><span class="line">sac_ia.setNumberOfSamples(n);</span><br><span class="line">sac_ia.setMinSampleDistance(d);</span><br><span class="line">sac_ia.setCorrespondenceRandomness(k);</span><br><span class="line">sac_ia.setMaximumIterations(N);</span><br><span class="line">sac_ia.setInputCloud(source);</span><br><span class="line">sac_ia.setInputTarget(target);</span><br><span class="line">sac_ia.setSourceFeatures(source_features);</span><br><span class="line">sac_ia.setTargetFeatures(target_features);</span><br><span class="line">sac_ia.align(aligned_source);</span><br><span class="line">Eigen::Matrix4f t_matrix = sac_ia.getFinalTransformation();</span><br></pre></td></tr></table></figure>
<h3 id="接口-2"><a class="markdownIt-Anchor" href="#接口-2"></a> 接口</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>广义配准实例化</td>
<td><code>CorrespondenceEstimation&lt;FeatureT,FeatureT&gt;est;</code></td>
</tr>
<tr>
<td>输入点云</td>
<td><code>est.setInputSource(source_feature);</code></td>
</tr>
<tr>
<td>目标点云</td>
<td><code>est.setInputTarget(target_feature);</code></td>
</tr>
<tr>
<td>执行运算</td>
<td><code>est.determineCorrespondences(correspondences);</code></td>
</tr>
<tr>
<td>RANSAC去除虚假匹配</td>
<td><code>CorrespondenceRejectorSampleConsensus&lt;PointT&gt;sac;</code></td>
</tr>
<tr>
<td>输入点云</td>
<td><code>sac.setInputSource(source);</code></td>
</tr>
<tr>
<td>目标点云</td>
<td><code>sac.setInputTarget(target);</code></td>
</tr>
<tr>
<td>inlier阈值</td>
<td><code>sac.InlierThreshold(epsilon);</code></td>
</tr>
<tr>
<td>最大迭代次数</td>
<td><code>sac.setMaximumIterations(100);</code></td>
</tr>
<tr>
<td>执行运算</td>
<td><code>sac.setInputCorrespondences(correspondences);</code></td>
</tr>
<tr>
<td>执行运算</td>
<td><code>sac.getInputCorrespondences(inliers);</code></td>
</tr>
<tr>
<td>获取匹配的变换矩阵</td>
<td><code>Eigen::Matrix4f transformation_matrix = sac.getBestTransformation();</code></td>
</tr>
<tr>
<td>SAC-IA初始对齐</td>
<td><code>SampleConsensusInitialAlignment&lt;PointT,PointT,FeatureT&gt;sac_ia;</code></td>
</tr>
<tr>
<td>输入点云</td>
<td><code>sac_ia.setInputCloud(source);</code></td>
</tr>
<tr>
<td>目标点云</td>
<td><code>sac_ia.setInputTarget(target);</code></td>
</tr>
<tr>
<td>特征点个数</td>
<td><code>sac_ia.setNumberOfSamples(n);</code></td>
</tr>
<tr>
<td>最小距离</td>
<td><code>sac_ia.setMinSampleDistance(d);</code></td>
</tr>
<tr>
<td>随机参数</td>
<td><code>sac_ia.setCorrespondenceRandomness(k);</code></td>
</tr>
<tr>
<td>最大迭代次数</td>
<td><code>sac_ia.setMaximumIterations(100);</code></td>
</tr>
<tr>
<td>输入特征</td>
<td><code>sac_ia.setSourceFeatures(source_features);</code></td>
</tr>
<tr>
<td>目标特征</td>
<td><code>sac_ia.setTargetFeatures(target_features);</code></td>
</tr>
<tr>
<td>获取匹配的变换矩阵</td>
<td><code>Eigen::Matrix4f transformation_matrix = sac_ia.getFinalTransformation();</code></td>
</tr>
</tbody>
</table>
<h2 id="配准api"><a class="markdownIt-Anchor" href="#配准api"></a> 配准API</h2>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CorrespondenceEstimation</code></td>
<td>确定两点云中对应匹配关系</td>
</tr>
<tr>
<td><code>CorrespondenceRejectorFeatures</code></td>
<td>能够实现基于特征匹配的对应点对提取</td>
</tr>
<tr>
<td><code>SampleConsensusPrerejective</code></td>
<td>实现了基于RANSAC方法的对应对外点去除，用于姿态评估和点云配准中的几何一致性限制</td>
</tr>
<tr>
<td><code>TransformationEstimation3Point</code></td>
<td>实现使用三个匹配点计算两点云变换矩阵</td>
</tr>
<tr>
<td><code>TransfromationFromCorrsespondences</code></td>
<td>实现三个及以上匹配点间变换矩阵的计算</td>
</tr>
<tr>
<td><code>TransfromationEstimationDQ</code><br><code>TransfromationEstimationDualQuaternion</code></td>
<td>实现基于对偶四元数的点云姿态估计</td>
</tr>
<tr>
<td><code>TransfromationEstimationLM</code></td>
<td>实现基于对应匹配点对，用LM优化的变换矩阵估计</td>
</tr>
<tr>
<td><code>TransfromationEstimationPointToPlane</code></td>
<td>实现基于LM优化的匹配点对间最小点到平面距离的最优变换矩阵计算</td>
</tr>
<tr>
<td><code>TransfromationEstimationPointtoPlaneWeighted</code></td>
<td>在TransfromationEstimationPointToPlane基础上加入了对应匹配点的权重，以适应更为复杂场景点云配准任务</td>
</tr>
<tr>
<td><code>TransfromationEstimationPointToPlaneLLS</code></td>
<td>基于现行最小二乘的点到平面距离累计最小化约束，对应点到平面的距离计算加入法向量约束</td>
</tr>
<tr>
<td><code>TransfromationEstimationPointToPlaneLLSWeighted</code></td>
<td>带权重的PointToPlaneLLS</td>
</tr>
<tr>
<td><code>TransfromationEstimationSVD</code></td>
<td>使用SVD分解策略完成匹配点对的变换矩阵计算</td>
</tr>
<tr>
<td><code>TransfromationEstimationEuclidean</code></td>
<td>实现了给定对应匹配的变换，并计算可靠性得分</td>
</tr>
<tr>
<td><code>IterativeClosestPoint</code></td>
<td>ICP算法</td>
</tr>
<tr>
<td><code>IterativeClosestPointNoLinear</code></td>
<td>ICP后端使用LM作为优化</td>
</tr>
<tr>
<td><code>GeneratlizedIterativeClosestPoint</code></td>
<td>一般化ICP算法</td>
</tr>
<tr>
<td><code>GeneratlizedIterativeClosestPoint6D</code></td>
<td>集成L<em>a</em>b颜色空间到Generalized-ICP中</td>
</tr>
<tr>
<td><code>IterativeClosestPointWithNormal</code></td>
<td>以点到平面的最小距离作为迭代优化对象实现ICP配准</td>
</tr>
<tr>
<td><code>FPCSInitialAlignment</code></td>
<td></td>
</tr>
<tr>
<td><code>KFPCSInitialAlignment</code></td>
<td></td>
</tr>
<tr>
<td><code>NormalDistributionsTransform</code></td>
<td>NDT方法</td>
</tr>
</tbody>
</table>
<h1 id="关键点"><a class="markdownIt-Anchor" href="#关键点"></a> 关键点</h1>
<ul>
<li>pcl::keypoints类</li>
</ul>
<h2 id="iss"><a class="markdownIt-Anchor" href="#iss"></a> ISS</h2>
<table>
<thead>
<tr>
<th>ISS</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例化</td>
<td><code>pcl::ISSKeypoint3d&lt;pcl::PointXYZ，pcl::PointXYZ&gt;iss_detector;</code></td>
</tr>
<tr>
<td>-</td>
<td><code>pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;)</code><br><code>iss_detector.setSearchMethod(tree)</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.setSalientRadius(support_radius)</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.setNonMaxRadius(nms_radius);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.setThreshold21(0.975);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.setThreshold32(0.975);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.setMinNeighbors(5);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.setNumberOfThreads(4);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.setInputCloud(cloud);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>iss_detector.compute(keyPoints);</code></td>
</tr>
</tbody>
</table>
<h2 id="harris3d"><a class="markdownIt-Anchor" href="#harris3d"></a> Harris3D</h2>
<table>
<thead>
<tr>
<th>Harris3D</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例化</td>
<td><code>pcl::HarrisKeypoint3d&lt;pcl::PointXYZ，pcl::PointXYZI,pcl::Normal&gt;harris;</code>输出保存在I分量</td>
</tr>
<tr>
<td>-</td>
<td><code>harris.setInputCloud(point_cloud_ptr);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>harris.setNonMaxSupression(true);</code></td>
</tr>
<tr>
<td>块半径</td>
<td><code>harris.setRadius(0.02f);</code></td>
</tr>
<tr>
<td>数量阈值</td>
<td><code>harris.setThreshold(0.01f);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>harris.compute(cloud_out);</code></td>
</tr>
</tbody>
</table>
<h2 id="sift"><a class="markdownIt-Anchor" href="#sift"></a> SIFT</h2>
<table>
<thead>
<tr>
<th>SIFT</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例化</td>
<td><code>pcl::SIFTKeypoint&lt;pcl::PointXYZ，pcl::PointWithScale&gt;sift_src;</code></td>
</tr>
<tr>
<td>-</td>
<td><code>sift_src.setSearchMethod(tree);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>sift_src.setScales(min_scale,n_octaves,n_scales_per_octave);</code>min_scale：尺度空间中最小尺度,n_octaves：尺度空间层数,n_scales_per_octave：尺度空间层中计算的尺度个数</td>
</tr>
<tr>
<td>-</td>
<td><code>sift_src.setMinimumContrast(min_contrast);</code>min_contrast：根据点云设置，越小关键点越多</td>
</tr>
<tr>
<td>-</td>
<td><code>sift_src.setInputCloud(cloud_src);</code></td>
</tr>
<tr>
<td>-</td>
<td><code>sift_src.compute(result);</code></td>
</tr>
</tbody>
</table>
<h1 id="描述子"><a class="markdownIt-Anchor" href="#描述子"></a> 描述子</h1>
<ul>
<li>pcl::features类</li>
<li>局部描述子
<ul>
<li>Spin Image</li>
<li>3DSC</li>
<li>PFH/FPFH</li>
<li>SHOT/SHOT for RGBD</li>
</ul>
</li>
<li>全局描述子
<ul>
<li>基于直方图
<ul>
<li>Shape Distributions</li>
<li>3D Shape Histograms</li>
<li>Orientation Histograms</li>
<li>Viewpoint Feature Histogram</li>
<li>Clustered VFH</li>
<li>OUR-CVFH</li>
</ul>
</li>
<li>基于变换
<ul>
<li>3D Fourier Transform</li>
<li>Angular Radial Tr.</li>
<li>3D Radon Tr</li>
<li>Spherical Harmonics</li>
<li>wavelets</li>
</ul>
</li>
<li>基于2D
<ul>
<li>Fourier Descriptors</li>
<li>Zernike Moments</li>
<li>SIFT</li>
<li>SURF</li>
</ul>
</li>
<li>基于连通图
<ul>
<li>topology-based</li>
<li>Reeb graph</li>
<li>skeleton-based</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="方法-2"><a class="markdownIt-Anchor" href="#方法-2"></a> 方法</h2>
<p>方法|说明<br />
Spin Image|<code>pcl::SpinImageEstimation</code><br />
3D Unique shape Contexts|<code>pcl::ShapeContext3DEstimation</code><br />
PFH/FPFH|<code>pcl::PFHEstimation</code><br><code>pcl::FPFHEstimation</code><br />
SHOT/SHOT for RGBD|<code>pcl::SHOTEstimation</code><br><code>pcl::SHOTColorEstimation</code></p>
<h2 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/registration/icp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_in</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;(<span class="number">5</span>,<span class="number">1</span>))</span></span>;</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud_out</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">  <span class="comment">// Fill in the CloudIn data</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point : *cloud_in)  &#123;</span><br><span class="line">    point.x = <span class="number">1024</span> * rand() / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.y = <span class="number">1024</span> * rand() / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">    point.z = <span class="number">1024</span> * rand() / (RAND_MAX + <span class="number">1.0f</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Saved &quot;</span> &lt;&lt; cloud_in-&gt;size () &lt;&lt; <span class="string">&quot; data points to input:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point : *cloud_in)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  *cloud_out = *cloud_in;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; cloud_out-&gt;size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point : *cloud_out)</span><br><span class="line">    point.x += <span class="number">0.7f</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Transformed &quot;</span> &lt;&lt; cloud_in-&gt;size () &lt;&lt; <span class="string">&quot; data points:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; point : *cloud_out)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; point &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pcl::IterativeClosestPoint&lt;pcl::PointXYZ, pcl::PointXYZ&gt; icp;</span><br><span class="line">  icp.setInputSource(cloud_in);</span><br><span class="line">  icp.setInputTarget(cloud_out);</span><br><span class="line">  pcl::PointCloud&lt;pcl::PointXYZ&gt; Final;</span><br><span class="line">  icp.align(Final);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;has converged:&quot;</span> &lt;&lt; icp.hasConverged() &lt;&lt; <span class="string">&quot; score: &quot;</span> &lt;&lt;</span><br><span class="line">  icp.getFitnessScore() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; icp.getFinalTransformation() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/robotic/">robotic</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/05/opengl/"><i class="fa fa-chevron-left">  </i><span>OpenGL</span></a></div><div class="next-post pull-right"><a href="/2020/09/25/eigen/"><span>eigen</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'AdfkiqY89QUSUWbDY9xJuCh0-gzGzoHsz',
  appKey:'2cEvHcqEWsyoKwy4AUL3kPGh',
  placeholder:'劈个叉吧',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'100',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By hero576</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>