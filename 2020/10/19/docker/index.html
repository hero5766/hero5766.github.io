<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="docker"><meta name="keywords" content="skills"><meta name="author" content="hero576"><meta name="copyright" content="hero576"><title>docker | void land space</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5ff8fca367285c16c6dd5c16ca2ccc1b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.0.2'
} </script><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="void land space" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text"> 介绍[1]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text"> 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text"> 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%95%9C%E5%83%8F%E6%BA%90"><span class="toc-number">1.4.</span> <span class="toc-text"> 更新镜像源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text"> 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text"> 运行容器方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.</span> <span class="toc-text"> 容器状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">3.</span> <span class="toc-text"> 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.</span> <span class="toc-text"> 创建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%9B%B4%E6%96%B0%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 从已经创建的容器中更新镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-dockerfile-%E6%8C%87%E4%BB%A4%E6%9D%A5%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 使用 Dockerfile 指令来创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.</span> <span class="toc-text"> 连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text"> DNS配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> 仓库管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dockerfile"><span class="toc-number">5.</span> <span class="toc-text"> Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-dockerfile-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F"><span class="toc-number">5.1.</span> <span class="toc-text"> 使用 Dockerfile 定制镜像</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/haimianbaobao.jpg"></div><div class="author-info__name text-center">hero576</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">void land space</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">docker</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/common/"> common</a></div><div class="article-container" id="post-content"><blockquote></blockquote>
<a id="more"></a>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<ul>
<li>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</li>
<li>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</li>
<li>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</li>
</ul>
<h2 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h2>
<ul>
<li>Docker 包括三个基本概念:</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>镜像（Image）</td>
<td>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</td>
</tr>
<tr>
<td>容器（Container）</td>
<td>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</td>
</tr>
<tr>
<td>仓库（Repository）</td>
<td>仓库可看成一个代码控制中心，用来保存镜像。</td>
</tr>
</tbody>
</table>
<ul>
<li>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</li>
<li>Docker 容器通过 Docker 镜像来创建。</li>
</ul>
<p><img src="/images/pasted-303.png" alt="docker架构" /></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker 镜像(Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td>Docker 容器(Container)</td>
<td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td>Docker 客户端(Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>Docker 主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td>Docker Registry</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<br>Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。<br>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</td>
</tr>
<tr>
<td>Docker Machine</td>
<td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody>
</table>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/ubuntu-docker-install.html">安装教程</a>，选择合适的操作系统</p>
</li>
<li>
<p>验证安装：<code>docker -v</code></p>
</li>
<li>
<p>配置免sudo运行docker：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker <span class="comment"># add dockergroup</span></span><br><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker <span class="comment"># add user to docker group</span></span><br><span class="line">sudo service docker restart <span class="comment"># reboot docker service</span></span><br><span class="line">newgrp docker <span class="comment"># change current user to new group</span></span><br><span class="line">docker ps <span class="comment"># ensure docker can run normally without sudo</span></span><br></pre></td></tr></table></figure>
<h2 id="更新镜像源"><a class="markdownIt-Anchor" href="#更新镜像源"></a> 更新镜像源</h2>
<ul>
<li>
<p>docker官方源里的 Docker 版本比较旧，我们需要配置一个<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">国内源</a>，阿里的或者中科大的都可以。</p>
</li>
<li>
<p>修改配置文件：<code>$ sudo vim /etc/docker/daemon.json</code></p>
</li>
<li>
<p>内容：</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;registry-mirrors&quot;</span>:[<span class="string">&quot;https://6kx4zyno.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h1>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动容器</td>
<td><code>docker run -it ubuntu /bin/bash</code></td>
<td>-t: 在新容器内指定一个伪终端或终端。<br>-i: 允许你对容器内的标准输入 (STDIN) 进行交互。<br>加了 -d 参数容器会进入后台运行，默认不会进入容器，想要进入容器需要使用指令<code>docker exec</code><br>-P:将容器内部使用的网络端口随机映射到我们使用的主机上。<br> -p:设置指定的映射端口：<code>-p 5000:5000</code><br>–name: 标识来命名容器，没有指定docker会默认命名<br>-v：虚拟机和宿主机文件关联起来：<code>-v$(pwd):/data</code></td>
</tr>
<tr>
<td>查看容器状态</td>
<td><code>docker ps -a</code></td>
<td>-a：查询所用容器，包括已停止的<br>-l:查询最后一次创建的容器</td>
</tr>
<tr>
<td>停止容器</td>
<td><code>docker stop CONTAINERID/NAME</code></td>
<td></td>
</tr>
<tr>
<td>查看容器内的标准输出</td>
<td><code>docker logs CONTAINERID/NAME</code></td>
<td>-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。</td>
</tr>
<tr>
<td>指令查询帮助</td>
<td><code>docker COMMAND --help</code></td>
<td><code>docker stats --help</code></td>
</tr>
<tr>
<td>获取镜像</td>
<td><code>docker pull ubuntu</code></td>
<td></td>
</tr>
<tr>
<td>启动已停止运行的容器</td>
<td><code>docker start CONTAINERID/NAME</code></td>
<td></td>
</tr>
<tr>
<td>重启容器</td>
<td><code>docker restart CONTAINERID/NAME</code></td>
<td></td>
</tr>
<tr>
<td>进入到正在运行的容器</td>
<td><code>docker attach CONTAINERID/NAME</code></td>
<td>使用<code>docker attach</code>如果从这个容器退出，会导致容器的停止。</td>
</tr>
<tr>
<td>在运行容器中运行命令</td>
<td><code>docker exec CONTAINERID/NAME /bin/bash</code></td>
<td>推荐大家使用<code>docker exec</code>命令而不是attach，因为此退出容器终端，不会导致容器的停止。</td>
</tr>
<tr>
<td>将容器的文件系统导出为tar存档</td>
<td><code>docker export CONTAINERID/NAME &gt; ubuntu.tar</code></td>
<td>导出容器快照到本地文件 ubuntu.tar。</td>
</tr>
<tr>
<td>导入容器</td>
<td><code>cat ubuntu.tar|docker import - test/ubuntu:v1</code><br><code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></td>
<td>可以使用 docker import 从容器快照文件中再导入为镜像<br>也可以通过指定 URL 或者某个目录来导入</td>
</tr>
<tr>
<td>删除容器</td>
<td><code>docker rm -f CONTAINERID/NAME</code></td>
<td></td>
</tr>
<tr>
<td>清理掉所有处于终止状态的容器</td>
<td><code>docker container prune</code></td>
<td></td>
</tr>
<tr>
<td>查看网络端口与主机映射</td>
<td><code>docker port CONTAINERID/NAME</code></td>
<td></td>
</tr>
<tr>
<td>容器容器运行的进程</td>
<td><code>docker top CONTAINERID/NAME</code></td>
<td></td>
</tr>
<tr>
<td>显示一个或多个容器的详细信息</td>
<td><code>docker inspect CONTAINERID/NAME</code></td>
<td>返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</td>
</tr>
<tr>
<td>从容器的更改创建一个新的映像</td>
<td><code>docker commit</code></td>
<td></td>
</tr>
<tr>
<td>在容器和本地文件系统之间复制文件/文件夹</td>
<td><code>docker cp</code></td>
<td></td>
</tr>
<tr>
<td>创建一个新的容器</td>
<td><code>docker create</code></td>
<td></td>
</tr>
<tr>
<td>检查容器文件系统上文件或目录的更改</td>
<td><code>docker diff</code></td>
<td></td>
</tr>
<tr>
<td>杀死一个或多个运行容器</td>
<td><code>docker kill</code></td>
<td></td>
</tr>
<tr>
<td>列出容器</td>
<td><code>docker ls</code></td>
<td>-a：显示所有容器(默认只显示运行的)<br>-l：显示最新创建的容器(包括所有状态)<br>-q：只显示数字ID<br>-s：显示文件大小<br>–format：使用Go模板打印容器<br>–no-trunc：不要截断输出<br>-f：根据提供的条件过滤输出<br>-n	-1：显示最后创建的容器(包括所有状态)</td>
</tr>
<tr>
<td>暂停一个或多个容器内的所有进程</td>
<td><code>docker pause</code></td>
<td></td>
</tr>
<tr>
<td>重命名容器</td>
<td><code>docker rename</code></td>
<td></td>
</tr>
<tr>
<td>显示容器的实时流资源使用统计信息</td>
<td><code>docker stats</code></td>
<td></td>
</tr>
<tr>
<td>取消暂停一个或多个容器内的所有流程</td>
<td><code>docker unpause</code></td>
<td></td>
</tr>
<tr>
<td>更新一个或多个容器的配置</td>
<td><code>docker update</code></td>
<td></td>
</tr>
<tr>
<td>阻止一个或多个容器停止，然后打印退出代码</td>
<td><code>docker wait</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="运行容器方式"><a class="markdownIt-Anchor" href="#运行容器方式"></a> 运行容器方式</h2>
<ul>
<li>直接运行：<code>docker run ubuntu /bin/bash echo &quot;hello&quot;</code>，docker启动linux容器，并在容器中执行语句并输出到终端</li>
<li>交互式容器：<code>docker run -it ubuntu /bin/bash</code></li>
<li>启动后台模式：<code>docker run -d ubuntu /bin/sh -c</code>，输出容器ID</li>
</ul>
<h2 id="容器状态"><a class="markdownIt-Anchor" href="#容器状态"></a> 容器状态</h2>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>created</td>
<td>已创建</td>
</tr>
<tr>
<td>restarting</td>
<td>重启中</td>
</tr>
<tr>
<td>running</td>
<td>运行中</td>
</tr>
<tr>
<td>removing</td>
<td>迁移中</td>
</tr>
<tr>
<td>paused</td>
<td>暂停</td>
</tr>
<tr>
<td>exited</td>
<td>停止</td>
</tr>
<tr>
<td>dead</td>
<td>死亡</td>
</tr>
</tbody>
</table>
<h1 id="镜像"><a class="markdownIt-Anchor" href="#镜像"></a> 镜像</h1>
<p>-当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<ul>
<li>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本。如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</li>
<li>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>镜像列表</td>
<td><code>docker images</code></td>
<td></td>
</tr>
<tr>
<td>获取镜像</td>
<td><code>docker pull ubuntu:13.10</code></td>
<td></td>
</tr>
<tr>
<td>查找镜像</td>
<td><code>docker search httpd</code></td>
<td>Docker Hub 网址为： <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></td>
</tr>
<tr>
<td>拖取镜像</td>
<td><code>docker pull httpd</code></td>
<td></td>
</tr>
<tr>
<td>删除镜像</td>
<td><code>docker rmi httpd</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="创建镜像"><a class="markdownIt-Anchor" href="#创建镜像"></a> 创建镜像</h2>
<ul>
<li>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。
<ul>
<li>
<ol>
<li>从已经创建的容器中更新镜像，并且提交这个镜像</li>
</ol>
</li>
<li>
<ol start="2">
<li>使用 Dockerfile 指令来创建一个新的镜像</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="从已经创建的容器中更新镜像"><a class="markdownIt-Anchor" href="#从已经创建的容器中更新镜像"></a> 从已经创建的容器中更新镜像</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>提交容器</td>
<td><code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></td>
<td>返回sha256，-m: 提交的描述信息<br>-a: 指定镜像作者<br>e218edb10161：容器 ID<br>runoob/ubuntu:v2: 指定要创建的目标镜像名</td>
</tr>
<tr>
<td>查看新镜像</td>
<td><code>docker images</code></td>
<td></td>
</tr>
<tr>
<td>使用新镜像启动容器</td>
<td><code>docker run -t -i runoob/ubuntu:v2 /bin/bash</code></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="使用-dockerfile-指令来创建"><a class="markdownIt-Anchor" href="#使用-dockerfile-指令来创建"></a> 使用 Dockerfile 指令来创建</h3>
<ul>
<li>首先要创建<code>Dockerfile</code>文件：<code>vi Dockerfile</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>    centos:<span class="number">6.7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>      Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     useradd runoob</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;runoob:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">22</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">     /usr/sbin/sshd -D</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</li>
<li>第一条FROM，指定使用哪个镜像源</li>
<li>RUN 指令告诉docker 在镜像内执行命令，安装了什么。</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>构建镜像</td>
<td><code>docker build -t runoob/centos:6.7 .</code></td>
<td>-t ：指定要创建的目标镜像名<br>. ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</td>
</tr>
<tr>
<td>查看创建的镜像</td>
<td><code>docker images</code></td>
<td></td>
</tr>
<tr>
<td>使用新镜像创建容器</td>
<td><code>docker run -t -i runoob/centos:6.7 /bin/bash</code></td>
<td></td>
</tr>
<tr>
<td>设置镜像标签</td>
<td><code>docker tag 860c279d2fec runoob/centos:dev</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h2>
<ul>
<li>Docker 容器互联：端口映射并不是唯一把 docker 连接到另一个容器的方法。docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>新建网络</td>
<td><code>docker network create -d bridge test-net</code></td>
<td>-d：参数指定 Docker 网络类型，有 bridge、overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</td>
</tr>
<tr>
<td>查询网络</td>
<td><code>docker network ls</code></td>
<td></td>
</tr>
<tr>
<td>连接容器</td>
<td>运行一个容器并连接到新建的网络<code>docker run -itd --name test1 --network test-net ubuntu /bin/bash</code><br>打开新的终端，再运行一个容器并加入到 test-net 网络:<code>docker run -itd --name test2 --network test-net ubuntu /bin/bash</code><br>通过 ping 来证明 test1 容器和 test2 容器建立了互联关系:<code>ping test2</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="dns配置"><a class="markdownIt-Anchor" href="#dns配置"></a> DNS配置</h2>
<p><strong>全局设置</strong></p>
<ul>
<li>我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。配置完，需要重启 docker 才能生效。</li>
<li>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：<code>docker run -it --rm ubuntu cat etc/resolv.conf</code></li>
</ul>
<p><strong>手动设置</strong></p>
<ul>
<li>如果只想在指定的容器设置 DNS，则可以使用以下命令：</li>
<li><code>docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu</code></li>
<li>参数说明：
<ul>
<li>–rm：容器退出时自动清理容器内部的文件系统。</li>
<li>-h HOSTNAME 或者 --hostname=HOSTNAME： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</li>
<li>–dns=IP_ADDRESS： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</li>
<li>–dns-search=DOMAIN： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <a target="_blank" rel="noopener" href="http://host.example.com">host.example.com</a>。</li>
</ul>
</li>
</ul>
<h1 id="仓库管理"><a class="markdownIt-Anchor" href="#仓库管理"></a> 仓库管理</h1>
<ul>
<li>仓库（Repository）是集中存放镜像的地方。
<ul>
<li>docker hub</li>
<li><a href="cr.console.aliyun.com">aliyun</a></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>注册</td>
<td>在 <a target="_blank" rel="noopener" href="https://hub.docker.com">https://hub.docker.com</a> 免费注册一个 Docker 账号。</td>
</tr>
<tr>
<td>登录</td>
<td><code>docker login</code>，登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</td>
</tr>
<tr>
<td>退出</td>
<td><code>docker logout</code></td>
</tr>
<tr>
<td>推送镜像</td>
<td><code>docker tag ubuntu:18.04 username/ubuntu:18.04</code><br><code>docker push username/ubuntu:18.04</code><br><code>docker search username/ubuntu</code></td>
</tr>
</tbody>
</table>
<h1 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h1>
<ul>
<li>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</li>
</ul>
<h2 id="使用-dockerfile-定制镜像"><a class="markdownIt-Anchor" href="#使用-dockerfile-定制镜像"></a> 使用 Dockerfile 定制镜像</h2>
<ul>
<li>
<p>新建Dockerfile文件</p>
<ul>
<li>在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;这是一个本地构建的nginx镜像&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>FROM指令</p>
<ul>
<li>定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</li>
</ul>
</li>
<li>
<p>RUN指令</p>
<ul>
<li>
<p>用于执行后面跟着的命令行命令。有以下两种格式：<br />
<strong>shell 格式：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></pre></td></tr></table></figure>
<p><strong>exec 格式：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line"># 例如：</span><br><span class="line"># RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。以 &amp;&amp; 符号连接命令，这样执行后，只会创建 1 层镜像。</p>
</li>
</ul>
</li>
<li>
<p>开始构建镜像：<code>docker build -t nginx:v3 .</code></p>
</li>
<li>
<p>查看是否构建成功：<code>docker images</code></p>
</li>
<li>
<p>上下文路径<br />
上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p>
<blockquote>
<p>解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</p>
</blockquote>
<ul>
<li>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</li>
</ul>
<blockquote>
<p>注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
</blockquote>
</li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-architecture.html">链接</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/skills/">skills</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/21/colab/"><i class="fa fa-chevron-left">  </i><span>Google Colab</span></a></div><div class="next-post pull-right"><a href="/2020/10/15/pytorch/"><span>PyTorch</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'AdfkiqY89QUSUWbDY9xJuCh0-gzGzoHsz',
  appKey:'2cEvHcqEWsyoKwy4AUL3kPGh',
  placeholder:'劈个叉吧',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'100',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 By hero576</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>